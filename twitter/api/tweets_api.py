# coding: utf-8

"""
    Twitter API v2

    Twitter API v2 available endpoints  # noqa: E501

    The version of the OpenAPI document: 2.49
    Generated by: https://openapi-generator.tech
"""


from __future__ import absolute_import

import re  # noqa: F401

from pydantic import validate_arguments, ValidationError
from typing_extensions import Annotated

from datetime import datetime

from pydantic import Field, StrictBool, StrictStr, conint, constr

from typing import List, Literal, Optional

from twitter import models
from twitter.models import AddOrDeleteRulesRequest, AddOrDeleteRulesResponse, FilteredStreamingTweetResponse, Get2ListsIdTweetsResponse, Get2SpacesIdBuyersResponse, Get2SpacesIdTweetsResponse, Get2TweetsCountsAllResponse, Get2TweetsCountsRecentResponse, Get2TweetsIdQuoteTweetsResponse, Get2TweetsIdResponse, Get2TweetsResponse, Get2TweetsSample10StreamResponse, Get2TweetsSearchAllResponse, Get2TweetsSearchRecentResponse, Get2UsersIdLikedTweetsResponse, Get2UsersIdMentionsResponse, Get2UsersIdTimelinesReverseChronologicalResponse, Get2UsersIdTweetsResponse, RulesLookupResponse, StreamingTweetResponse, TweetCreateRequest, TweetCreateResponse, TweetDeleteResponse, TweetHideRequest, TweetHideResponse, UsersLikesCreateRequest, UsersLikesCreateResponse, UsersLikesDeleteResponse, UsersRetweetsCreateRequest, UsersRetweetsCreateResponse, UsersRetweetsDeleteResponse

from twitter.api_client import ApiClient
from twitter.exceptions import (  # noqa: F401
    ApiTypeError,
    ApiValueError
)


class TweetsApi(object):
    """NOTE: This class is auto generated by OpenAPI Generator
    Ref: https://openapi-generator.tech

    Do not edit the class manually.
    """

    def __init__(self, api_client=None):
        if api_client is None:
            api_client = ApiClient()
        self.api_client = api_client

    @validate_arguments
    def add_or_delete_rules(self, add_or_delete_rules_request : AddOrDeleteRulesRequest, dry_run : Annotated[Optional[StrictBool], Field(description="Dry Run can be used with both the add and delete action, with the expected result given, but without actually taking any action in the system (meaning the end state will always be as it was when the request was submitted). This is particularly useful to validate rule changes.")] = None, **kwargs) -> AddOrDeleteRulesResponse:  # noqa: E501
        """Add/Delete rules  # noqa: E501

        Add or delete rules from a User's active rule set. Users can provide unique, optionally tagged rules to add. Users can delete their entire rule set or a subset specified by rule ids or values.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.add_or_delete_rules(add_or_delete_rules_request, dry_run, async_req=True)
        >>> result = thread.get()

        :param add_or_delete_rules_request: (required)
        :type add_or_delete_rules_request: AddOrDeleteRulesRequest
        :param dry_run: Dry Run can be used with both the add and delete action, with the expected result given, but without actually taking any action in the system (meaning the end state will always be as it was when the request was submitted). This is particularly useful to validate rule changes.
        :type dry_run: bool
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: AddOrDeleteRulesResponse
        """
        kwargs['_return_http_data_only'] = True
        return self.add_or_delete_rules_with_http_info(add_or_delete_rules_request, dry_run, **kwargs)  # noqa: E501

    @validate_arguments
    def add_or_delete_rules_with_http_info(self, add_or_delete_rules_request : AddOrDeleteRulesRequest, dry_run : Annotated[Optional[StrictBool], Field(description="Dry Run can be used with both the add and delete action, with the expected result given, but without actually taking any action in the system (meaning the end state will always be as it was when the request was submitted). This is particularly useful to validate rule changes.")] = None, **kwargs):  # noqa: E501
        """Add/Delete rules  # noqa: E501

        Add or delete rules from a User's active rule set. Users can provide unique, optionally tagged rules to add. Users can delete their entire rule set or a subset specified by rule ids or values.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.add_or_delete_rules_with_http_info(add_or_delete_rules_request, dry_run, async_req=True)
        >>> result = thread.get()

        :param add_or_delete_rules_request: (required)
        :type add_or_delete_rules_request: AddOrDeleteRulesRequest
        :param dry_run: Dry Run can be used with both the add and delete action, with the expected result given, but without actually taking any action in the system (meaning the end state will always be as it was when the request was submitted). This is particularly useful to validate rule changes.
        :type dry_run: bool
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(AddOrDeleteRulesResponse, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'add_or_delete_rules_request',
            'dry_run'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in local_var_params['kwargs'].items():
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method add_or_delete_rules" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if local_var_params.get('dry_run') is not None:  # noqa: E501
            query_params.append(('dry_run', local_var_params['dry_run']))

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        if local_var_params['add_or_delete_rules_request']:
            body_params = local_var_params['add_or_delete_rules_request']

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'application/problem+json'])  # noqa: E501

        # HTTP header `Content-Type`
        content_types_list = local_var_params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if content_types_list:
                header_params['Content-Type'] = content_types_list

        # Authentication setting
        auth_settings = ['BearerToken']  # noqa: E501

        response_types_map = {
            200: "AddOrDeleteRulesResponse",
        }

        return self.api_client.call_api(
            '/2/tweets/search/stream/rules', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    @validate_arguments
    def create_tweet(self, tweet_create_request : TweetCreateRequest, **kwargs) -> TweetCreateResponse:  # noqa: E501
        """Creation of a Tweet  # noqa: E501

        Causes the User to create a Tweet under the authorized account.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.create_tweet(tweet_create_request, async_req=True)
        >>> result = thread.get()

        :param tweet_create_request: (required)
        :type tweet_create_request: TweetCreateRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: TweetCreateResponse
        """
        kwargs['_return_http_data_only'] = True
        return self.create_tweet_with_http_info(tweet_create_request, **kwargs)  # noqa: E501

    @validate_arguments
    def create_tweet_with_http_info(self, tweet_create_request : TweetCreateRequest, **kwargs):  # noqa: E501
        """Creation of a Tweet  # noqa: E501

        Causes the User to create a Tweet under the authorized account.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.create_tweet_with_http_info(tweet_create_request, async_req=True)
        >>> result = thread.get()

        :param tweet_create_request: (required)
        :type tweet_create_request: TweetCreateRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(TweetCreateResponse, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'tweet_create_request'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in local_var_params['kwargs'].items():
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_tweet" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        if local_var_params['tweet_create_request']:
            body_params = local_var_params['tweet_create_request']

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'application/problem+json'])  # noqa: E501

        # HTTP header `Content-Type`
        content_types_list = local_var_params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if content_types_list:
                header_params['Content-Type'] = content_types_list

        # Authentication setting
        auth_settings = ['OAuth2UserToken', 'UserToken']  # noqa: E501

        response_types_map = {
            201: "TweetCreateResponse",
        }

        return self.api_client.call_api(
            '/2/tweets', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    @validate_arguments
    def delete_tweet_by_id(self, id : Annotated[constr(strict=True, regex=r'/^[0-9]{1,19}$/'), Field(..., description="The ID of the Tweet to be deleted.")], **kwargs) -> TweetDeleteResponse:  # noqa: E501
        """Tweet delete by Tweet ID  # noqa: E501

        Delete specified Tweet (in the path) by ID.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.delete_tweet_by_id(id, async_req=True)
        >>> result = thread.get()

        :param id: The ID of the Tweet to be deleted. (required)
        :type id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: TweetDeleteResponse
        """
        kwargs['_return_http_data_only'] = True
        return self.delete_tweet_by_id_with_http_info(id, **kwargs)  # noqa: E501

    @validate_arguments
    def delete_tweet_by_id_with_http_info(self, id : Annotated[constr(strict=True, regex=r'/^[0-9]{1,19}$/'), Field(..., description="The ID of the Tweet to be deleted.")], **kwargs):  # noqa: E501
        """Tweet delete by Tweet ID  # noqa: E501

        Delete specified Tweet (in the path) by ID.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.delete_tweet_by_id_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param id: The ID of the Tweet to be deleted. (required)
        :type id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(TweetDeleteResponse, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in local_var_params['kwargs'].items():
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_tweet_by_id" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        collection_formats = {}

        path_params = {}
        if local_var_params['id']:
            path_params['id'] = local_var_params['id']

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'application/problem+json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['OAuth2UserToken', 'UserToken']  # noqa: E501

        response_types_map = {
            200: "TweetDeleteResponse",
        }

        return self.api_client.call_api(
            '/2/tweets/{id}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    @validate_arguments
    def find_tweet_by_id(self, id : Annotated[constr(strict=True, regex=r'/^[0-9]{1,19}$/'), Field(..., description="A single Tweet ID.")], tweet_fields : Annotated[Optional[List[Literal['attachments', 'author_id', 'context_annotations', 'conversation_id', 'created_at', 'entities', 'geo', 'id', 'in_reply_to_user_id', 'lang', 'non_public_metrics', 'organic_metrics', 'possibly_sensitive', 'promoted_metrics', 'public_metrics', 'referenced_tweets', 'reply_settings', 'source', 'text', 'withheld']]], Field(description="A comma separated list of Tweet fields to display.", unique_items=True)] = None, expansions : Annotated[Optional[List[Literal['attachments.media_keys', 'attachments.poll_ids', 'author_id', 'entities.mentions.username', 'geo.place_id', 'in_reply_to_user_id', 'referenced_tweets.id', 'referenced_tweets.id.author_id']]], Field(description="A comma separated list of fields to expand.", unique_items=True)] = None, media_fields : Annotated[Optional[List[Literal['alt_text', 'duration_ms', 'height', 'media_key', 'non_public_metrics', 'organic_metrics', 'preview_image_url', 'promoted_metrics', 'public_metrics', 'type', 'url', 'variants', 'width']]], Field(description="A comma separated list of Media fields to display.", unique_items=True)] = None, poll_fields : Annotated[Optional[List[Literal['duration_minutes', 'end_datetime', 'id', 'options', 'voting_status']]], Field(description="A comma separated list of Poll fields to display.", unique_items=True)] = None, user_fields : Annotated[Optional[List[Literal['created_at', 'description', 'entities', 'id', 'location', 'name', 'pinned_tweet_id', 'profile_image_url', 'protected', 'public_metrics', 'url', 'username', 'verified', 'withheld']]], Field(description="A comma separated list of User fields to display.", unique_items=True)] = None, place_fields : Annotated[Optional[List[Literal['contained_within', 'country', 'country_code', 'full_name', 'geo', 'id', 'name', 'place_type']]], Field(description="A comma separated list of Place fields to display.", unique_items=True)] = None, **kwargs) -> Get2TweetsIdResponse:  # noqa: E501
        """Tweet lookup by Tweet ID  # noqa: E501

        Returns a variety of information about the Tweet specified by the requested ID.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.find_tweet_by_id(id, tweet_fields, expansions, media_fields, poll_fields, user_fields, place_fields, async_req=True)
        >>> result = thread.get()

        :param id: A single Tweet ID. (required)
        :type id: str
        :param tweet_fields: A comma separated list of Tweet fields to display.
        :type tweet_fields: List[str]
        :param expansions: A comma separated list of fields to expand.
        :type expansions: List[str]
        :param media_fields: A comma separated list of Media fields to display.
        :type media_fields: List[str]
        :param poll_fields: A comma separated list of Poll fields to display.
        :type poll_fields: List[str]
        :param user_fields: A comma separated list of User fields to display.
        :type user_fields: List[str]
        :param place_fields: A comma separated list of Place fields to display.
        :type place_fields: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: Get2TweetsIdResponse
        """
        kwargs['_return_http_data_only'] = True
        return self.find_tweet_by_id_with_http_info(id, tweet_fields, expansions, media_fields, poll_fields, user_fields, place_fields, **kwargs)  # noqa: E501

    @validate_arguments
    def find_tweet_by_id_with_http_info(self, id : Annotated[constr(strict=True, regex=r'/^[0-9]{1,19}$/'), Field(..., description="A single Tweet ID.")], tweet_fields : Annotated[Optional[List[Literal['attachments', 'author_id', 'context_annotations', 'conversation_id', 'created_at', 'entities', 'geo', 'id', 'in_reply_to_user_id', 'lang', 'non_public_metrics', 'organic_metrics', 'possibly_sensitive', 'promoted_metrics', 'public_metrics', 'referenced_tweets', 'reply_settings', 'source', 'text', 'withheld']]], Field(description="A comma separated list of Tweet fields to display.", unique_items=True)] = None, expansions : Annotated[Optional[List[Literal['attachments.media_keys', 'attachments.poll_ids', 'author_id', 'entities.mentions.username', 'geo.place_id', 'in_reply_to_user_id', 'referenced_tweets.id', 'referenced_tweets.id.author_id']]], Field(description="A comma separated list of fields to expand.", unique_items=True)] = None, media_fields : Annotated[Optional[List[Literal['alt_text', 'duration_ms', 'height', 'media_key', 'non_public_metrics', 'organic_metrics', 'preview_image_url', 'promoted_metrics', 'public_metrics', 'type', 'url', 'variants', 'width']]], Field(description="A comma separated list of Media fields to display.", unique_items=True)] = None, poll_fields : Annotated[Optional[List[Literal['duration_minutes', 'end_datetime', 'id', 'options', 'voting_status']]], Field(description="A comma separated list of Poll fields to display.", unique_items=True)] = None, user_fields : Annotated[Optional[List[Literal['created_at', 'description', 'entities', 'id', 'location', 'name', 'pinned_tweet_id', 'profile_image_url', 'protected', 'public_metrics', 'url', 'username', 'verified', 'withheld']]], Field(description="A comma separated list of User fields to display.", unique_items=True)] = None, place_fields : Annotated[Optional[List[Literal['contained_within', 'country', 'country_code', 'full_name', 'geo', 'id', 'name', 'place_type']]], Field(description="A comma separated list of Place fields to display.", unique_items=True)] = None, **kwargs):  # noqa: E501
        """Tweet lookup by Tweet ID  # noqa: E501

        Returns a variety of information about the Tweet specified by the requested ID.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.find_tweet_by_id_with_http_info(id, tweet_fields, expansions, media_fields, poll_fields, user_fields, place_fields, async_req=True)
        >>> result = thread.get()

        :param id: A single Tweet ID. (required)
        :type id: str
        :param tweet_fields: A comma separated list of Tweet fields to display.
        :type tweet_fields: List[str]
        :param expansions: A comma separated list of fields to expand.
        :type expansions: List[str]
        :param media_fields: A comma separated list of Media fields to display.
        :type media_fields: List[str]
        :param poll_fields: A comma separated list of Poll fields to display.
        :type poll_fields: List[str]
        :param user_fields: A comma separated list of User fields to display.
        :type user_fields: List[str]
        :param place_fields: A comma separated list of Place fields to display.
        :type place_fields: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(Get2TweetsIdResponse, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'id',
            'tweet_fields',
            'expansions',
            'media_fields',
            'poll_fields',
            'user_fields',
            'place_fields'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in local_var_params['kwargs'].items():
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method find_tweet_by_id" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        collection_formats = {}

        path_params = {}
        if local_var_params['id']:
            path_params['id'] = local_var_params['id']

        query_params = []
        if local_var_params.get('tweet_fields') is not None:  # noqa: E501
            query_params.append(('tweet.fields', local_var_params['tweet_fields']))
            collection_formats['tweet.fields'] = 'csv'
        if local_var_params.get('expansions') is not None:  # noqa: E501
            query_params.append(('expansions', local_var_params['expansions']))
            collection_formats['expansions'] = 'csv'
        if local_var_params.get('media_fields') is not None:  # noqa: E501
            query_params.append(('media.fields', local_var_params['media_fields']))
            collection_formats['media.fields'] = 'csv'
        if local_var_params.get('poll_fields') is not None:  # noqa: E501
            query_params.append(('poll.fields', local_var_params['poll_fields']))
            collection_formats['poll.fields'] = 'csv'
        if local_var_params.get('user_fields') is not None:  # noqa: E501
            query_params.append(('user.fields', local_var_params['user_fields']))
            collection_formats['user.fields'] = 'csv'
        if local_var_params.get('place_fields') is not None:  # noqa: E501
            query_params.append(('place.fields', local_var_params['place_fields']))
            collection_formats['place.fields'] = 'csv'

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'application/problem+json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BearerToken', 'OAuth2UserToken', 'UserToken']  # noqa: E501

        response_types_map = {
            200: "Get2TweetsIdResponse",
        }

        return self.api_client.call_api(
            '/2/tweets/{id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    @validate_arguments
    def find_tweets_by_id(self, ids : Annotated[List[constr(strict=True, regex=r'/^[0-9]{1,19}$/')], Field(..., description="A comma separated list of Tweet IDs. Up to 100 are allowed in a single request.")], tweet_fields : Annotated[Optional[List[Literal['attachments', 'author_id', 'context_annotations', 'conversation_id', 'created_at', 'entities', 'geo', 'id', 'in_reply_to_user_id', 'lang', 'non_public_metrics', 'organic_metrics', 'possibly_sensitive', 'promoted_metrics', 'public_metrics', 'referenced_tweets', 'reply_settings', 'source', 'text', 'withheld']]], Field(description="A comma separated list of Tweet fields to display.", unique_items=True)] = None, expansions : Annotated[Optional[List[Literal['attachments.media_keys', 'attachments.poll_ids', 'author_id', 'entities.mentions.username', 'geo.place_id', 'in_reply_to_user_id', 'referenced_tweets.id', 'referenced_tweets.id.author_id']]], Field(description="A comma separated list of fields to expand.", unique_items=True)] = None, media_fields : Annotated[Optional[List[Literal['alt_text', 'duration_ms', 'height', 'media_key', 'non_public_metrics', 'organic_metrics', 'preview_image_url', 'promoted_metrics', 'public_metrics', 'type', 'url', 'variants', 'width']]], Field(description="A comma separated list of Media fields to display.", unique_items=True)] = None, poll_fields : Annotated[Optional[List[Literal['duration_minutes', 'end_datetime', 'id', 'options', 'voting_status']]], Field(description="A comma separated list of Poll fields to display.", unique_items=True)] = None, user_fields : Annotated[Optional[List[Literal['created_at', 'description', 'entities', 'id', 'location', 'name', 'pinned_tweet_id', 'profile_image_url', 'protected', 'public_metrics', 'url', 'username', 'verified', 'withheld']]], Field(description="A comma separated list of User fields to display.", unique_items=True)] = None, place_fields : Annotated[Optional[List[Literal['contained_within', 'country', 'country_code', 'full_name', 'geo', 'id', 'name', 'place_type']]], Field(description="A comma separated list of Place fields to display.", unique_items=True)] = None, **kwargs) -> Get2TweetsResponse:  # noqa: E501
        """Tweet lookup by Tweet IDs  # noqa: E501

        Returns a variety of information about the Tweet specified by the requested ID.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.find_tweets_by_id(ids, tweet_fields, expansions, media_fields, poll_fields, user_fields, place_fields, async_req=True)
        >>> result = thread.get()

        :param ids: A comma separated list of Tweet IDs. Up to 100 are allowed in a single request. (required)
        :type ids: List[str]
        :param tweet_fields: A comma separated list of Tweet fields to display.
        :type tweet_fields: List[str]
        :param expansions: A comma separated list of fields to expand.
        :type expansions: List[str]
        :param media_fields: A comma separated list of Media fields to display.
        :type media_fields: List[str]
        :param poll_fields: A comma separated list of Poll fields to display.
        :type poll_fields: List[str]
        :param user_fields: A comma separated list of User fields to display.
        :type user_fields: List[str]
        :param place_fields: A comma separated list of Place fields to display.
        :type place_fields: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: Get2TweetsResponse
        """
        kwargs['_return_http_data_only'] = True
        return self.find_tweets_by_id_with_http_info(ids, tweet_fields, expansions, media_fields, poll_fields, user_fields, place_fields, **kwargs)  # noqa: E501

    @validate_arguments
    def find_tweets_by_id_with_http_info(self, ids : Annotated[List[constr(strict=True, regex=r'/^[0-9]{1,19}$/')], Field(..., description="A comma separated list of Tweet IDs. Up to 100 are allowed in a single request.")], tweet_fields : Annotated[Optional[List[Literal['attachments', 'author_id', 'context_annotations', 'conversation_id', 'created_at', 'entities', 'geo', 'id', 'in_reply_to_user_id', 'lang', 'non_public_metrics', 'organic_metrics', 'possibly_sensitive', 'promoted_metrics', 'public_metrics', 'referenced_tweets', 'reply_settings', 'source', 'text', 'withheld']]], Field(description="A comma separated list of Tweet fields to display.", unique_items=True)] = None, expansions : Annotated[Optional[List[Literal['attachments.media_keys', 'attachments.poll_ids', 'author_id', 'entities.mentions.username', 'geo.place_id', 'in_reply_to_user_id', 'referenced_tweets.id', 'referenced_tweets.id.author_id']]], Field(description="A comma separated list of fields to expand.", unique_items=True)] = None, media_fields : Annotated[Optional[List[Literal['alt_text', 'duration_ms', 'height', 'media_key', 'non_public_metrics', 'organic_metrics', 'preview_image_url', 'promoted_metrics', 'public_metrics', 'type', 'url', 'variants', 'width']]], Field(description="A comma separated list of Media fields to display.", unique_items=True)] = None, poll_fields : Annotated[Optional[List[Literal['duration_minutes', 'end_datetime', 'id', 'options', 'voting_status']]], Field(description="A comma separated list of Poll fields to display.", unique_items=True)] = None, user_fields : Annotated[Optional[List[Literal['created_at', 'description', 'entities', 'id', 'location', 'name', 'pinned_tweet_id', 'profile_image_url', 'protected', 'public_metrics', 'url', 'username', 'verified', 'withheld']]], Field(description="A comma separated list of User fields to display.", unique_items=True)] = None, place_fields : Annotated[Optional[List[Literal['contained_within', 'country', 'country_code', 'full_name', 'geo', 'id', 'name', 'place_type']]], Field(description="A comma separated list of Place fields to display.", unique_items=True)] = None, **kwargs):  # noqa: E501
        """Tweet lookup by Tweet IDs  # noqa: E501

        Returns a variety of information about the Tweet specified by the requested ID.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.find_tweets_by_id_with_http_info(ids, tweet_fields, expansions, media_fields, poll_fields, user_fields, place_fields, async_req=True)
        >>> result = thread.get()

        :param ids: A comma separated list of Tweet IDs. Up to 100 are allowed in a single request. (required)
        :type ids: List[str]
        :param tweet_fields: A comma separated list of Tweet fields to display.
        :type tweet_fields: List[str]
        :param expansions: A comma separated list of fields to expand.
        :type expansions: List[str]
        :param media_fields: A comma separated list of Media fields to display.
        :type media_fields: List[str]
        :param poll_fields: A comma separated list of Poll fields to display.
        :type poll_fields: List[str]
        :param user_fields: A comma separated list of User fields to display.
        :type user_fields: List[str]
        :param place_fields: A comma separated list of Place fields to display.
        :type place_fields: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(Get2TweetsResponse, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'ids',
            'tweet_fields',
            'expansions',
            'media_fields',
            'poll_fields',
            'user_fields',
            'place_fields'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in local_var_params['kwargs'].items():
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method find_tweets_by_id" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if local_var_params.get('ids') is not None:  # noqa: E501
            query_params.append(('ids', local_var_params['ids']))
            collection_formats['ids'] = 'csv'
        if local_var_params.get('tweet_fields') is not None:  # noqa: E501
            query_params.append(('tweet.fields', local_var_params['tweet_fields']))
            collection_formats['tweet.fields'] = 'csv'
        if local_var_params.get('expansions') is not None:  # noqa: E501
            query_params.append(('expansions', local_var_params['expansions']))
            collection_formats['expansions'] = 'csv'
        if local_var_params.get('media_fields') is not None:  # noqa: E501
            query_params.append(('media.fields', local_var_params['media_fields']))
            collection_formats['media.fields'] = 'csv'
        if local_var_params.get('poll_fields') is not None:  # noqa: E501
            query_params.append(('poll.fields', local_var_params['poll_fields']))
            collection_formats['poll.fields'] = 'csv'
        if local_var_params.get('user_fields') is not None:  # noqa: E501
            query_params.append(('user.fields', local_var_params['user_fields']))
            collection_formats['user.fields'] = 'csv'
        if local_var_params.get('place_fields') is not None:  # noqa: E501
            query_params.append(('place.fields', local_var_params['place_fields']))
            collection_formats['place.fields'] = 'csv'

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'application/problem+json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BearerToken', 'OAuth2UserToken', 'UserToken']  # noqa: E501

        response_types_map = {
            200: "Get2TweetsResponse",
        }

        return self.api_client.call_api(
            '/2/tweets', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    @validate_arguments
    def find_tweets_that_quote_a_tweet(self, id : Annotated[constr(strict=True, regex=r'/^[0-9]{1,19}$/'), Field(..., description="A single Tweet ID.")], max_results : Annotated[Optional[conint(strict=True, ge=100, le=10)], Field(description="The maximum number of results to be returned.")] = None, pagination_token : Annotated[Optional[constr(strict=True, min_length=1)], Field(description="This parameter is used to get a specified 'page' of results.")] = None, exclude : Annotated[Optional[List[Literal['replies', 'retweets']]], Field(description="The set of entities to exclude (e.g. 'replies' or 'retweets').", unique_items=True)] = None, tweet_fields : Annotated[Optional[List[Literal['attachments', 'author_id', 'context_annotations', 'conversation_id', 'created_at', 'entities', 'geo', 'id', 'in_reply_to_user_id', 'lang', 'non_public_metrics', 'organic_metrics', 'possibly_sensitive', 'promoted_metrics', 'public_metrics', 'referenced_tweets', 'reply_settings', 'source', 'text', 'withheld']]], Field(description="A comma separated list of Tweet fields to display.", unique_items=True)] = None, expansions : Annotated[Optional[List[Literal['attachments.media_keys', 'attachments.poll_ids', 'author_id', 'entities.mentions.username', 'geo.place_id', 'in_reply_to_user_id', 'referenced_tweets.id', 'referenced_tweets.id.author_id']]], Field(description="A comma separated list of fields to expand.", unique_items=True)] = None, media_fields : Annotated[Optional[List[Literal['alt_text', 'duration_ms', 'height', 'media_key', 'non_public_metrics', 'organic_metrics', 'preview_image_url', 'promoted_metrics', 'public_metrics', 'type', 'url', 'variants', 'width']]], Field(description="A comma separated list of Media fields to display.", unique_items=True)] = None, poll_fields : Annotated[Optional[List[Literal['duration_minutes', 'end_datetime', 'id', 'options', 'voting_status']]], Field(description="A comma separated list of Poll fields to display.", unique_items=True)] = None, user_fields : Annotated[Optional[List[Literal['created_at', 'description', 'entities', 'id', 'location', 'name', 'pinned_tweet_id', 'profile_image_url', 'protected', 'public_metrics', 'url', 'username', 'verified', 'withheld']]], Field(description="A comma separated list of User fields to display.", unique_items=True)] = None, place_fields : Annotated[Optional[List[Literal['contained_within', 'country', 'country_code', 'full_name', 'geo', 'id', 'name', 'place_type']]], Field(description="A comma separated list of Place fields to display.", unique_items=True)] = None, **kwargs) -> Get2TweetsIdQuoteTweetsResponse:  # noqa: E501
        """Retrieve Tweets that quote a Tweet.  # noqa: E501

        Returns a variety of information about each Tweet that quotes the Tweet specified by the requested ID.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.find_tweets_that_quote_a_tweet(id, max_results, pagination_token, exclude, tweet_fields, expansions, media_fields, poll_fields, user_fields, place_fields, async_req=True)
        >>> result = thread.get()

        :param id: A single Tweet ID. (required)
        :type id: str
        :param max_results: The maximum number of results to be returned.
        :type max_results: int
        :param pagination_token: This parameter is used to get a specified 'page' of results.
        :type pagination_token: str
        :param exclude: The set of entities to exclude (e.g. 'replies' or 'retweets').
        :type exclude: List[str]
        :param tweet_fields: A comma separated list of Tweet fields to display.
        :type tweet_fields: List[str]
        :param expansions: A comma separated list of fields to expand.
        :type expansions: List[str]
        :param media_fields: A comma separated list of Media fields to display.
        :type media_fields: List[str]
        :param poll_fields: A comma separated list of Poll fields to display.
        :type poll_fields: List[str]
        :param user_fields: A comma separated list of User fields to display.
        :type user_fields: List[str]
        :param place_fields: A comma separated list of Place fields to display.
        :type place_fields: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: Get2TweetsIdQuoteTweetsResponse
        """
        kwargs['_return_http_data_only'] = True
        return self.find_tweets_that_quote_a_tweet_with_http_info(id, max_results, pagination_token, exclude, tweet_fields, expansions, media_fields, poll_fields, user_fields, place_fields, **kwargs)  # noqa: E501

    @validate_arguments
    def find_tweets_that_quote_a_tweet_with_http_info(self, id : Annotated[constr(strict=True, regex=r'/^[0-9]{1,19}$/'), Field(..., description="A single Tweet ID.")], max_results : Annotated[Optional[conint(strict=True, ge=100, le=10)], Field(description="The maximum number of results to be returned.")] = None, pagination_token : Annotated[Optional[constr(strict=True, min_length=1)], Field(description="This parameter is used to get a specified 'page' of results.")] = None, exclude : Annotated[Optional[List[Literal['replies', 'retweets']]], Field(description="The set of entities to exclude (e.g. 'replies' or 'retweets').", unique_items=True)] = None, tweet_fields : Annotated[Optional[List[Literal['attachments', 'author_id', 'context_annotations', 'conversation_id', 'created_at', 'entities', 'geo', 'id', 'in_reply_to_user_id', 'lang', 'non_public_metrics', 'organic_metrics', 'possibly_sensitive', 'promoted_metrics', 'public_metrics', 'referenced_tweets', 'reply_settings', 'source', 'text', 'withheld']]], Field(description="A comma separated list of Tweet fields to display.", unique_items=True)] = None, expansions : Annotated[Optional[List[Literal['attachments.media_keys', 'attachments.poll_ids', 'author_id', 'entities.mentions.username', 'geo.place_id', 'in_reply_to_user_id', 'referenced_tweets.id', 'referenced_tweets.id.author_id']]], Field(description="A comma separated list of fields to expand.", unique_items=True)] = None, media_fields : Annotated[Optional[List[Literal['alt_text', 'duration_ms', 'height', 'media_key', 'non_public_metrics', 'organic_metrics', 'preview_image_url', 'promoted_metrics', 'public_metrics', 'type', 'url', 'variants', 'width']]], Field(description="A comma separated list of Media fields to display.", unique_items=True)] = None, poll_fields : Annotated[Optional[List[Literal['duration_minutes', 'end_datetime', 'id', 'options', 'voting_status']]], Field(description="A comma separated list of Poll fields to display.", unique_items=True)] = None, user_fields : Annotated[Optional[List[Literal['created_at', 'description', 'entities', 'id', 'location', 'name', 'pinned_tweet_id', 'profile_image_url', 'protected', 'public_metrics', 'url', 'username', 'verified', 'withheld']]], Field(description="A comma separated list of User fields to display.", unique_items=True)] = None, place_fields : Annotated[Optional[List[Literal['contained_within', 'country', 'country_code', 'full_name', 'geo', 'id', 'name', 'place_type']]], Field(description="A comma separated list of Place fields to display.", unique_items=True)] = None, **kwargs):  # noqa: E501
        """Retrieve Tweets that quote a Tweet.  # noqa: E501

        Returns a variety of information about each Tweet that quotes the Tweet specified by the requested ID.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.find_tweets_that_quote_a_tweet_with_http_info(id, max_results, pagination_token, exclude, tweet_fields, expansions, media_fields, poll_fields, user_fields, place_fields, async_req=True)
        >>> result = thread.get()

        :param id: A single Tweet ID. (required)
        :type id: str
        :param max_results: The maximum number of results to be returned.
        :type max_results: int
        :param pagination_token: This parameter is used to get a specified 'page' of results.
        :type pagination_token: str
        :param exclude: The set of entities to exclude (e.g. 'replies' or 'retweets').
        :type exclude: List[str]
        :param tweet_fields: A comma separated list of Tweet fields to display.
        :type tweet_fields: List[str]
        :param expansions: A comma separated list of fields to expand.
        :type expansions: List[str]
        :param media_fields: A comma separated list of Media fields to display.
        :type media_fields: List[str]
        :param poll_fields: A comma separated list of Poll fields to display.
        :type poll_fields: List[str]
        :param user_fields: A comma separated list of User fields to display.
        :type user_fields: List[str]
        :param place_fields: A comma separated list of Place fields to display.
        :type place_fields: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(Get2TweetsIdQuoteTweetsResponse, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'id',
            'max_results',
            'pagination_token',
            'exclude',
            'tweet_fields',
            'expansions',
            'media_fields',
            'poll_fields',
            'user_fields',
            'place_fields'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in local_var_params['kwargs'].items():
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method find_tweets_that_quote_a_tweet" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        collection_formats = {}

        path_params = {}
        if local_var_params['id']:
            path_params['id'] = local_var_params['id']

        query_params = []
        if local_var_params.get('max_results') is not None:  # noqa: E501
            query_params.append(('max_results', local_var_params['max_results']))
        if local_var_params.get('pagination_token') is not None:  # noqa: E501
            query_params.append(('pagination_token', local_var_params['pagination_token']))
        if local_var_params.get('exclude') is not None:  # noqa: E501
            query_params.append(('exclude', local_var_params['exclude']))
            collection_formats['exclude'] = 'csv'
        if local_var_params.get('tweet_fields') is not None:  # noqa: E501
            query_params.append(('tweet.fields', local_var_params['tweet_fields']))
            collection_formats['tweet.fields'] = 'csv'
        if local_var_params.get('expansions') is not None:  # noqa: E501
            query_params.append(('expansions', local_var_params['expansions']))
            collection_formats['expansions'] = 'csv'
        if local_var_params.get('media_fields') is not None:  # noqa: E501
            query_params.append(('media.fields', local_var_params['media_fields']))
            collection_formats['media.fields'] = 'csv'
        if local_var_params.get('poll_fields') is not None:  # noqa: E501
            query_params.append(('poll.fields', local_var_params['poll_fields']))
            collection_formats['poll.fields'] = 'csv'
        if local_var_params.get('user_fields') is not None:  # noqa: E501
            query_params.append(('user.fields', local_var_params['user_fields']))
            collection_formats['user.fields'] = 'csv'
        if local_var_params.get('place_fields') is not None:  # noqa: E501
            query_params.append(('place.fields', local_var_params['place_fields']))
            collection_formats['place.fields'] = 'csv'

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'application/problem+json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BearerToken', 'OAuth2UserToken', 'UserToken']  # noqa: E501

        response_types_map = {
            200: "Get2TweetsIdQuoteTweetsResponse",
        }

        return self.api_client.call_api(
            '/2/tweets/{id}/quote_tweets', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    @validate_arguments
    def get_rules(self, ids : Annotated[Optional[List[constr(strict=True, regex=r'/^[0-9]{1,19}$/')]], Field(description="A comma-separated list of Rule IDs.")] = None, max_results : Annotated[Optional[conint(strict=True, ge=1000, le=1)], Field(description="The maximum number of results.")] = None, pagination_token : Annotated[Optional[constr(strict=True, max_length=16, min_length=16)], Field(description="This value is populated by passing the 'next_token' returned in a request to paginate through results.")] = None, **kwargs) -> RulesLookupResponse:  # noqa: E501
        """Rules lookup  # noqa: E501

        Returns rules from a User's active rule set. Users can fetch all of their rules or a subset, specified by the provided rule ids.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_rules(ids, max_results, pagination_token, async_req=True)
        >>> result = thread.get()

        :param ids: A comma-separated list of Rule IDs.
        :type ids: List[str]
        :param max_results: The maximum number of results.
        :type max_results: int
        :param pagination_token: This value is populated by passing the 'next_token' returned in a request to paginate through results.
        :type pagination_token: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: RulesLookupResponse
        """
        kwargs['_return_http_data_only'] = True
        return self.get_rules_with_http_info(ids, max_results, pagination_token, **kwargs)  # noqa: E501

    @validate_arguments
    def get_rules_with_http_info(self, ids : Annotated[Optional[List[constr(strict=True, regex=r'/^[0-9]{1,19}$/')]], Field(description="A comma-separated list of Rule IDs.")] = None, max_results : Annotated[Optional[conint(strict=True, ge=1000, le=1)], Field(description="The maximum number of results.")] = None, pagination_token : Annotated[Optional[constr(strict=True, max_length=16, min_length=16)], Field(description="This value is populated by passing the 'next_token' returned in a request to paginate through results.")] = None, **kwargs):  # noqa: E501
        """Rules lookup  # noqa: E501

        Returns rules from a User's active rule set. Users can fetch all of their rules or a subset, specified by the provided rule ids.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_rules_with_http_info(ids, max_results, pagination_token, async_req=True)
        >>> result = thread.get()

        :param ids: A comma-separated list of Rule IDs.
        :type ids: List[str]
        :param max_results: The maximum number of results.
        :type max_results: int
        :param pagination_token: This value is populated by passing the 'next_token' returned in a request to paginate through results.
        :type pagination_token: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(RulesLookupResponse, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'ids',
            'max_results',
            'pagination_token'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in local_var_params['kwargs'].items():
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_rules" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if local_var_params.get('ids') is not None:  # noqa: E501
            query_params.append(('ids', local_var_params['ids']))
            collection_formats['ids'] = 'multi'
        if local_var_params.get('max_results') is not None:  # noqa: E501
            query_params.append(('max_results', local_var_params['max_results']))
        if local_var_params.get('pagination_token') is not None:  # noqa: E501
            query_params.append(('pagination_token', local_var_params['pagination_token']))

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'application/problem+json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BearerToken']  # noqa: E501

        response_types_map = {
            200: "RulesLookupResponse",
        }

        return self.api_client.call_api(
            '/2/tweets/search/stream/rules', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    @validate_arguments
    def get_tweets_firehose_stream(self, partition : Annotated[conint(strict=True, ge=20, le=1), Field(..., description="The partition number.")], backfill_minutes : Annotated[Optional[conint(strict=True, ge=5, le=0)], Field(description="The number of minutes of backfill requested.")] = None, start_time : Annotated[Optional[datetime], Field(description="YYYY-MM-DDTHH:mm:ssZ. The earliest UTC timestamp to which the Tweets will be provided.")] = None, end_time : Annotated[Optional[datetime], Field(description="YYYY-MM-DDTHH:mm:ssZ. The latest UTC timestamp to which the Tweets will be provided.")] = None, tweet_fields : Annotated[Optional[List[Literal['attachments', 'author_id', 'context_annotations', 'conversation_id', 'created_at', 'entities', 'geo', 'id', 'in_reply_to_user_id', 'lang', 'non_public_metrics', 'organic_metrics', 'possibly_sensitive', 'promoted_metrics', 'public_metrics', 'referenced_tweets', 'reply_settings', 'source', 'text', 'withheld']]], Field(description="A comma separated list of Tweet fields to display.", unique_items=True)] = None, expansions : Annotated[Optional[List[Literal['attachments.media_keys', 'attachments.poll_ids', 'author_id', 'entities.mentions.username', 'geo.place_id', 'in_reply_to_user_id', 'referenced_tweets.id', 'referenced_tweets.id.author_id']]], Field(description="A comma separated list of fields to expand.", unique_items=True)] = None, media_fields : Annotated[Optional[List[Literal['alt_text', 'duration_ms', 'height', 'media_key', 'non_public_metrics', 'organic_metrics', 'preview_image_url', 'promoted_metrics', 'public_metrics', 'type', 'url', 'variants', 'width']]], Field(description="A comma separated list of Media fields to display.", unique_items=True)] = None, poll_fields : Annotated[Optional[List[Literal['duration_minutes', 'end_datetime', 'id', 'options', 'voting_status']]], Field(description="A comma separated list of Poll fields to display.", unique_items=True)] = None, user_fields : Annotated[Optional[List[Literal['created_at', 'description', 'entities', 'id', 'location', 'name', 'pinned_tweet_id', 'profile_image_url', 'protected', 'public_metrics', 'url', 'username', 'verified', 'withheld']]], Field(description="A comma separated list of User fields to display.", unique_items=True)] = None, place_fields : Annotated[Optional[List[Literal['contained_within', 'country', 'country_code', 'full_name', 'geo', 'id', 'name', 'place_type']]], Field(description="A comma separated list of Place fields to display.", unique_items=True)] = None, **kwargs) -> StreamingTweetResponse:  # noqa: E501
        """Firehose stream  # noqa: E501

        Streams 100% of public Tweets.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_tweets_firehose_stream(partition, backfill_minutes, start_time, end_time, tweet_fields, expansions, media_fields, poll_fields, user_fields, place_fields, async_req=True)
        >>> result = thread.get()

        :param partition: The partition number. (required)
        :type partition: int
        :param backfill_minutes: The number of minutes of backfill requested.
        :type backfill_minutes: int
        :param start_time: YYYY-MM-DDTHH:mm:ssZ. The earliest UTC timestamp to which the Tweets will be provided.
        :type start_time: datetime
        :param end_time: YYYY-MM-DDTHH:mm:ssZ. The latest UTC timestamp to which the Tweets will be provided.
        :type end_time: datetime
        :param tweet_fields: A comma separated list of Tweet fields to display.
        :type tweet_fields: List[str]
        :param expansions: A comma separated list of fields to expand.
        :type expansions: List[str]
        :param media_fields: A comma separated list of Media fields to display.
        :type media_fields: List[str]
        :param poll_fields: A comma separated list of Poll fields to display.
        :type poll_fields: List[str]
        :param user_fields: A comma separated list of User fields to display.
        :type user_fields: List[str]
        :param place_fields: A comma separated list of Place fields to display.
        :type place_fields: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: StreamingTweetResponse
        """
        kwargs['_return_http_data_only'] = True
        return self.get_tweets_firehose_stream_with_http_info(partition, backfill_minutes, start_time, end_time, tweet_fields, expansions, media_fields, poll_fields, user_fields, place_fields, **kwargs)  # noqa: E501

    @validate_arguments
    def get_tweets_firehose_stream_with_http_info(self, partition : Annotated[conint(strict=True, ge=20, le=1), Field(..., description="The partition number.")], backfill_minutes : Annotated[Optional[conint(strict=True, ge=5, le=0)], Field(description="The number of minutes of backfill requested.")] = None, start_time : Annotated[Optional[datetime], Field(description="YYYY-MM-DDTHH:mm:ssZ. The earliest UTC timestamp to which the Tweets will be provided.")] = None, end_time : Annotated[Optional[datetime], Field(description="YYYY-MM-DDTHH:mm:ssZ. The latest UTC timestamp to which the Tweets will be provided.")] = None, tweet_fields : Annotated[Optional[List[Literal['attachments', 'author_id', 'context_annotations', 'conversation_id', 'created_at', 'entities', 'geo', 'id', 'in_reply_to_user_id', 'lang', 'non_public_metrics', 'organic_metrics', 'possibly_sensitive', 'promoted_metrics', 'public_metrics', 'referenced_tweets', 'reply_settings', 'source', 'text', 'withheld']]], Field(description="A comma separated list of Tweet fields to display.", unique_items=True)] = None, expansions : Annotated[Optional[List[Literal['attachments.media_keys', 'attachments.poll_ids', 'author_id', 'entities.mentions.username', 'geo.place_id', 'in_reply_to_user_id', 'referenced_tweets.id', 'referenced_tweets.id.author_id']]], Field(description="A comma separated list of fields to expand.", unique_items=True)] = None, media_fields : Annotated[Optional[List[Literal['alt_text', 'duration_ms', 'height', 'media_key', 'non_public_metrics', 'organic_metrics', 'preview_image_url', 'promoted_metrics', 'public_metrics', 'type', 'url', 'variants', 'width']]], Field(description="A comma separated list of Media fields to display.", unique_items=True)] = None, poll_fields : Annotated[Optional[List[Literal['duration_minutes', 'end_datetime', 'id', 'options', 'voting_status']]], Field(description="A comma separated list of Poll fields to display.", unique_items=True)] = None, user_fields : Annotated[Optional[List[Literal['created_at', 'description', 'entities', 'id', 'location', 'name', 'pinned_tweet_id', 'profile_image_url', 'protected', 'public_metrics', 'url', 'username', 'verified', 'withheld']]], Field(description="A comma separated list of User fields to display.", unique_items=True)] = None, place_fields : Annotated[Optional[List[Literal['contained_within', 'country', 'country_code', 'full_name', 'geo', 'id', 'name', 'place_type']]], Field(description="A comma separated list of Place fields to display.", unique_items=True)] = None, **kwargs):  # noqa: E501
        """Firehose stream  # noqa: E501

        Streams 100% of public Tweets.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_tweets_firehose_stream_with_http_info(partition, backfill_minutes, start_time, end_time, tweet_fields, expansions, media_fields, poll_fields, user_fields, place_fields, async_req=True)
        >>> result = thread.get()

        :param partition: The partition number. (required)
        :type partition: int
        :param backfill_minutes: The number of minutes of backfill requested.
        :type backfill_minutes: int
        :param start_time: YYYY-MM-DDTHH:mm:ssZ. The earliest UTC timestamp to which the Tweets will be provided.
        :type start_time: datetime
        :param end_time: YYYY-MM-DDTHH:mm:ssZ. The latest UTC timestamp to which the Tweets will be provided.
        :type end_time: datetime
        :param tweet_fields: A comma separated list of Tweet fields to display.
        :type tweet_fields: List[str]
        :param expansions: A comma separated list of fields to expand.
        :type expansions: List[str]
        :param media_fields: A comma separated list of Media fields to display.
        :type media_fields: List[str]
        :param poll_fields: A comma separated list of Poll fields to display.
        :type poll_fields: List[str]
        :param user_fields: A comma separated list of User fields to display.
        :type user_fields: List[str]
        :param place_fields: A comma separated list of Place fields to display.
        :type place_fields: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(StreamingTweetResponse, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'partition',
            'backfill_minutes',
            'start_time',
            'end_time',
            'tweet_fields',
            'expansions',
            'media_fields',
            'poll_fields',
            'user_fields',
            'place_fields'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in local_var_params['kwargs'].items():
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_tweets_firehose_stream" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if local_var_params.get('backfill_minutes') is not None:  # noqa: E501
            query_params.append(('backfill_minutes', local_var_params['backfill_minutes']))
        if local_var_params.get('partition') is not None:  # noqa: E501
            query_params.append(('partition', local_var_params['partition']))
        if local_var_params.get('start_time') is not None:  # noqa: E501
            query_params.append(('start_time', local_var_params['start_time']))
        if local_var_params.get('end_time') is not None:  # noqa: E501
            query_params.append(('end_time', local_var_params['end_time']))
        if local_var_params.get('tweet_fields') is not None:  # noqa: E501
            query_params.append(('tweet.fields', local_var_params['tweet_fields']))
            collection_formats['tweet.fields'] = 'csv'
        if local_var_params.get('expansions') is not None:  # noqa: E501
            query_params.append(('expansions', local_var_params['expansions']))
            collection_formats['expansions'] = 'csv'
        if local_var_params.get('media_fields') is not None:  # noqa: E501
            query_params.append(('media.fields', local_var_params['media_fields']))
            collection_formats['media.fields'] = 'csv'
        if local_var_params.get('poll_fields') is not None:  # noqa: E501
            query_params.append(('poll.fields', local_var_params['poll_fields']))
            collection_formats['poll.fields'] = 'csv'
        if local_var_params.get('user_fields') is not None:  # noqa: E501
            query_params.append(('user.fields', local_var_params['user_fields']))
            collection_formats['user.fields'] = 'csv'
        if local_var_params.get('place_fields') is not None:  # noqa: E501
            query_params.append(('place.fields', local_var_params['place_fields']))
            collection_formats['place.fields'] = 'csv'

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'application/problem+json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BearerToken']  # noqa: E501

        response_types_map = {
            200: "StreamingTweetResponse",
        }

        return self.api_client.call_api(
            '/2/tweets/firehose/stream', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    @validate_arguments
    def get_tweets_sample10_stream(self, partition : Annotated[conint(strict=True, ge=2, le=1), Field(..., description="The partition number.")], backfill_minutes : Annotated[Optional[conint(strict=True, ge=5, le=0)], Field(description="The number of minutes of backfill requested.")] = None, start_time : Annotated[Optional[datetime], Field(description="YYYY-MM-DDTHH:mm:ssZ. The earliest UTC timestamp to which the Tweets will be provided.")] = None, end_time : Annotated[Optional[datetime], Field(description="YYYY-MM-DDTHH:mm:ssZ. The latest UTC timestamp to which the Tweets will be provided.")] = None, tweet_fields : Annotated[Optional[List[Literal['attachments', 'author_id', 'context_annotations', 'conversation_id', 'created_at', 'entities', 'geo', 'id', 'in_reply_to_user_id', 'lang', 'non_public_metrics', 'organic_metrics', 'possibly_sensitive', 'promoted_metrics', 'public_metrics', 'referenced_tweets', 'reply_settings', 'source', 'text', 'withheld']]], Field(description="A comma separated list of Tweet fields to display.", unique_items=True)] = None, expansions : Annotated[Optional[List[Literal['attachments.media_keys', 'attachments.poll_ids', 'author_id', 'entities.mentions.username', 'geo.place_id', 'in_reply_to_user_id', 'referenced_tweets.id', 'referenced_tweets.id.author_id']]], Field(description="A comma separated list of fields to expand.", unique_items=True)] = None, media_fields : Annotated[Optional[List[Literal['alt_text', 'duration_ms', 'height', 'media_key', 'non_public_metrics', 'organic_metrics', 'preview_image_url', 'promoted_metrics', 'public_metrics', 'type', 'url', 'variants', 'width']]], Field(description="A comma separated list of Media fields to display.", unique_items=True)] = None, poll_fields : Annotated[Optional[List[Literal['duration_minutes', 'end_datetime', 'id', 'options', 'voting_status']]], Field(description="A comma separated list of Poll fields to display.", unique_items=True)] = None, user_fields : Annotated[Optional[List[Literal['created_at', 'description', 'entities', 'id', 'location', 'name', 'pinned_tweet_id', 'profile_image_url', 'protected', 'public_metrics', 'url', 'username', 'verified', 'withheld']]], Field(description="A comma separated list of User fields to display.", unique_items=True)] = None, place_fields : Annotated[Optional[List[Literal['contained_within', 'country', 'country_code', 'full_name', 'geo', 'id', 'name', 'place_type']]], Field(description="A comma separated list of Place fields to display.", unique_items=True)] = None, **kwargs) -> Get2TweetsSample10StreamResponse:  # noqa: E501
        """Sample 10% stream  # noqa: E501

        Streams a deterministic 10% of public Tweets.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_tweets_sample10_stream(partition, backfill_minutes, start_time, end_time, tweet_fields, expansions, media_fields, poll_fields, user_fields, place_fields, async_req=True)
        >>> result = thread.get()

        :param partition: The partition number. (required)
        :type partition: int
        :param backfill_minutes: The number of minutes of backfill requested.
        :type backfill_minutes: int
        :param start_time: YYYY-MM-DDTHH:mm:ssZ. The earliest UTC timestamp to which the Tweets will be provided.
        :type start_time: datetime
        :param end_time: YYYY-MM-DDTHH:mm:ssZ. The latest UTC timestamp to which the Tweets will be provided.
        :type end_time: datetime
        :param tweet_fields: A comma separated list of Tweet fields to display.
        :type tweet_fields: List[str]
        :param expansions: A comma separated list of fields to expand.
        :type expansions: List[str]
        :param media_fields: A comma separated list of Media fields to display.
        :type media_fields: List[str]
        :param poll_fields: A comma separated list of Poll fields to display.
        :type poll_fields: List[str]
        :param user_fields: A comma separated list of User fields to display.
        :type user_fields: List[str]
        :param place_fields: A comma separated list of Place fields to display.
        :type place_fields: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: Get2TweetsSample10StreamResponse
        """
        kwargs['_return_http_data_only'] = True
        return self.get_tweets_sample10_stream_with_http_info(partition, backfill_minutes, start_time, end_time, tweet_fields, expansions, media_fields, poll_fields, user_fields, place_fields, **kwargs)  # noqa: E501

    @validate_arguments
    def get_tweets_sample10_stream_with_http_info(self, partition : Annotated[conint(strict=True, ge=2, le=1), Field(..., description="The partition number.")], backfill_minutes : Annotated[Optional[conint(strict=True, ge=5, le=0)], Field(description="The number of minutes of backfill requested.")] = None, start_time : Annotated[Optional[datetime], Field(description="YYYY-MM-DDTHH:mm:ssZ. The earliest UTC timestamp to which the Tweets will be provided.")] = None, end_time : Annotated[Optional[datetime], Field(description="YYYY-MM-DDTHH:mm:ssZ. The latest UTC timestamp to which the Tweets will be provided.")] = None, tweet_fields : Annotated[Optional[List[Literal['attachments', 'author_id', 'context_annotations', 'conversation_id', 'created_at', 'entities', 'geo', 'id', 'in_reply_to_user_id', 'lang', 'non_public_metrics', 'organic_metrics', 'possibly_sensitive', 'promoted_metrics', 'public_metrics', 'referenced_tweets', 'reply_settings', 'source', 'text', 'withheld']]], Field(description="A comma separated list of Tweet fields to display.", unique_items=True)] = None, expansions : Annotated[Optional[List[Literal['attachments.media_keys', 'attachments.poll_ids', 'author_id', 'entities.mentions.username', 'geo.place_id', 'in_reply_to_user_id', 'referenced_tweets.id', 'referenced_tweets.id.author_id']]], Field(description="A comma separated list of fields to expand.", unique_items=True)] = None, media_fields : Annotated[Optional[List[Literal['alt_text', 'duration_ms', 'height', 'media_key', 'non_public_metrics', 'organic_metrics', 'preview_image_url', 'promoted_metrics', 'public_metrics', 'type', 'url', 'variants', 'width']]], Field(description="A comma separated list of Media fields to display.", unique_items=True)] = None, poll_fields : Annotated[Optional[List[Literal['duration_minutes', 'end_datetime', 'id', 'options', 'voting_status']]], Field(description="A comma separated list of Poll fields to display.", unique_items=True)] = None, user_fields : Annotated[Optional[List[Literal['created_at', 'description', 'entities', 'id', 'location', 'name', 'pinned_tweet_id', 'profile_image_url', 'protected', 'public_metrics', 'url', 'username', 'verified', 'withheld']]], Field(description="A comma separated list of User fields to display.", unique_items=True)] = None, place_fields : Annotated[Optional[List[Literal['contained_within', 'country', 'country_code', 'full_name', 'geo', 'id', 'name', 'place_type']]], Field(description="A comma separated list of Place fields to display.", unique_items=True)] = None, **kwargs):  # noqa: E501
        """Sample 10% stream  # noqa: E501

        Streams a deterministic 10% of public Tweets.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_tweets_sample10_stream_with_http_info(partition, backfill_minutes, start_time, end_time, tweet_fields, expansions, media_fields, poll_fields, user_fields, place_fields, async_req=True)
        >>> result = thread.get()

        :param partition: The partition number. (required)
        :type partition: int
        :param backfill_minutes: The number of minutes of backfill requested.
        :type backfill_minutes: int
        :param start_time: YYYY-MM-DDTHH:mm:ssZ. The earliest UTC timestamp to which the Tweets will be provided.
        :type start_time: datetime
        :param end_time: YYYY-MM-DDTHH:mm:ssZ. The latest UTC timestamp to which the Tweets will be provided.
        :type end_time: datetime
        :param tweet_fields: A comma separated list of Tweet fields to display.
        :type tweet_fields: List[str]
        :param expansions: A comma separated list of fields to expand.
        :type expansions: List[str]
        :param media_fields: A comma separated list of Media fields to display.
        :type media_fields: List[str]
        :param poll_fields: A comma separated list of Poll fields to display.
        :type poll_fields: List[str]
        :param user_fields: A comma separated list of User fields to display.
        :type user_fields: List[str]
        :param place_fields: A comma separated list of Place fields to display.
        :type place_fields: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(Get2TweetsSample10StreamResponse, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'partition',
            'backfill_minutes',
            'start_time',
            'end_time',
            'tweet_fields',
            'expansions',
            'media_fields',
            'poll_fields',
            'user_fields',
            'place_fields'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in local_var_params['kwargs'].items():
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_tweets_sample10_stream" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if local_var_params.get('backfill_minutes') is not None:  # noqa: E501
            query_params.append(('backfill_minutes', local_var_params['backfill_minutes']))
        if local_var_params.get('partition') is not None:  # noqa: E501
            query_params.append(('partition', local_var_params['partition']))
        if local_var_params.get('start_time') is not None:  # noqa: E501
            query_params.append(('start_time', local_var_params['start_time']))
        if local_var_params.get('end_time') is not None:  # noqa: E501
            query_params.append(('end_time', local_var_params['end_time']))
        if local_var_params.get('tweet_fields') is not None:  # noqa: E501
            query_params.append(('tweet.fields', local_var_params['tweet_fields']))
            collection_formats['tweet.fields'] = 'csv'
        if local_var_params.get('expansions') is not None:  # noqa: E501
            query_params.append(('expansions', local_var_params['expansions']))
            collection_formats['expansions'] = 'csv'
        if local_var_params.get('media_fields') is not None:  # noqa: E501
            query_params.append(('media.fields', local_var_params['media_fields']))
            collection_formats['media.fields'] = 'csv'
        if local_var_params.get('poll_fields') is not None:  # noqa: E501
            query_params.append(('poll.fields', local_var_params['poll_fields']))
            collection_formats['poll.fields'] = 'csv'
        if local_var_params.get('user_fields') is not None:  # noqa: E501
            query_params.append(('user.fields', local_var_params['user_fields']))
            collection_formats['user.fields'] = 'csv'
        if local_var_params.get('place_fields') is not None:  # noqa: E501
            query_params.append(('place.fields', local_var_params['place_fields']))
            collection_formats['place.fields'] = 'csv'

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'application/problem+json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BearerToken']  # noqa: E501

        response_types_map = {
            200: "Get2TweetsSample10StreamResponse",
        }

        return self.api_client.call_api(
            '/2/tweets/sample10/stream', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    @validate_arguments
    def hide_reply_by_id(self, tweet_id : Annotated[constr(strict=True, regex=r'/^[0-9]{1,19}$/'), Field(..., description="The ID of the reply that you want to hide or unhide.")], tweet_hide_request : Optional[TweetHideRequest] = None, **kwargs) -> TweetHideResponse:  # noqa: E501
        """Hide replies  # noqa: E501

        Hides or unhides a reply to an owned conversation.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.hide_reply_by_id(tweet_id, tweet_hide_request, async_req=True)
        >>> result = thread.get()

        :param tweet_id: The ID of the reply that you want to hide or unhide. (required)
        :type tweet_id: str
        :param tweet_hide_request:
        :type tweet_hide_request: TweetHideRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: TweetHideResponse
        """
        kwargs['_return_http_data_only'] = True
        return self.hide_reply_by_id_with_http_info(tweet_id, tweet_hide_request, **kwargs)  # noqa: E501

    @validate_arguments
    def hide_reply_by_id_with_http_info(self, tweet_id : Annotated[constr(strict=True, regex=r'/^[0-9]{1,19}$/'), Field(..., description="The ID of the reply that you want to hide or unhide.")], tweet_hide_request : Optional[TweetHideRequest] = None, **kwargs):  # noqa: E501
        """Hide replies  # noqa: E501

        Hides or unhides a reply to an owned conversation.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.hide_reply_by_id_with_http_info(tweet_id, tweet_hide_request, async_req=True)
        >>> result = thread.get()

        :param tweet_id: The ID of the reply that you want to hide or unhide. (required)
        :type tweet_id: str
        :param tweet_hide_request:
        :type tweet_hide_request: TweetHideRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(TweetHideResponse, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'tweet_id',
            'tweet_hide_request'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in local_var_params['kwargs'].items():
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method hide_reply_by_id" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        collection_formats = {}

        path_params = {}
        if local_var_params['tweet_id']:
            path_params['tweet_id'] = local_var_params['tweet_id']

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        if local_var_params['tweet_hide_request']:
            body_params = local_var_params['tweet_hide_request']

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'application/problem+json'])  # noqa: E501

        # HTTP header `Content-Type`
        content_types_list = local_var_params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if content_types_list:
                header_params['Content-Type'] = content_types_list

        # Authentication setting
        auth_settings = ['OAuth2UserToken', 'UserToken']  # noqa: E501

        response_types_map = {
            200: "TweetHideResponse",
        }

        return self.api_client.call_api(
            '/2/tweets/{tweet_id}/hidden', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    @validate_arguments
    def lists_id_tweets(self, id : Annotated[constr(strict=True, regex=r'/^[0-9]{1,19}$/'), Field(..., description="The ID of the List.")], max_results : Annotated[Optional[conint(strict=True, ge=100, le=1)], Field(description="The maximum number of results.")] = None, pagination_token : Annotated[Optional[constr(strict=True, min_length=1)], Field(description="This parameter is used to get the next 'page' of results.")] = None, tweet_fields : Annotated[Optional[List[Literal['attachments', 'author_id', 'context_annotations', 'conversation_id', 'created_at', 'entities', 'geo', 'id', 'in_reply_to_user_id', 'lang', 'non_public_metrics', 'organic_metrics', 'possibly_sensitive', 'promoted_metrics', 'public_metrics', 'referenced_tweets', 'reply_settings', 'source', 'text', 'withheld']]], Field(description="A comma separated list of Tweet fields to display.", unique_items=True)] = None, expansions : Annotated[Optional[List[Literal['attachments.media_keys', 'attachments.poll_ids', 'author_id', 'entities.mentions.username', 'geo.place_id', 'in_reply_to_user_id', 'referenced_tweets.id', 'referenced_tweets.id.author_id']]], Field(description="A comma separated list of fields to expand.", unique_items=True)] = None, media_fields : Annotated[Optional[List[Literal['alt_text', 'duration_ms', 'height', 'media_key', 'non_public_metrics', 'organic_metrics', 'preview_image_url', 'promoted_metrics', 'public_metrics', 'type', 'url', 'variants', 'width']]], Field(description="A comma separated list of Media fields to display.", unique_items=True)] = None, poll_fields : Annotated[Optional[List[Literal['duration_minutes', 'end_datetime', 'id', 'options', 'voting_status']]], Field(description="A comma separated list of Poll fields to display.", unique_items=True)] = None, user_fields : Annotated[Optional[List[Literal['created_at', 'description', 'entities', 'id', 'location', 'name', 'pinned_tweet_id', 'profile_image_url', 'protected', 'public_metrics', 'url', 'username', 'verified', 'withheld']]], Field(description="A comma separated list of User fields to display.", unique_items=True)] = None, place_fields : Annotated[Optional[List[Literal['contained_within', 'country', 'country_code', 'full_name', 'geo', 'id', 'name', 'place_type']]], Field(description="A comma separated list of Place fields to display.", unique_items=True)] = None, **kwargs) -> Get2ListsIdTweetsResponse:  # noqa: E501
        """List Tweets timeline by List ID.  # noqa: E501

        Returns a list of Tweets associated with the provided List ID.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.lists_id_tweets(id, max_results, pagination_token, tweet_fields, expansions, media_fields, poll_fields, user_fields, place_fields, async_req=True)
        >>> result = thread.get()

        :param id: The ID of the List. (required)
        :type id: str
        :param max_results: The maximum number of results.
        :type max_results: int
        :param pagination_token: This parameter is used to get the next 'page' of results.
        :type pagination_token: str
        :param tweet_fields: A comma separated list of Tweet fields to display.
        :type tweet_fields: List[str]
        :param expansions: A comma separated list of fields to expand.
        :type expansions: List[str]
        :param media_fields: A comma separated list of Media fields to display.
        :type media_fields: List[str]
        :param poll_fields: A comma separated list of Poll fields to display.
        :type poll_fields: List[str]
        :param user_fields: A comma separated list of User fields to display.
        :type user_fields: List[str]
        :param place_fields: A comma separated list of Place fields to display.
        :type place_fields: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: Get2ListsIdTweetsResponse
        """
        kwargs['_return_http_data_only'] = True
        return self.lists_id_tweets_with_http_info(id, max_results, pagination_token, tweet_fields, expansions, media_fields, poll_fields, user_fields, place_fields, **kwargs)  # noqa: E501

    @validate_arguments
    def lists_id_tweets_with_http_info(self, id : Annotated[constr(strict=True, regex=r'/^[0-9]{1,19}$/'), Field(..., description="The ID of the List.")], max_results : Annotated[Optional[conint(strict=True, ge=100, le=1)], Field(description="The maximum number of results.")] = None, pagination_token : Annotated[Optional[constr(strict=True, min_length=1)], Field(description="This parameter is used to get the next 'page' of results.")] = None, tweet_fields : Annotated[Optional[List[Literal['attachments', 'author_id', 'context_annotations', 'conversation_id', 'created_at', 'entities', 'geo', 'id', 'in_reply_to_user_id', 'lang', 'non_public_metrics', 'organic_metrics', 'possibly_sensitive', 'promoted_metrics', 'public_metrics', 'referenced_tweets', 'reply_settings', 'source', 'text', 'withheld']]], Field(description="A comma separated list of Tweet fields to display.", unique_items=True)] = None, expansions : Annotated[Optional[List[Literal['attachments.media_keys', 'attachments.poll_ids', 'author_id', 'entities.mentions.username', 'geo.place_id', 'in_reply_to_user_id', 'referenced_tweets.id', 'referenced_tweets.id.author_id']]], Field(description="A comma separated list of fields to expand.", unique_items=True)] = None, media_fields : Annotated[Optional[List[Literal['alt_text', 'duration_ms', 'height', 'media_key', 'non_public_metrics', 'organic_metrics', 'preview_image_url', 'promoted_metrics', 'public_metrics', 'type', 'url', 'variants', 'width']]], Field(description="A comma separated list of Media fields to display.", unique_items=True)] = None, poll_fields : Annotated[Optional[List[Literal['duration_minutes', 'end_datetime', 'id', 'options', 'voting_status']]], Field(description="A comma separated list of Poll fields to display.", unique_items=True)] = None, user_fields : Annotated[Optional[List[Literal['created_at', 'description', 'entities', 'id', 'location', 'name', 'pinned_tweet_id', 'profile_image_url', 'protected', 'public_metrics', 'url', 'username', 'verified', 'withheld']]], Field(description="A comma separated list of User fields to display.", unique_items=True)] = None, place_fields : Annotated[Optional[List[Literal['contained_within', 'country', 'country_code', 'full_name', 'geo', 'id', 'name', 'place_type']]], Field(description="A comma separated list of Place fields to display.", unique_items=True)] = None, **kwargs):  # noqa: E501
        """List Tweets timeline by List ID.  # noqa: E501

        Returns a list of Tweets associated with the provided List ID.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.lists_id_tweets_with_http_info(id, max_results, pagination_token, tweet_fields, expansions, media_fields, poll_fields, user_fields, place_fields, async_req=True)
        >>> result = thread.get()

        :param id: The ID of the List. (required)
        :type id: str
        :param max_results: The maximum number of results.
        :type max_results: int
        :param pagination_token: This parameter is used to get the next 'page' of results.
        :type pagination_token: str
        :param tweet_fields: A comma separated list of Tweet fields to display.
        :type tweet_fields: List[str]
        :param expansions: A comma separated list of fields to expand.
        :type expansions: List[str]
        :param media_fields: A comma separated list of Media fields to display.
        :type media_fields: List[str]
        :param poll_fields: A comma separated list of Poll fields to display.
        :type poll_fields: List[str]
        :param user_fields: A comma separated list of User fields to display.
        :type user_fields: List[str]
        :param place_fields: A comma separated list of Place fields to display.
        :type place_fields: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(Get2ListsIdTweetsResponse, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'id',
            'max_results',
            'pagination_token',
            'tweet_fields',
            'expansions',
            'media_fields',
            'poll_fields',
            'user_fields',
            'place_fields'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in local_var_params['kwargs'].items():
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method lists_id_tweets" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        collection_formats = {}

        path_params = {}
        if local_var_params['id']:
            path_params['id'] = local_var_params['id']

        query_params = []
        if local_var_params.get('max_results') is not None:  # noqa: E501
            query_params.append(('max_results', local_var_params['max_results']))
        if local_var_params.get('pagination_token') is not None:  # noqa: E501
            query_params.append(('pagination_token', local_var_params['pagination_token']))
        if local_var_params.get('tweet_fields') is not None:  # noqa: E501
            query_params.append(('tweet.fields', local_var_params['tweet_fields']))
            collection_formats['tweet.fields'] = 'csv'
        if local_var_params.get('expansions') is not None:  # noqa: E501
            query_params.append(('expansions', local_var_params['expansions']))
            collection_formats['expansions'] = 'csv'
        if local_var_params.get('media_fields') is not None:  # noqa: E501
            query_params.append(('media.fields', local_var_params['media_fields']))
            collection_formats['media.fields'] = 'csv'
        if local_var_params.get('poll_fields') is not None:  # noqa: E501
            query_params.append(('poll.fields', local_var_params['poll_fields']))
            collection_formats['poll.fields'] = 'csv'
        if local_var_params.get('user_fields') is not None:  # noqa: E501
            query_params.append(('user.fields', local_var_params['user_fields']))
            collection_formats['user.fields'] = 'csv'
        if local_var_params.get('place_fields') is not None:  # noqa: E501
            query_params.append(('place.fields', local_var_params['place_fields']))
            collection_formats['place.fields'] = 'csv'

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'application/problem+json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BearerToken', 'OAuth2UserToken', 'UserToken']  # noqa: E501

        response_types_map = {
            200: "Get2ListsIdTweetsResponse",
        }

        return self.api_client.call_api(
            '/2/lists/{id}/tweets', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    @validate_arguments
    def sample_stream(self, backfill_minutes : Annotated[Optional[conint(strict=True, ge=5, le=0)], Field(description="The number of minutes of backfill requested.")] = None, tweet_fields : Annotated[Optional[List[Literal['attachments', 'author_id', 'context_annotations', 'conversation_id', 'created_at', 'entities', 'geo', 'id', 'in_reply_to_user_id', 'lang', 'non_public_metrics', 'organic_metrics', 'possibly_sensitive', 'promoted_metrics', 'public_metrics', 'referenced_tweets', 'reply_settings', 'source', 'text', 'withheld']]], Field(description="A comma separated list of Tweet fields to display.", unique_items=True)] = None, expansions : Annotated[Optional[List[Literal['attachments.media_keys', 'attachments.poll_ids', 'author_id', 'entities.mentions.username', 'geo.place_id', 'in_reply_to_user_id', 'referenced_tweets.id', 'referenced_tweets.id.author_id']]], Field(description="A comma separated list of fields to expand.", unique_items=True)] = None, media_fields : Annotated[Optional[List[Literal['alt_text', 'duration_ms', 'height', 'media_key', 'non_public_metrics', 'organic_metrics', 'preview_image_url', 'promoted_metrics', 'public_metrics', 'type', 'url', 'variants', 'width']]], Field(description="A comma separated list of Media fields to display.", unique_items=True)] = None, poll_fields : Annotated[Optional[List[Literal['duration_minutes', 'end_datetime', 'id', 'options', 'voting_status']]], Field(description="A comma separated list of Poll fields to display.", unique_items=True)] = None, user_fields : Annotated[Optional[List[Literal['created_at', 'description', 'entities', 'id', 'location', 'name', 'pinned_tweet_id', 'profile_image_url', 'protected', 'public_metrics', 'url', 'username', 'verified', 'withheld']]], Field(description="A comma separated list of User fields to display.", unique_items=True)] = None, place_fields : Annotated[Optional[List[Literal['contained_within', 'country', 'country_code', 'full_name', 'geo', 'id', 'name', 'place_type']]], Field(description="A comma separated list of Place fields to display.", unique_items=True)] = None, **kwargs) -> StreamingTweetResponse:  # noqa: E501
        """Sample stream  # noqa: E501

        Streams a deterministic 1% of public Tweets.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.sample_stream(backfill_minutes, tweet_fields, expansions, media_fields, poll_fields, user_fields, place_fields, async_req=True)
        >>> result = thread.get()

        :param backfill_minutes: The number of minutes of backfill requested.
        :type backfill_minutes: int
        :param tweet_fields: A comma separated list of Tweet fields to display.
        :type tweet_fields: List[str]
        :param expansions: A comma separated list of fields to expand.
        :type expansions: List[str]
        :param media_fields: A comma separated list of Media fields to display.
        :type media_fields: List[str]
        :param poll_fields: A comma separated list of Poll fields to display.
        :type poll_fields: List[str]
        :param user_fields: A comma separated list of User fields to display.
        :type user_fields: List[str]
        :param place_fields: A comma separated list of Place fields to display.
        :type place_fields: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: StreamingTweetResponse
        """
        kwargs['_return_http_data_only'] = True
        return self.sample_stream_with_http_info(backfill_minutes, tweet_fields, expansions, media_fields, poll_fields, user_fields, place_fields, **kwargs)  # noqa: E501

    @validate_arguments
    def sample_stream_with_http_info(self, backfill_minutes : Annotated[Optional[conint(strict=True, ge=5, le=0)], Field(description="The number of minutes of backfill requested.")] = None, tweet_fields : Annotated[Optional[List[Literal['attachments', 'author_id', 'context_annotations', 'conversation_id', 'created_at', 'entities', 'geo', 'id', 'in_reply_to_user_id', 'lang', 'non_public_metrics', 'organic_metrics', 'possibly_sensitive', 'promoted_metrics', 'public_metrics', 'referenced_tweets', 'reply_settings', 'source', 'text', 'withheld']]], Field(description="A comma separated list of Tweet fields to display.", unique_items=True)] = None, expansions : Annotated[Optional[List[Literal['attachments.media_keys', 'attachments.poll_ids', 'author_id', 'entities.mentions.username', 'geo.place_id', 'in_reply_to_user_id', 'referenced_tweets.id', 'referenced_tweets.id.author_id']]], Field(description="A comma separated list of fields to expand.", unique_items=True)] = None, media_fields : Annotated[Optional[List[Literal['alt_text', 'duration_ms', 'height', 'media_key', 'non_public_metrics', 'organic_metrics', 'preview_image_url', 'promoted_metrics', 'public_metrics', 'type', 'url', 'variants', 'width']]], Field(description="A comma separated list of Media fields to display.", unique_items=True)] = None, poll_fields : Annotated[Optional[List[Literal['duration_minutes', 'end_datetime', 'id', 'options', 'voting_status']]], Field(description="A comma separated list of Poll fields to display.", unique_items=True)] = None, user_fields : Annotated[Optional[List[Literal['created_at', 'description', 'entities', 'id', 'location', 'name', 'pinned_tweet_id', 'profile_image_url', 'protected', 'public_metrics', 'url', 'username', 'verified', 'withheld']]], Field(description="A comma separated list of User fields to display.", unique_items=True)] = None, place_fields : Annotated[Optional[List[Literal['contained_within', 'country', 'country_code', 'full_name', 'geo', 'id', 'name', 'place_type']]], Field(description="A comma separated list of Place fields to display.", unique_items=True)] = None, **kwargs):  # noqa: E501
        """Sample stream  # noqa: E501

        Streams a deterministic 1% of public Tweets.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.sample_stream_with_http_info(backfill_minutes, tweet_fields, expansions, media_fields, poll_fields, user_fields, place_fields, async_req=True)
        >>> result = thread.get()

        :param backfill_minutes: The number of minutes of backfill requested.
        :type backfill_minutes: int
        :param tweet_fields: A comma separated list of Tweet fields to display.
        :type tweet_fields: List[str]
        :param expansions: A comma separated list of fields to expand.
        :type expansions: List[str]
        :param media_fields: A comma separated list of Media fields to display.
        :type media_fields: List[str]
        :param poll_fields: A comma separated list of Poll fields to display.
        :type poll_fields: List[str]
        :param user_fields: A comma separated list of User fields to display.
        :type user_fields: List[str]
        :param place_fields: A comma separated list of Place fields to display.
        :type place_fields: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(StreamingTweetResponse, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'backfill_minutes',
            'tweet_fields',
            'expansions',
            'media_fields',
            'poll_fields',
            'user_fields',
            'place_fields'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in local_var_params['kwargs'].items():
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method sample_stream" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if local_var_params.get('backfill_minutes') is not None:  # noqa: E501
            query_params.append(('backfill_minutes', local_var_params['backfill_minutes']))
        if local_var_params.get('tweet_fields') is not None:  # noqa: E501
            query_params.append(('tweet.fields', local_var_params['tweet_fields']))
            collection_formats['tweet.fields'] = 'csv'
        if local_var_params.get('expansions') is not None:  # noqa: E501
            query_params.append(('expansions', local_var_params['expansions']))
            collection_formats['expansions'] = 'csv'
        if local_var_params.get('media_fields') is not None:  # noqa: E501
            query_params.append(('media.fields', local_var_params['media_fields']))
            collection_formats['media.fields'] = 'csv'
        if local_var_params.get('poll_fields') is not None:  # noqa: E501
            query_params.append(('poll.fields', local_var_params['poll_fields']))
            collection_formats['poll.fields'] = 'csv'
        if local_var_params.get('user_fields') is not None:  # noqa: E501
            query_params.append(('user.fields', local_var_params['user_fields']))
            collection_formats['user.fields'] = 'csv'
        if local_var_params.get('place_fields') is not None:  # noqa: E501
            query_params.append(('place.fields', local_var_params['place_fields']))
            collection_formats['place.fields'] = 'csv'

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'application/problem+json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BearerToken']  # noqa: E501

        response_types_map = {
            200: "StreamingTweetResponse",
        }

        return self.api_client.call_api(
            '/2/tweets/sample/stream', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    @validate_arguments
    def search_stream(self, backfill_minutes : Annotated[Optional[conint(strict=True, ge=5, le=0)], Field(description="The number of minutes of backfill requested.")] = None, start_time : Annotated[Optional[datetime], Field(description="YYYY-MM-DDTHH:mm:ssZ. The earliest UTC timestamp from which the Tweets will be provided.")] = None, end_time : Annotated[Optional[datetime], Field(description="YYYY-MM-DDTHH:mm:ssZ. The latest UTC timestamp to which the Tweets will be provided.")] = None, tweet_fields : Annotated[Optional[List[Literal['attachments', 'author_id', 'context_annotations', 'conversation_id', 'created_at', 'entities', 'geo', 'id', 'in_reply_to_user_id', 'lang', 'non_public_metrics', 'organic_metrics', 'possibly_sensitive', 'promoted_metrics', 'public_metrics', 'referenced_tweets', 'reply_settings', 'source', 'text', 'withheld']]], Field(description="A comma separated list of Tweet fields to display.", unique_items=True)] = None, expansions : Annotated[Optional[List[Literal['attachments.media_keys', 'attachments.poll_ids', 'author_id', 'entities.mentions.username', 'geo.place_id', 'in_reply_to_user_id', 'referenced_tweets.id', 'referenced_tweets.id.author_id']]], Field(description="A comma separated list of fields to expand.", unique_items=True)] = None, media_fields : Annotated[Optional[List[Literal['alt_text', 'duration_ms', 'height', 'media_key', 'non_public_metrics', 'organic_metrics', 'preview_image_url', 'promoted_metrics', 'public_metrics', 'type', 'url', 'variants', 'width']]], Field(description="A comma separated list of Media fields to display.", unique_items=True)] = None, poll_fields : Annotated[Optional[List[Literal['duration_minutes', 'end_datetime', 'id', 'options', 'voting_status']]], Field(description="A comma separated list of Poll fields to display.", unique_items=True)] = None, user_fields : Annotated[Optional[List[Literal['created_at', 'description', 'entities', 'id', 'location', 'name', 'pinned_tweet_id', 'profile_image_url', 'protected', 'public_metrics', 'url', 'username', 'verified', 'withheld']]], Field(description="A comma separated list of User fields to display.", unique_items=True)] = None, place_fields : Annotated[Optional[List[Literal['contained_within', 'country', 'country_code', 'full_name', 'geo', 'id', 'name', 'place_type']]], Field(description="A comma separated list of Place fields to display.", unique_items=True)] = None, **kwargs) -> FilteredStreamingTweetResponse:  # noqa: E501
        """Filtered stream  # noqa: E501

        Streams Tweets matching the stream's active rule set.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.search_stream(backfill_minutes, start_time, end_time, tweet_fields, expansions, media_fields, poll_fields, user_fields, place_fields, async_req=True)
        >>> result = thread.get()

        :param backfill_minutes: The number of minutes of backfill requested.
        :type backfill_minutes: int
        :param start_time: YYYY-MM-DDTHH:mm:ssZ. The earliest UTC timestamp from which the Tweets will be provided.
        :type start_time: datetime
        :param end_time: YYYY-MM-DDTHH:mm:ssZ. The latest UTC timestamp to which the Tweets will be provided.
        :type end_time: datetime
        :param tweet_fields: A comma separated list of Tweet fields to display.
        :type tweet_fields: List[str]
        :param expansions: A comma separated list of fields to expand.
        :type expansions: List[str]
        :param media_fields: A comma separated list of Media fields to display.
        :type media_fields: List[str]
        :param poll_fields: A comma separated list of Poll fields to display.
        :type poll_fields: List[str]
        :param user_fields: A comma separated list of User fields to display.
        :type user_fields: List[str]
        :param place_fields: A comma separated list of Place fields to display.
        :type place_fields: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: FilteredStreamingTweetResponse
        """
        kwargs['_return_http_data_only'] = True
        return self.search_stream_with_http_info(backfill_minutes, start_time, end_time, tweet_fields, expansions, media_fields, poll_fields, user_fields, place_fields, **kwargs)  # noqa: E501

    @validate_arguments
    def search_stream_with_http_info(self, backfill_minutes : Annotated[Optional[conint(strict=True, ge=5, le=0)], Field(description="The number of minutes of backfill requested.")] = None, start_time : Annotated[Optional[datetime], Field(description="YYYY-MM-DDTHH:mm:ssZ. The earliest UTC timestamp from which the Tweets will be provided.")] = None, end_time : Annotated[Optional[datetime], Field(description="YYYY-MM-DDTHH:mm:ssZ. The latest UTC timestamp to which the Tweets will be provided.")] = None, tweet_fields : Annotated[Optional[List[Literal['attachments', 'author_id', 'context_annotations', 'conversation_id', 'created_at', 'entities', 'geo', 'id', 'in_reply_to_user_id', 'lang', 'non_public_metrics', 'organic_metrics', 'possibly_sensitive', 'promoted_metrics', 'public_metrics', 'referenced_tweets', 'reply_settings', 'source', 'text', 'withheld']]], Field(description="A comma separated list of Tweet fields to display.", unique_items=True)] = None, expansions : Annotated[Optional[List[Literal['attachments.media_keys', 'attachments.poll_ids', 'author_id', 'entities.mentions.username', 'geo.place_id', 'in_reply_to_user_id', 'referenced_tweets.id', 'referenced_tweets.id.author_id']]], Field(description="A comma separated list of fields to expand.", unique_items=True)] = None, media_fields : Annotated[Optional[List[Literal['alt_text', 'duration_ms', 'height', 'media_key', 'non_public_metrics', 'organic_metrics', 'preview_image_url', 'promoted_metrics', 'public_metrics', 'type', 'url', 'variants', 'width']]], Field(description="A comma separated list of Media fields to display.", unique_items=True)] = None, poll_fields : Annotated[Optional[List[Literal['duration_minutes', 'end_datetime', 'id', 'options', 'voting_status']]], Field(description="A comma separated list of Poll fields to display.", unique_items=True)] = None, user_fields : Annotated[Optional[List[Literal['created_at', 'description', 'entities', 'id', 'location', 'name', 'pinned_tweet_id', 'profile_image_url', 'protected', 'public_metrics', 'url', 'username', 'verified', 'withheld']]], Field(description="A comma separated list of User fields to display.", unique_items=True)] = None, place_fields : Annotated[Optional[List[Literal['contained_within', 'country', 'country_code', 'full_name', 'geo', 'id', 'name', 'place_type']]], Field(description="A comma separated list of Place fields to display.", unique_items=True)] = None, **kwargs):  # noqa: E501
        """Filtered stream  # noqa: E501

        Streams Tweets matching the stream's active rule set.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.search_stream_with_http_info(backfill_minutes, start_time, end_time, tweet_fields, expansions, media_fields, poll_fields, user_fields, place_fields, async_req=True)
        >>> result = thread.get()

        :param backfill_minutes: The number of minutes of backfill requested.
        :type backfill_minutes: int
        :param start_time: YYYY-MM-DDTHH:mm:ssZ. The earliest UTC timestamp from which the Tweets will be provided.
        :type start_time: datetime
        :param end_time: YYYY-MM-DDTHH:mm:ssZ. The latest UTC timestamp to which the Tweets will be provided.
        :type end_time: datetime
        :param tweet_fields: A comma separated list of Tweet fields to display.
        :type tweet_fields: List[str]
        :param expansions: A comma separated list of fields to expand.
        :type expansions: List[str]
        :param media_fields: A comma separated list of Media fields to display.
        :type media_fields: List[str]
        :param poll_fields: A comma separated list of Poll fields to display.
        :type poll_fields: List[str]
        :param user_fields: A comma separated list of User fields to display.
        :type user_fields: List[str]
        :param place_fields: A comma separated list of Place fields to display.
        :type place_fields: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(FilteredStreamingTweetResponse, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'backfill_minutes',
            'start_time',
            'end_time',
            'tweet_fields',
            'expansions',
            'media_fields',
            'poll_fields',
            'user_fields',
            'place_fields'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in local_var_params['kwargs'].items():
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method search_stream" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if local_var_params.get('backfill_minutes') is not None:  # noqa: E501
            query_params.append(('backfill_minutes', local_var_params['backfill_minutes']))
        if local_var_params.get('start_time') is not None:  # noqa: E501
            query_params.append(('start_time', local_var_params['start_time']))
        if local_var_params.get('end_time') is not None:  # noqa: E501
            query_params.append(('end_time', local_var_params['end_time']))
        if local_var_params.get('tweet_fields') is not None:  # noqa: E501
            query_params.append(('tweet.fields', local_var_params['tweet_fields']))
            collection_formats['tweet.fields'] = 'csv'
        if local_var_params.get('expansions') is not None:  # noqa: E501
            query_params.append(('expansions', local_var_params['expansions']))
            collection_formats['expansions'] = 'csv'
        if local_var_params.get('media_fields') is not None:  # noqa: E501
            query_params.append(('media.fields', local_var_params['media_fields']))
            collection_formats['media.fields'] = 'csv'
        if local_var_params.get('poll_fields') is not None:  # noqa: E501
            query_params.append(('poll.fields', local_var_params['poll_fields']))
            collection_formats['poll.fields'] = 'csv'
        if local_var_params.get('user_fields') is not None:  # noqa: E501
            query_params.append(('user.fields', local_var_params['user_fields']))
            collection_formats['user.fields'] = 'csv'
        if local_var_params.get('place_fields') is not None:  # noqa: E501
            query_params.append(('place.fields', local_var_params['place_fields']))
            collection_formats['place.fields'] = 'csv'

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'application/problem+json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BearerToken']  # noqa: E501

        response_types_map = {
            200: "FilteredStreamingTweetResponse",
        }

        return self.api_client.call_api(
            '/2/tweets/search/stream', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    @validate_arguments
    def space_buyers(self, id : Annotated[constr(strict=True, regex=r'/^[a-zA-Z0-9]{1,13}$/'), Field(..., description="The ID of the Space to be retrieved.")], pagination_token : Annotated[Optional[constr(strict=True, min_length=16)], Field(description="This parameter is used to get a specified 'page' of results.")] = None, max_results : Annotated[Optional[conint(strict=True, ge=100, le=1)], Field(description="The maximum number of results.")] = None, user_fields : Annotated[Optional[List[Literal['created_at', 'description', 'entities', 'id', 'location', 'name', 'pinned_tweet_id', 'profile_image_url', 'protected', 'public_metrics', 'url', 'username', 'verified', 'withheld']]], Field(description="A comma separated list of User fields to display.", unique_items=True)] = None, expansions : Annotated[Optional[List[Literal['pinned_tweet_id']]], Field(description="A comma separated list of fields to expand.", unique_items=True)] = None, tweet_fields : Annotated[Optional[List[Literal['attachments', 'author_id', 'context_annotations', 'conversation_id', 'created_at', 'entities', 'geo', 'id', 'in_reply_to_user_id', 'lang', 'non_public_metrics', 'organic_metrics', 'possibly_sensitive', 'promoted_metrics', 'public_metrics', 'referenced_tweets', 'reply_settings', 'source', 'text', 'withheld']]], Field(description="A comma separated list of Tweet fields to display.", unique_items=True)] = None, **kwargs) -> Get2SpacesIdBuyersResponse:  # noqa: E501
        """Retrieve the list of Users who purchased a ticket to the given space  # noqa: E501

        Retrieves the list of Users who purchased a ticket to the given space  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.space_buyers(id, pagination_token, max_results, user_fields, expansions, tweet_fields, async_req=True)
        >>> result = thread.get()

        :param id: The ID of the Space to be retrieved. (required)
        :type id: str
        :param pagination_token: This parameter is used to get a specified 'page' of results.
        :type pagination_token: str
        :param max_results: The maximum number of results.
        :type max_results: int
        :param user_fields: A comma separated list of User fields to display.
        :type user_fields: List[str]
        :param expansions: A comma separated list of fields to expand.
        :type expansions: List[str]
        :param tweet_fields: A comma separated list of Tweet fields to display.
        :type tweet_fields: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: Get2SpacesIdBuyersResponse
        """
        kwargs['_return_http_data_only'] = True
        return self.space_buyers_with_http_info(id, pagination_token, max_results, user_fields, expansions, tweet_fields, **kwargs)  # noqa: E501

    @validate_arguments
    def space_buyers_with_http_info(self, id : Annotated[constr(strict=True, regex=r'/^[a-zA-Z0-9]{1,13}$/'), Field(..., description="The ID of the Space to be retrieved.")], pagination_token : Annotated[Optional[constr(strict=True, min_length=16)], Field(description="This parameter is used to get a specified 'page' of results.")] = None, max_results : Annotated[Optional[conint(strict=True, ge=100, le=1)], Field(description="The maximum number of results.")] = None, user_fields : Annotated[Optional[List[Literal['created_at', 'description', 'entities', 'id', 'location', 'name', 'pinned_tweet_id', 'profile_image_url', 'protected', 'public_metrics', 'url', 'username', 'verified', 'withheld']]], Field(description="A comma separated list of User fields to display.", unique_items=True)] = None, expansions : Annotated[Optional[List[Literal['pinned_tweet_id']]], Field(description="A comma separated list of fields to expand.", unique_items=True)] = None, tweet_fields : Annotated[Optional[List[Literal['attachments', 'author_id', 'context_annotations', 'conversation_id', 'created_at', 'entities', 'geo', 'id', 'in_reply_to_user_id', 'lang', 'non_public_metrics', 'organic_metrics', 'possibly_sensitive', 'promoted_metrics', 'public_metrics', 'referenced_tweets', 'reply_settings', 'source', 'text', 'withheld']]], Field(description="A comma separated list of Tweet fields to display.", unique_items=True)] = None, **kwargs):  # noqa: E501
        """Retrieve the list of Users who purchased a ticket to the given space  # noqa: E501

        Retrieves the list of Users who purchased a ticket to the given space  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.space_buyers_with_http_info(id, pagination_token, max_results, user_fields, expansions, tweet_fields, async_req=True)
        >>> result = thread.get()

        :param id: The ID of the Space to be retrieved. (required)
        :type id: str
        :param pagination_token: This parameter is used to get a specified 'page' of results.
        :type pagination_token: str
        :param max_results: The maximum number of results.
        :type max_results: int
        :param user_fields: A comma separated list of User fields to display.
        :type user_fields: List[str]
        :param expansions: A comma separated list of fields to expand.
        :type expansions: List[str]
        :param tweet_fields: A comma separated list of Tweet fields to display.
        :type tweet_fields: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(Get2SpacesIdBuyersResponse, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'id',
            'pagination_token',
            'max_results',
            'user_fields',
            'expansions',
            'tweet_fields'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in local_var_params['kwargs'].items():
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method space_buyers" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        collection_formats = {}

        path_params = {}
        if local_var_params['id']:
            path_params['id'] = local_var_params['id']

        query_params = []
        if local_var_params.get('pagination_token') is not None:  # noqa: E501
            query_params.append(('pagination_token', local_var_params['pagination_token']))
        if local_var_params.get('max_results') is not None:  # noqa: E501
            query_params.append(('max_results', local_var_params['max_results']))
        if local_var_params.get('user_fields') is not None:  # noqa: E501
            query_params.append(('user.fields', local_var_params['user_fields']))
            collection_formats['user.fields'] = 'csv'
        if local_var_params.get('expansions') is not None:  # noqa: E501
            query_params.append(('expansions', local_var_params['expansions']))
            collection_formats['expansions'] = 'csv'
        if local_var_params.get('tweet_fields') is not None:  # noqa: E501
            query_params.append(('tweet.fields', local_var_params['tweet_fields']))
            collection_formats['tweet.fields'] = 'csv'

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'application/problem+json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['OAuth2UserToken']  # noqa: E501

        response_types_map = {
            200: "Get2SpacesIdBuyersResponse",
        }

        return self.api_client.call_api(
            '/2/spaces/{id}/buyers', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    @validate_arguments
    def space_tweets(self, id : Annotated[constr(strict=True, regex=r'/^[a-zA-Z0-9]{1,13}$/'), Field(..., description="The ID of the Space to be retrieved.")], max_results : Annotated[Optional[conint(strict=True, ge=100, le=1)], Field(description="The number of Tweets to fetch from the provided space. If not provided, the value will default to the maximum of 100.")] = None, tweet_fields : Annotated[Optional[List[Literal['attachments', 'author_id', 'context_annotations', 'conversation_id', 'created_at', 'entities', 'geo', 'id', 'in_reply_to_user_id', 'lang', 'non_public_metrics', 'organic_metrics', 'possibly_sensitive', 'promoted_metrics', 'public_metrics', 'referenced_tweets', 'reply_settings', 'source', 'text', 'withheld']]], Field(description="A comma separated list of Tweet fields to display.", unique_items=True)] = None, expansions : Annotated[Optional[List[Literal['attachments.media_keys', 'attachments.poll_ids', 'author_id', 'entities.mentions.username', 'geo.place_id', 'in_reply_to_user_id', 'referenced_tweets.id', 'referenced_tweets.id.author_id']]], Field(description="A comma separated list of fields to expand.", unique_items=True)] = None, media_fields : Annotated[Optional[List[Literal['alt_text', 'duration_ms', 'height', 'media_key', 'non_public_metrics', 'organic_metrics', 'preview_image_url', 'promoted_metrics', 'public_metrics', 'type', 'url', 'variants', 'width']]], Field(description="A comma separated list of Media fields to display.", unique_items=True)] = None, poll_fields : Annotated[Optional[List[Literal['duration_minutes', 'end_datetime', 'id', 'options', 'voting_status']]], Field(description="A comma separated list of Poll fields to display.", unique_items=True)] = None, user_fields : Annotated[Optional[List[Literal['created_at', 'description', 'entities', 'id', 'location', 'name', 'pinned_tweet_id', 'profile_image_url', 'protected', 'public_metrics', 'url', 'username', 'verified', 'withheld']]], Field(description="A comma separated list of User fields to display.", unique_items=True)] = None, place_fields : Annotated[Optional[List[Literal['contained_within', 'country', 'country_code', 'full_name', 'geo', 'id', 'name', 'place_type']]], Field(description="A comma separated list of Place fields to display.", unique_items=True)] = None, **kwargs) -> Get2SpacesIdTweetsResponse:  # noqa: E501
        """Retrieve Tweets from a Space.  # noqa: E501

        Retrieves Tweets shared in the specified Space.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.space_tweets(id, max_results, tweet_fields, expansions, media_fields, poll_fields, user_fields, place_fields, async_req=True)
        >>> result = thread.get()

        :param id: The ID of the Space to be retrieved. (required)
        :type id: str
        :param max_results: The number of Tweets to fetch from the provided space. If not provided, the value will default to the maximum of 100.
        :type max_results: int
        :param tweet_fields: A comma separated list of Tweet fields to display.
        :type tweet_fields: List[str]
        :param expansions: A comma separated list of fields to expand.
        :type expansions: List[str]
        :param media_fields: A comma separated list of Media fields to display.
        :type media_fields: List[str]
        :param poll_fields: A comma separated list of Poll fields to display.
        :type poll_fields: List[str]
        :param user_fields: A comma separated list of User fields to display.
        :type user_fields: List[str]
        :param place_fields: A comma separated list of Place fields to display.
        :type place_fields: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: Get2SpacesIdTweetsResponse
        """
        kwargs['_return_http_data_only'] = True
        return self.space_tweets_with_http_info(id, max_results, tweet_fields, expansions, media_fields, poll_fields, user_fields, place_fields, **kwargs)  # noqa: E501

    @validate_arguments
    def space_tweets_with_http_info(self, id : Annotated[constr(strict=True, regex=r'/^[a-zA-Z0-9]{1,13}$/'), Field(..., description="The ID of the Space to be retrieved.")], max_results : Annotated[Optional[conint(strict=True, ge=100, le=1)], Field(description="The number of Tweets to fetch from the provided space. If not provided, the value will default to the maximum of 100.")] = None, tweet_fields : Annotated[Optional[List[Literal['attachments', 'author_id', 'context_annotations', 'conversation_id', 'created_at', 'entities', 'geo', 'id', 'in_reply_to_user_id', 'lang', 'non_public_metrics', 'organic_metrics', 'possibly_sensitive', 'promoted_metrics', 'public_metrics', 'referenced_tweets', 'reply_settings', 'source', 'text', 'withheld']]], Field(description="A comma separated list of Tweet fields to display.", unique_items=True)] = None, expansions : Annotated[Optional[List[Literal['attachments.media_keys', 'attachments.poll_ids', 'author_id', 'entities.mentions.username', 'geo.place_id', 'in_reply_to_user_id', 'referenced_tweets.id', 'referenced_tweets.id.author_id']]], Field(description="A comma separated list of fields to expand.", unique_items=True)] = None, media_fields : Annotated[Optional[List[Literal['alt_text', 'duration_ms', 'height', 'media_key', 'non_public_metrics', 'organic_metrics', 'preview_image_url', 'promoted_metrics', 'public_metrics', 'type', 'url', 'variants', 'width']]], Field(description="A comma separated list of Media fields to display.", unique_items=True)] = None, poll_fields : Annotated[Optional[List[Literal['duration_minutes', 'end_datetime', 'id', 'options', 'voting_status']]], Field(description="A comma separated list of Poll fields to display.", unique_items=True)] = None, user_fields : Annotated[Optional[List[Literal['created_at', 'description', 'entities', 'id', 'location', 'name', 'pinned_tweet_id', 'profile_image_url', 'protected', 'public_metrics', 'url', 'username', 'verified', 'withheld']]], Field(description="A comma separated list of User fields to display.", unique_items=True)] = None, place_fields : Annotated[Optional[List[Literal['contained_within', 'country', 'country_code', 'full_name', 'geo', 'id', 'name', 'place_type']]], Field(description="A comma separated list of Place fields to display.", unique_items=True)] = None, **kwargs):  # noqa: E501
        """Retrieve Tweets from a Space.  # noqa: E501

        Retrieves Tweets shared in the specified Space.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.space_tweets_with_http_info(id, max_results, tweet_fields, expansions, media_fields, poll_fields, user_fields, place_fields, async_req=True)
        >>> result = thread.get()

        :param id: The ID of the Space to be retrieved. (required)
        :type id: str
        :param max_results: The number of Tweets to fetch from the provided space. If not provided, the value will default to the maximum of 100.
        :type max_results: int
        :param tweet_fields: A comma separated list of Tweet fields to display.
        :type tweet_fields: List[str]
        :param expansions: A comma separated list of fields to expand.
        :type expansions: List[str]
        :param media_fields: A comma separated list of Media fields to display.
        :type media_fields: List[str]
        :param poll_fields: A comma separated list of Poll fields to display.
        :type poll_fields: List[str]
        :param user_fields: A comma separated list of User fields to display.
        :type user_fields: List[str]
        :param place_fields: A comma separated list of Place fields to display.
        :type place_fields: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(Get2SpacesIdTweetsResponse, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'id',
            'max_results',
            'tweet_fields',
            'expansions',
            'media_fields',
            'poll_fields',
            'user_fields',
            'place_fields'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in local_var_params['kwargs'].items():
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method space_tweets" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        collection_formats = {}

        path_params = {}
        if local_var_params['id']:
            path_params['id'] = local_var_params['id']

        query_params = []
        if local_var_params.get('max_results') is not None:  # noqa: E501
            query_params.append(('max_results', local_var_params['max_results']))
        if local_var_params.get('tweet_fields') is not None:  # noqa: E501
            query_params.append(('tweet.fields', local_var_params['tweet_fields']))
            collection_formats['tweet.fields'] = 'csv'
        if local_var_params.get('expansions') is not None:  # noqa: E501
            query_params.append(('expansions', local_var_params['expansions']))
            collection_formats['expansions'] = 'csv'
        if local_var_params.get('media_fields') is not None:  # noqa: E501
            query_params.append(('media.fields', local_var_params['media_fields']))
            collection_formats['media.fields'] = 'csv'
        if local_var_params.get('poll_fields') is not None:  # noqa: E501
            query_params.append(('poll.fields', local_var_params['poll_fields']))
            collection_formats['poll.fields'] = 'csv'
        if local_var_params.get('user_fields') is not None:  # noqa: E501
            query_params.append(('user.fields', local_var_params['user_fields']))
            collection_formats['user.fields'] = 'csv'
        if local_var_params.get('place_fields') is not None:  # noqa: E501
            query_params.append(('place.fields', local_var_params['place_fields']))
            collection_formats['place.fields'] = 'csv'

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'application/problem+json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BearerToken', 'OAuth2UserToken']  # noqa: E501

        response_types_map = {
            200: "Get2SpacesIdTweetsResponse",
        }

        return self.api_client.call_api(
            '/2/spaces/{id}/tweets', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    @validate_arguments
    def tweet_counts_full_archive_search(self, query : Annotated[constr(strict=True, max_length=4096, min_length=1), Field(..., description="One query/rule/filter for matching Tweets. Refer to https://t.co/rulelength to identify the max query length.")], start_time : Annotated[Optional[datetime], Field(description="YYYY-MM-DDTHH:mm:ssZ. The oldest UTC timestamp (from most recent 7 days) from which the Tweets will be provided. Timestamp is in second granularity and is inclusive (i.e. 12:00:01 includes the first second of the minute).")] = None, end_time : Annotated[Optional[datetime], Field(description="YYYY-MM-DDTHH:mm:ssZ. The newest, most recent UTC timestamp to which the Tweets will be provided. Timestamp is in second granularity and is exclusive (i.e. 12:00:01 excludes the first second of the minute).")] = None, since_id : Annotated[Optional[constr(strict=True, regex=r'/^[0-9]{1,19}$/')], Field(description="Returns results with a Tweet ID greater than (that is, more recent than) the specified ID.")] = None, until_id : Annotated[Optional[constr(strict=True, regex=r'/^[0-9]{1,19}$/')], Field(description="Returns results with a Tweet ID less than (that is, older than) the specified ID.")] = None, next_token : Annotated[Optional[constr(strict=True, min_length=1)], Field(description="This parameter is used to get the next 'page' of results. The value used with the parameter is pulled directly from the response provided by the API, and should not be modified.")] = None, pagination_token : Annotated[Optional[constr(strict=True, min_length=1)], Field(description="This parameter is used to get the next 'page' of results. The value used with the parameter is pulled directly from the response provided by the API, and should not be modified.")] = None, granularity : Annotated[Optional[StrictStr], Field(description="The granularity for the search counts results.")] = None, search_count_fields : Annotated[Optional[List[Literal['end', 'start', 'tweet_count']]], Field(description="A comma separated list of SearchCount fields to display.", unique_items=True)] = None, **kwargs) -> Get2TweetsCountsAllResponse:  # noqa: E501
        """Full archive search counts  # noqa: E501

        Returns Tweet Counts that match a search query.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.tweet_counts_full_archive_search(query, start_time, end_time, since_id, until_id, next_token, pagination_token, granularity, search_count_fields, async_req=True)
        >>> result = thread.get()

        :param query: One query/rule/filter for matching Tweets. Refer to https://t.co/rulelength to identify the max query length. (required)
        :type query: str
        :param start_time: YYYY-MM-DDTHH:mm:ssZ. The oldest UTC timestamp (from most recent 7 days) from which the Tweets will be provided. Timestamp is in second granularity and is inclusive (i.e. 12:00:01 includes the first second of the minute).
        :type start_time: datetime
        :param end_time: YYYY-MM-DDTHH:mm:ssZ. The newest, most recent UTC timestamp to which the Tweets will be provided. Timestamp is in second granularity and is exclusive (i.e. 12:00:01 excludes the first second of the minute).
        :type end_time: datetime
        :param since_id: Returns results with a Tweet ID greater than (that is, more recent than) the specified ID.
        :type since_id: str
        :param until_id: Returns results with a Tweet ID less than (that is, older than) the specified ID.
        :type until_id: str
        :param next_token: This parameter is used to get the next 'page' of results. The value used with the parameter is pulled directly from the response provided by the API, and should not be modified.
        :type next_token: str
        :param pagination_token: This parameter is used to get the next 'page' of results. The value used with the parameter is pulled directly from the response provided by the API, and should not be modified.
        :type pagination_token: str
        :param granularity: The granularity for the search counts results.
        :type granularity: str
        :param search_count_fields: A comma separated list of SearchCount fields to display.
        :type search_count_fields: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: Get2TweetsCountsAllResponse
        """
        kwargs['_return_http_data_only'] = True
        return self.tweet_counts_full_archive_search_with_http_info(query, start_time, end_time, since_id, until_id, next_token, pagination_token, granularity, search_count_fields, **kwargs)  # noqa: E501

    @validate_arguments
    def tweet_counts_full_archive_search_with_http_info(self, query : Annotated[constr(strict=True, max_length=4096, min_length=1), Field(..., description="One query/rule/filter for matching Tweets. Refer to https://t.co/rulelength to identify the max query length.")], start_time : Annotated[Optional[datetime], Field(description="YYYY-MM-DDTHH:mm:ssZ. The oldest UTC timestamp (from most recent 7 days) from which the Tweets will be provided. Timestamp is in second granularity and is inclusive (i.e. 12:00:01 includes the first second of the minute).")] = None, end_time : Annotated[Optional[datetime], Field(description="YYYY-MM-DDTHH:mm:ssZ. The newest, most recent UTC timestamp to which the Tweets will be provided. Timestamp is in second granularity and is exclusive (i.e. 12:00:01 excludes the first second of the minute).")] = None, since_id : Annotated[Optional[constr(strict=True, regex=r'/^[0-9]{1,19}$/')], Field(description="Returns results with a Tweet ID greater than (that is, more recent than) the specified ID.")] = None, until_id : Annotated[Optional[constr(strict=True, regex=r'/^[0-9]{1,19}$/')], Field(description="Returns results with a Tweet ID less than (that is, older than) the specified ID.")] = None, next_token : Annotated[Optional[constr(strict=True, min_length=1)], Field(description="This parameter is used to get the next 'page' of results. The value used with the parameter is pulled directly from the response provided by the API, and should not be modified.")] = None, pagination_token : Annotated[Optional[constr(strict=True, min_length=1)], Field(description="This parameter is used to get the next 'page' of results. The value used with the parameter is pulled directly from the response provided by the API, and should not be modified.")] = None, granularity : Annotated[Optional[StrictStr], Field(description="The granularity for the search counts results.")] = None, search_count_fields : Annotated[Optional[List[Literal['end', 'start', 'tweet_count']]], Field(description="A comma separated list of SearchCount fields to display.", unique_items=True)] = None, **kwargs):  # noqa: E501
        """Full archive search counts  # noqa: E501

        Returns Tweet Counts that match a search query.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.tweet_counts_full_archive_search_with_http_info(query, start_time, end_time, since_id, until_id, next_token, pagination_token, granularity, search_count_fields, async_req=True)
        >>> result = thread.get()

        :param query: One query/rule/filter for matching Tweets. Refer to https://t.co/rulelength to identify the max query length. (required)
        :type query: str
        :param start_time: YYYY-MM-DDTHH:mm:ssZ. The oldest UTC timestamp (from most recent 7 days) from which the Tweets will be provided. Timestamp is in second granularity and is inclusive (i.e. 12:00:01 includes the first second of the minute).
        :type start_time: datetime
        :param end_time: YYYY-MM-DDTHH:mm:ssZ. The newest, most recent UTC timestamp to which the Tweets will be provided. Timestamp is in second granularity and is exclusive (i.e. 12:00:01 excludes the first second of the minute).
        :type end_time: datetime
        :param since_id: Returns results with a Tweet ID greater than (that is, more recent than) the specified ID.
        :type since_id: str
        :param until_id: Returns results with a Tweet ID less than (that is, older than) the specified ID.
        :type until_id: str
        :param next_token: This parameter is used to get the next 'page' of results. The value used with the parameter is pulled directly from the response provided by the API, and should not be modified.
        :type next_token: str
        :param pagination_token: This parameter is used to get the next 'page' of results. The value used with the parameter is pulled directly from the response provided by the API, and should not be modified.
        :type pagination_token: str
        :param granularity: The granularity for the search counts results.
        :type granularity: str
        :param search_count_fields: A comma separated list of SearchCount fields to display.
        :type search_count_fields: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(Get2TweetsCountsAllResponse, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'query',
            'start_time',
            'end_time',
            'since_id',
            'until_id',
            'next_token',
            'pagination_token',
            'granularity',
            'search_count_fields'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in local_var_params['kwargs'].items():
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method tweet_counts_full_archive_search" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if local_var_params.get('query') is not None:  # noqa: E501
            query_params.append(('query', local_var_params['query']))
        if local_var_params.get('start_time') is not None:  # noqa: E501
            query_params.append(('start_time', local_var_params['start_time']))
        if local_var_params.get('end_time') is not None:  # noqa: E501
            query_params.append(('end_time', local_var_params['end_time']))
        if local_var_params.get('since_id') is not None:  # noqa: E501
            query_params.append(('since_id', local_var_params['since_id']))
        if local_var_params.get('until_id') is not None:  # noqa: E501
            query_params.append(('until_id', local_var_params['until_id']))
        if local_var_params.get('next_token') is not None:  # noqa: E501
            query_params.append(('next_token', local_var_params['next_token']))
        if local_var_params.get('pagination_token') is not None:  # noqa: E501
            query_params.append(('pagination_token', local_var_params['pagination_token']))
        if local_var_params.get('granularity') is not None:  # noqa: E501
            query_params.append(('granularity', local_var_params['granularity']))
        if local_var_params.get('search_count_fields') is not None:  # noqa: E501
            query_params.append(('search_count.fields', local_var_params['search_count_fields']))
            collection_formats['search_count.fields'] = 'csv'

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'application/problem+json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BearerToken']  # noqa: E501

        response_types_map = {
            200: "Get2TweetsCountsAllResponse",
        }

        return self.api_client.call_api(
            '/2/tweets/counts/all', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    @validate_arguments
    def tweet_counts_recent_search(self, query : Annotated[constr(strict=True, max_length=4096, min_length=1), Field(..., description="One query/rule/filter for matching Tweets. Refer to https://t.co/rulelength to identify the max query length.")], start_time : Annotated[Optional[datetime], Field(description="YYYY-MM-DDTHH:mm:ssZ. The oldest UTC timestamp (from most recent 7 days) from which the Tweets will be provided. Timestamp is in second granularity and is inclusive (i.e. 12:00:01 includes the first second of the minute).")] = None, end_time : Annotated[Optional[datetime], Field(description="YYYY-MM-DDTHH:mm:ssZ. The newest, most recent UTC timestamp to which the Tweets will be provided. Timestamp is in second granularity and is exclusive (i.e. 12:00:01 excludes the first second of the minute).")] = None, since_id : Annotated[Optional[constr(strict=True, regex=r'/^[0-9]{1,19}$/')], Field(description="Returns results with a Tweet ID greater than (that is, more recent than) the specified ID.")] = None, until_id : Annotated[Optional[constr(strict=True, regex=r'/^[0-9]{1,19}$/')], Field(description="Returns results with a Tweet ID less than (that is, older than) the specified ID.")] = None, next_token : Annotated[Optional[constr(strict=True, min_length=1)], Field(description="This parameter is used to get the next 'page' of results. The value used with the parameter is pulled directly from the response provided by the API, and should not be modified.")] = None, pagination_token : Annotated[Optional[constr(strict=True, min_length=1)], Field(description="This parameter is used to get the next 'page' of results. The value used with the parameter is pulled directly from the response provided by the API, and should not be modified.")] = None, granularity : Annotated[Optional[StrictStr], Field(description="The granularity for the search counts results.")] = None, search_count_fields : Annotated[Optional[List[Literal['end', 'start', 'tweet_count']]], Field(description="A comma separated list of SearchCount fields to display.", unique_items=True)] = None, **kwargs) -> Get2TweetsCountsRecentResponse:  # noqa: E501
        """Recent search counts  # noqa: E501

        Returns Tweet Counts from the last 7 days that match a search query.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.tweet_counts_recent_search(query, start_time, end_time, since_id, until_id, next_token, pagination_token, granularity, search_count_fields, async_req=True)
        >>> result = thread.get()

        :param query: One query/rule/filter for matching Tweets. Refer to https://t.co/rulelength to identify the max query length. (required)
        :type query: str
        :param start_time: YYYY-MM-DDTHH:mm:ssZ. The oldest UTC timestamp (from most recent 7 days) from which the Tweets will be provided. Timestamp is in second granularity and is inclusive (i.e. 12:00:01 includes the first second of the minute).
        :type start_time: datetime
        :param end_time: YYYY-MM-DDTHH:mm:ssZ. The newest, most recent UTC timestamp to which the Tweets will be provided. Timestamp is in second granularity and is exclusive (i.e. 12:00:01 excludes the first second of the minute).
        :type end_time: datetime
        :param since_id: Returns results with a Tweet ID greater than (that is, more recent than) the specified ID.
        :type since_id: str
        :param until_id: Returns results with a Tweet ID less than (that is, older than) the specified ID.
        :type until_id: str
        :param next_token: This parameter is used to get the next 'page' of results. The value used with the parameter is pulled directly from the response provided by the API, and should not be modified.
        :type next_token: str
        :param pagination_token: This parameter is used to get the next 'page' of results. The value used with the parameter is pulled directly from the response provided by the API, and should not be modified.
        :type pagination_token: str
        :param granularity: The granularity for the search counts results.
        :type granularity: str
        :param search_count_fields: A comma separated list of SearchCount fields to display.
        :type search_count_fields: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: Get2TweetsCountsRecentResponse
        """
        kwargs['_return_http_data_only'] = True
        return self.tweet_counts_recent_search_with_http_info(query, start_time, end_time, since_id, until_id, next_token, pagination_token, granularity, search_count_fields, **kwargs)  # noqa: E501

    @validate_arguments
    def tweet_counts_recent_search_with_http_info(self, query : Annotated[constr(strict=True, max_length=4096, min_length=1), Field(..., description="One query/rule/filter for matching Tweets. Refer to https://t.co/rulelength to identify the max query length.")], start_time : Annotated[Optional[datetime], Field(description="YYYY-MM-DDTHH:mm:ssZ. The oldest UTC timestamp (from most recent 7 days) from which the Tweets will be provided. Timestamp is in second granularity and is inclusive (i.e. 12:00:01 includes the first second of the minute).")] = None, end_time : Annotated[Optional[datetime], Field(description="YYYY-MM-DDTHH:mm:ssZ. The newest, most recent UTC timestamp to which the Tweets will be provided. Timestamp is in second granularity and is exclusive (i.e. 12:00:01 excludes the first second of the minute).")] = None, since_id : Annotated[Optional[constr(strict=True, regex=r'/^[0-9]{1,19}$/')], Field(description="Returns results with a Tweet ID greater than (that is, more recent than) the specified ID.")] = None, until_id : Annotated[Optional[constr(strict=True, regex=r'/^[0-9]{1,19}$/')], Field(description="Returns results with a Tweet ID less than (that is, older than) the specified ID.")] = None, next_token : Annotated[Optional[constr(strict=True, min_length=1)], Field(description="This parameter is used to get the next 'page' of results. The value used with the parameter is pulled directly from the response provided by the API, and should not be modified.")] = None, pagination_token : Annotated[Optional[constr(strict=True, min_length=1)], Field(description="This parameter is used to get the next 'page' of results. The value used with the parameter is pulled directly from the response provided by the API, and should not be modified.")] = None, granularity : Annotated[Optional[StrictStr], Field(description="The granularity for the search counts results.")] = None, search_count_fields : Annotated[Optional[List[Literal['end', 'start', 'tweet_count']]], Field(description="A comma separated list of SearchCount fields to display.", unique_items=True)] = None, **kwargs):  # noqa: E501
        """Recent search counts  # noqa: E501

        Returns Tweet Counts from the last 7 days that match a search query.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.tweet_counts_recent_search_with_http_info(query, start_time, end_time, since_id, until_id, next_token, pagination_token, granularity, search_count_fields, async_req=True)
        >>> result = thread.get()

        :param query: One query/rule/filter for matching Tweets. Refer to https://t.co/rulelength to identify the max query length. (required)
        :type query: str
        :param start_time: YYYY-MM-DDTHH:mm:ssZ. The oldest UTC timestamp (from most recent 7 days) from which the Tweets will be provided. Timestamp is in second granularity and is inclusive (i.e. 12:00:01 includes the first second of the minute).
        :type start_time: datetime
        :param end_time: YYYY-MM-DDTHH:mm:ssZ. The newest, most recent UTC timestamp to which the Tweets will be provided. Timestamp is in second granularity and is exclusive (i.e. 12:00:01 excludes the first second of the minute).
        :type end_time: datetime
        :param since_id: Returns results with a Tweet ID greater than (that is, more recent than) the specified ID.
        :type since_id: str
        :param until_id: Returns results with a Tweet ID less than (that is, older than) the specified ID.
        :type until_id: str
        :param next_token: This parameter is used to get the next 'page' of results. The value used with the parameter is pulled directly from the response provided by the API, and should not be modified.
        :type next_token: str
        :param pagination_token: This parameter is used to get the next 'page' of results. The value used with the parameter is pulled directly from the response provided by the API, and should not be modified.
        :type pagination_token: str
        :param granularity: The granularity for the search counts results.
        :type granularity: str
        :param search_count_fields: A comma separated list of SearchCount fields to display.
        :type search_count_fields: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(Get2TweetsCountsRecentResponse, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'query',
            'start_time',
            'end_time',
            'since_id',
            'until_id',
            'next_token',
            'pagination_token',
            'granularity',
            'search_count_fields'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in local_var_params['kwargs'].items():
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method tweet_counts_recent_search" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if local_var_params.get('query') is not None:  # noqa: E501
            query_params.append(('query', local_var_params['query']))
        if local_var_params.get('start_time') is not None:  # noqa: E501
            query_params.append(('start_time', local_var_params['start_time']))
        if local_var_params.get('end_time') is not None:  # noqa: E501
            query_params.append(('end_time', local_var_params['end_time']))
        if local_var_params.get('since_id') is not None:  # noqa: E501
            query_params.append(('since_id', local_var_params['since_id']))
        if local_var_params.get('until_id') is not None:  # noqa: E501
            query_params.append(('until_id', local_var_params['until_id']))
        if local_var_params.get('next_token') is not None:  # noqa: E501
            query_params.append(('next_token', local_var_params['next_token']))
        if local_var_params.get('pagination_token') is not None:  # noqa: E501
            query_params.append(('pagination_token', local_var_params['pagination_token']))
        if local_var_params.get('granularity') is not None:  # noqa: E501
            query_params.append(('granularity', local_var_params['granularity']))
        if local_var_params.get('search_count_fields') is not None:  # noqa: E501
            query_params.append(('search_count.fields', local_var_params['search_count_fields']))
            collection_formats['search_count.fields'] = 'csv'

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'application/problem+json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BearerToken']  # noqa: E501

        response_types_map = {
            200: "Get2TweetsCountsRecentResponse",
        }

        return self.api_client.call_api(
            '/2/tweets/counts/recent', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    @validate_arguments
    def tweets_fullarchive_search(self, query : Annotated[constr(strict=True, max_length=4096, min_length=1), Field(..., description="One query/rule/filter for matching Tweets. Refer to https://t.co/rulelength to identify the max query length.")], start_time : Annotated[Optional[datetime], Field(description="YYYY-MM-DDTHH:mm:ssZ. The oldest UTC timestamp from which the Tweets will be provided. Timestamp is in second granularity and is inclusive (i.e. 12:00:01 includes the first second of the minute).")] = None, end_time : Annotated[Optional[datetime], Field(description="YYYY-MM-DDTHH:mm:ssZ. The newest, most recent UTC timestamp to which the Tweets will be provided. Timestamp is in second granularity and is exclusive (i.e. 12:00:01 excludes the first second of the minute).")] = None, since_id : Annotated[Optional[constr(strict=True, regex=r'/^[0-9]{1,19}$/')], Field(description="Returns results with a Tweet ID greater than (that is, more recent than) the specified ID.")] = None, until_id : Annotated[Optional[constr(strict=True, regex=r'/^[0-9]{1,19}$/')], Field(description="Returns results with a Tweet ID less than (that is, older than) the specified ID.")] = None, max_results : Annotated[Optional[conint(strict=True, ge=500, le=10)], Field(description="The maximum number of search results to be returned by a request.")] = None, next_token : Annotated[Optional[constr(strict=True, min_length=1)], Field(description="This parameter is used to get the next 'page' of results. The value used with the parameter is pulled directly from the response provided by the API, and should not be modified.")] = None, pagination_token : Annotated[Optional[constr(strict=True, min_length=1)], Field(description="This parameter is used to get the next 'page' of results. The value used with the parameter is pulled directly from the response provided by the API, and should not be modified.")] = None, sort_order : Annotated[Optional[StrictStr], Field(description="This order in which to return results.")] = None, tweet_fields : Annotated[Optional[List[Literal['attachments', 'author_id', 'context_annotations', 'conversation_id', 'created_at', 'entities', 'geo', 'id', 'in_reply_to_user_id', 'lang', 'non_public_metrics', 'organic_metrics', 'possibly_sensitive', 'promoted_metrics', 'public_metrics', 'referenced_tweets', 'reply_settings', 'source', 'text', 'withheld']]], Field(description="A comma separated list of Tweet fields to display.", unique_items=True)] = None, expansions : Annotated[Optional[List[Literal['attachments.media_keys', 'attachments.poll_ids', 'author_id', 'entities.mentions.username', 'geo.place_id', 'in_reply_to_user_id', 'referenced_tweets.id', 'referenced_tweets.id.author_id']]], Field(description="A comma separated list of fields to expand.", unique_items=True)] = None, media_fields : Annotated[Optional[List[Literal['alt_text', 'duration_ms', 'height', 'media_key', 'non_public_metrics', 'organic_metrics', 'preview_image_url', 'promoted_metrics', 'public_metrics', 'type', 'url', 'variants', 'width']]], Field(description="A comma separated list of Media fields to display.", unique_items=True)] = None, poll_fields : Annotated[Optional[List[Literal['duration_minutes', 'end_datetime', 'id', 'options', 'voting_status']]], Field(description="A comma separated list of Poll fields to display.", unique_items=True)] = None, user_fields : Annotated[Optional[List[Literal['created_at', 'description', 'entities', 'id', 'location', 'name', 'pinned_tweet_id', 'profile_image_url', 'protected', 'public_metrics', 'url', 'username', 'verified', 'withheld']]], Field(description="A comma separated list of User fields to display.", unique_items=True)] = None, place_fields : Annotated[Optional[List[Literal['contained_within', 'country', 'country_code', 'full_name', 'geo', 'id', 'name', 'place_type']]], Field(description="A comma separated list of Place fields to display.", unique_items=True)] = None, **kwargs) -> Get2TweetsSearchAllResponse:  # noqa: E501
        """Full-archive search  # noqa: E501

        Returns Tweets that match a search query.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.tweets_fullarchive_search(query, start_time, end_time, since_id, until_id, max_results, next_token, pagination_token, sort_order, tweet_fields, expansions, media_fields, poll_fields, user_fields, place_fields, async_req=True)
        >>> result = thread.get()

        :param query: One query/rule/filter for matching Tweets. Refer to https://t.co/rulelength to identify the max query length. (required)
        :type query: str
        :param start_time: YYYY-MM-DDTHH:mm:ssZ. The oldest UTC timestamp from which the Tweets will be provided. Timestamp is in second granularity and is inclusive (i.e. 12:00:01 includes the first second of the minute).
        :type start_time: datetime
        :param end_time: YYYY-MM-DDTHH:mm:ssZ. The newest, most recent UTC timestamp to which the Tweets will be provided. Timestamp is in second granularity and is exclusive (i.e. 12:00:01 excludes the first second of the minute).
        :type end_time: datetime
        :param since_id: Returns results with a Tweet ID greater than (that is, more recent than) the specified ID.
        :type since_id: str
        :param until_id: Returns results with a Tweet ID less than (that is, older than) the specified ID.
        :type until_id: str
        :param max_results: The maximum number of search results to be returned by a request.
        :type max_results: int
        :param next_token: This parameter is used to get the next 'page' of results. The value used with the parameter is pulled directly from the response provided by the API, and should not be modified.
        :type next_token: str
        :param pagination_token: This parameter is used to get the next 'page' of results. The value used with the parameter is pulled directly from the response provided by the API, and should not be modified.
        :type pagination_token: str
        :param sort_order: This order in which to return results.
        :type sort_order: str
        :param tweet_fields: A comma separated list of Tweet fields to display.
        :type tweet_fields: List[str]
        :param expansions: A comma separated list of fields to expand.
        :type expansions: List[str]
        :param media_fields: A comma separated list of Media fields to display.
        :type media_fields: List[str]
        :param poll_fields: A comma separated list of Poll fields to display.
        :type poll_fields: List[str]
        :param user_fields: A comma separated list of User fields to display.
        :type user_fields: List[str]
        :param place_fields: A comma separated list of Place fields to display.
        :type place_fields: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: Get2TweetsSearchAllResponse
        """
        kwargs['_return_http_data_only'] = True
        return self.tweets_fullarchive_search_with_http_info(query, start_time, end_time, since_id, until_id, max_results, next_token, pagination_token, sort_order, tweet_fields, expansions, media_fields, poll_fields, user_fields, place_fields, **kwargs)  # noqa: E501

    @validate_arguments
    def tweets_fullarchive_search_with_http_info(self, query : Annotated[constr(strict=True, max_length=4096, min_length=1), Field(..., description="One query/rule/filter for matching Tweets. Refer to https://t.co/rulelength to identify the max query length.")], start_time : Annotated[Optional[datetime], Field(description="YYYY-MM-DDTHH:mm:ssZ. The oldest UTC timestamp from which the Tweets will be provided. Timestamp is in second granularity and is inclusive (i.e. 12:00:01 includes the first second of the minute).")] = None, end_time : Annotated[Optional[datetime], Field(description="YYYY-MM-DDTHH:mm:ssZ. The newest, most recent UTC timestamp to which the Tweets will be provided. Timestamp is in second granularity and is exclusive (i.e. 12:00:01 excludes the first second of the minute).")] = None, since_id : Annotated[Optional[constr(strict=True, regex=r'/^[0-9]{1,19}$/')], Field(description="Returns results with a Tweet ID greater than (that is, more recent than) the specified ID.")] = None, until_id : Annotated[Optional[constr(strict=True, regex=r'/^[0-9]{1,19}$/')], Field(description="Returns results with a Tweet ID less than (that is, older than) the specified ID.")] = None, max_results : Annotated[Optional[conint(strict=True, ge=500, le=10)], Field(description="The maximum number of search results to be returned by a request.")] = None, next_token : Annotated[Optional[constr(strict=True, min_length=1)], Field(description="This parameter is used to get the next 'page' of results. The value used with the parameter is pulled directly from the response provided by the API, and should not be modified.")] = None, pagination_token : Annotated[Optional[constr(strict=True, min_length=1)], Field(description="This parameter is used to get the next 'page' of results. The value used with the parameter is pulled directly from the response provided by the API, and should not be modified.")] = None, sort_order : Annotated[Optional[StrictStr], Field(description="This order in which to return results.")] = None, tweet_fields : Annotated[Optional[List[Literal['attachments', 'author_id', 'context_annotations', 'conversation_id', 'created_at', 'entities', 'geo', 'id', 'in_reply_to_user_id', 'lang', 'non_public_metrics', 'organic_metrics', 'possibly_sensitive', 'promoted_metrics', 'public_metrics', 'referenced_tweets', 'reply_settings', 'source', 'text', 'withheld']]], Field(description="A comma separated list of Tweet fields to display.", unique_items=True)] = None, expansions : Annotated[Optional[List[Literal['attachments.media_keys', 'attachments.poll_ids', 'author_id', 'entities.mentions.username', 'geo.place_id', 'in_reply_to_user_id', 'referenced_tweets.id', 'referenced_tweets.id.author_id']]], Field(description="A comma separated list of fields to expand.", unique_items=True)] = None, media_fields : Annotated[Optional[List[Literal['alt_text', 'duration_ms', 'height', 'media_key', 'non_public_metrics', 'organic_metrics', 'preview_image_url', 'promoted_metrics', 'public_metrics', 'type', 'url', 'variants', 'width']]], Field(description="A comma separated list of Media fields to display.", unique_items=True)] = None, poll_fields : Annotated[Optional[List[Literal['duration_minutes', 'end_datetime', 'id', 'options', 'voting_status']]], Field(description="A comma separated list of Poll fields to display.", unique_items=True)] = None, user_fields : Annotated[Optional[List[Literal['created_at', 'description', 'entities', 'id', 'location', 'name', 'pinned_tweet_id', 'profile_image_url', 'protected', 'public_metrics', 'url', 'username', 'verified', 'withheld']]], Field(description="A comma separated list of User fields to display.", unique_items=True)] = None, place_fields : Annotated[Optional[List[Literal['contained_within', 'country', 'country_code', 'full_name', 'geo', 'id', 'name', 'place_type']]], Field(description="A comma separated list of Place fields to display.", unique_items=True)] = None, **kwargs):  # noqa: E501
        """Full-archive search  # noqa: E501

        Returns Tweets that match a search query.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.tweets_fullarchive_search_with_http_info(query, start_time, end_time, since_id, until_id, max_results, next_token, pagination_token, sort_order, tweet_fields, expansions, media_fields, poll_fields, user_fields, place_fields, async_req=True)
        >>> result = thread.get()

        :param query: One query/rule/filter for matching Tweets. Refer to https://t.co/rulelength to identify the max query length. (required)
        :type query: str
        :param start_time: YYYY-MM-DDTHH:mm:ssZ. The oldest UTC timestamp from which the Tweets will be provided. Timestamp is in second granularity and is inclusive (i.e. 12:00:01 includes the first second of the minute).
        :type start_time: datetime
        :param end_time: YYYY-MM-DDTHH:mm:ssZ. The newest, most recent UTC timestamp to which the Tweets will be provided. Timestamp is in second granularity and is exclusive (i.e. 12:00:01 excludes the first second of the minute).
        :type end_time: datetime
        :param since_id: Returns results with a Tweet ID greater than (that is, more recent than) the specified ID.
        :type since_id: str
        :param until_id: Returns results with a Tweet ID less than (that is, older than) the specified ID.
        :type until_id: str
        :param max_results: The maximum number of search results to be returned by a request.
        :type max_results: int
        :param next_token: This parameter is used to get the next 'page' of results. The value used with the parameter is pulled directly from the response provided by the API, and should not be modified.
        :type next_token: str
        :param pagination_token: This parameter is used to get the next 'page' of results. The value used with the parameter is pulled directly from the response provided by the API, and should not be modified.
        :type pagination_token: str
        :param sort_order: This order in which to return results.
        :type sort_order: str
        :param tweet_fields: A comma separated list of Tweet fields to display.
        :type tweet_fields: List[str]
        :param expansions: A comma separated list of fields to expand.
        :type expansions: List[str]
        :param media_fields: A comma separated list of Media fields to display.
        :type media_fields: List[str]
        :param poll_fields: A comma separated list of Poll fields to display.
        :type poll_fields: List[str]
        :param user_fields: A comma separated list of User fields to display.
        :type user_fields: List[str]
        :param place_fields: A comma separated list of Place fields to display.
        :type place_fields: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(Get2TweetsSearchAllResponse, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'query',
            'start_time',
            'end_time',
            'since_id',
            'until_id',
            'max_results',
            'next_token',
            'pagination_token',
            'sort_order',
            'tweet_fields',
            'expansions',
            'media_fields',
            'poll_fields',
            'user_fields',
            'place_fields'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in local_var_params['kwargs'].items():
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method tweets_fullarchive_search" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if local_var_params.get('query') is not None:  # noqa: E501
            query_params.append(('query', local_var_params['query']))
        if local_var_params.get('start_time') is not None:  # noqa: E501
            query_params.append(('start_time', local_var_params['start_time']))
        if local_var_params.get('end_time') is not None:  # noqa: E501
            query_params.append(('end_time', local_var_params['end_time']))
        if local_var_params.get('since_id') is not None:  # noqa: E501
            query_params.append(('since_id', local_var_params['since_id']))
        if local_var_params.get('until_id') is not None:  # noqa: E501
            query_params.append(('until_id', local_var_params['until_id']))
        if local_var_params.get('max_results') is not None:  # noqa: E501
            query_params.append(('max_results', local_var_params['max_results']))
        if local_var_params.get('next_token') is not None:  # noqa: E501
            query_params.append(('next_token', local_var_params['next_token']))
        if local_var_params.get('pagination_token') is not None:  # noqa: E501
            query_params.append(('pagination_token', local_var_params['pagination_token']))
        if local_var_params.get('sort_order') is not None:  # noqa: E501
            query_params.append(('sort_order', local_var_params['sort_order']))
        if local_var_params.get('tweet_fields') is not None:  # noqa: E501
            query_params.append(('tweet.fields', local_var_params['tweet_fields']))
            collection_formats['tweet.fields'] = 'csv'
        if local_var_params.get('expansions') is not None:  # noqa: E501
            query_params.append(('expansions', local_var_params['expansions']))
            collection_formats['expansions'] = 'csv'
        if local_var_params.get('media_fields') is not None:  # noqa: E501
            query_params.append(('media.fields', local_var_params['media_fields']))
            collection_formats['media.fields'] = 'csv'
        if local_var_params.get('poll_fields') is not None:  # noqa: E501
            query_params.append(('poll.fields', local_var_params['poll_fields']))
            collection_formats['poll.fields'] = 'csv'
        if local_var_params.get('user_fields') is not None:  # noqa: E501
            query_params.append(('user.fields', local_var_params['user_fields']))
            collection_formats['user.fields'] = 'csv'
        if local_var_params.get('place_fields') is not None:  # noqa: E501
            query_params.append(('place.fields', local_var_params['place_fields']))
            collection_formats['place.fields'] = 'csv'

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'application/problem+json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BearerToken']  # noqa: E501

        response_types_map = {
            200: "Get2TweetsSearchAllResponse",
        }

        return self.api_client.call_api(
            '/2/tweets/search/all', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    @validate_arguments
    def tweets_recent_search(self, query : Annotated[constr(strict=True, max_length=4096, min_length=1), Field(..., description="One query/rule/filter for matching Tweets. Refer to https://t.co/rulelength to identify the max query length.")], start_time : Annotated[Optional[datetime], Field(description="YYYY-MM-DDTHH:mm:ssZ. The oldest UTC timestamp from which the Tweets will be provided. Timestamp is in second granularity and is inclusive (i.e. 12:00:01 includes the first second of the minute).")] = None, end_time : Annotated[Optional[datetime], Field(description="YYYY-MM-DDTHH:mm:ssZ. The newest, most recent UTC timestamp to which the Tweets will be provided. Timestamp is in second granularity and is exclusive (i.e. 12:00:01 excludes the first second of the minute).")] = None, since_id : Annotated[Optional[constr(strict=True, regex=r'/^[0-9]{1,19}$/')], Field(description="Returns results with a Tweet ID greater than (that is, more recent than) the specified ID.")] = None, until_id : Annotated[Optional[constr(strict=True, regex=r'/^[0-9]{1,19}$/')], Field(description="Returns results with a Tweet ID less than (that is, older than) the specified ID.")] = None, max_results : Annotated[Optional[conint(strict=True, ge=100, le=10)], Field(description="The maximum number of search results to be returned by a request.")] = None, next_token : Annotated[Optional[constr(strict=True, min_length=1)], Field(description="This parameter is used to get the next 'page' of results. The value used with the parameter is pulled directly from the response provided by the API, and should not be modified.")] = None, pagination_token : Annotated[Optional[constr(strict=True, min_length=1)], Field(description="This parameter is used to get the next 'page' of results. The value used with the parameter is pulled directly from the response provided by the API, and should not be modified.")] = None, sort_order : Annotated[Optional[StrictStr], Field(description="This order in which to return results.")] = None, tweet_fields : Annotated[Optional[List[Literal['attachments', 'author_id', 'context_annotations', 'conversation_id', 'created_at', 'entities', 'geo', 'id', 'in_reply_to_user_id', 'lang', 'non_public_metrics', 'organic_metrics', 'possibly_sensitive', 'promoted_metrics', 'public_metrics', 'referenced_tweets', 'reply_settings', 'source', 'text', 'withheld']]], Field(description="A comma separated list of Tweet fields to display.", unique_items=True)] = None, expansions : Annotated[Optional[List[Literal['attachments.media_keys', 'attachments.poll_ids', 'author_id', 'entities.mentions.username', 'geo.place_id', 'in_reply_to_user_id', 'referenced_tweets.id', 'referenced_tweets.id.author_id']]], Field(description="A comma separated list of fields to expand.", unique_items=True)] = None, media_fields : Annotated[Optional[List[Literal['alt_text', 'duration_ms', 'height', 'media_key', 'non_public_metrics', 'organic_metrics', 'preview_image_url', 'promoted_metrics', 'public_metrics', 'type', 'url', 'variants', 'width']]], Field(description="A comma separated list of Media fields to display.", unique_items=True)] = None, poll_fields : Annotated[Optional[List[Literal['duration_minutes', 'end_datetime', 'id', 'options', 'voting_status']]], Field(description="A comma separated list of Poll fields to display.", unique_items=True)] = None, user_fields : Annotated[Optional[List[Literal['created_at', 'description', 'entities', 'id', 'location', 'name', 'pinned_tweet_id', 'profile_image_url', 'protected', 'public_metrics', 'url', 'username', 'verified', 'withheld']]], Field(description="A comma separated list of User fields to display.", unique_items=True)] = None, place_fields : Annotated[Optional[List[Literal['contained_within', 'country', 'country_code', 'full_name', 'geo', 'id', 'name', 'place_type']]], Field(description="A comma separated list of Place fields to display.", unique_items=True)] = None, **kwargs) -> Get2TweetsSearchRecentResponse:  # noqa: E501
        """Recent search  # noqa: E501

        Returns Tweets from the last 7 days that match a search query.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.tweets_recent_search(query, start_time, end_time, since_id, until_id, max_results, next_token, pagination_token, sort_order, tweet_fields, expansions, media_fields, poll_fields, user_fields, place_fields, async_req=True)
        >>> result = thread.get()

        :param query: One query/rule/filter for matching Tweets. Refer to https://t.co/rulelength to identify the max query length. (required)
        :type query: str
        :param start_time: YYYY-MM-DDTHH:mm:ssZ. The oldest UTC timestamp from which the Tweets will be provided. Timestamp is in second granularity and is inclusive (i.e. 12:00:01 includes the first second of the minute).
        :type start_time: datetime
        :param end_time: YYYY-MM-DDTHH:mm:ssZ. The newest, most recent UTC timestamp to which the Tweets will be provided. Timestamp is in second granularity and is exclusive (i.e. 12:00:01 excludes the first second of the minute).
        :type end_time: datetime
        :param since_id: Returns results with a Tweet ID greater than (that is, more recent than) the specified ID.
        :type since_id: str
        :param until_id: Returns results with a Tweet ID less than (that is, older than) the specified ID.
        :type until_id: str
        :param max_results: The maximum number of search results to be returned by a request.
        :type max_results: int
        :param next_token: This parameter is used to get the next 'page' of results. The value used with the parameter is pulled directly from the response provided by the API, and should not be modified.
        :type next_token: str
        :param pagination_token: This parameter is used to get the next 'page' of results. The value used with the parameter is pulled directly from the response provided by the API, and should not be modified.
        :type pagination_token: str
        :param sort_order: This order in which to return results.
        :type sort_order: str
        :param tweet_fields: A comma separated list of Tweet fields to display.
        :type tweet_fields: List[str]
        :param expansions: A comma separated list of fields to expand.
        :type expansions: List[str]
        :param media_fields: A comma separated list of Media fields to display.
        :type media_fields: List[str]
        :param poll_fields: A comma separated list of Poll fields to display.
        :type poll_fields: List[str]
        :param user_fields: A comma separated list of User fields to display.
        :type user_fields: List[str]
        :param place_fields: A comma separated list of Place fields to display.
        :type place_fields: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: Get2TweetsSearchRecentResponse
        """
        kwargs['_return_http_data_only'] = True
        return self.tweets_recent_search_with_http_info(query, start_time, end_time, since_id, until_id, max_results, next_token, pagination_token, sort_order, tweet_fields, expansions, media_fields, poll_fields, user_fields, place_fields, **kwargs)  # noqa: E501

    @validate_arguments
    def tweets_recent_search_with_http_info(self, query : Annotated[constr(strict=True, max_length=4096, min_length=1), Field(..., description="One query/rule/filter for matching Tweets. Refer to https://t.co/rulelength to identify the max query length.")], start_time : Annotated[Optional[datetime], Field(description="YYYY-MM-DDTHH:mm:ssZ. The oldest UTC timestamp from which the Tweets will be provided. Timestamp is in second granularity and is inclusive (i.e. 12:00:01 includes the first second of the minute).")] = None, end_time : Annotated[Optional[datetime], Field(description="YYYY-MM-DDTHH:mm:ssZ. The newest, most recent UTC timestamp to which the Tweets will be provided. Timestamp is in second granularity and is exclusive (i.e. 12:00:01 excludes the first second of the minute).")] = None, since_id : Annotated[Optional[constr(strict=True, regex=r'/^[0-9]{1,19}$/')], Field(description="Returns results with a Tweet ID greater than (that is, more recent than) the specified ID.")] = None, until_id : Annotated[Optional[constr(strict=True, regex=r'/^[0-9]{1,19}$/')], Field(description="Returns results with a Tweet ID less than (that is, older than) the specified ID.")] = None, max_results : Annotated[Optional[conint(strict=True, ge=100, le=10)], Field(description="The maximum number of search results to be returned by a request.")] = None, next_token : Annotated[Optional[constr(strict=True, min_length=1)], Field(description="This parameter is used to get the next 'page' of results. The value used with the parameter is pulled directly from the response provided by the API, and should not be modified.")] = None, pagination_token : Annotated[Optional[constr(strict=True, min_length=1)], Field(description="This parameter is used to get the next 'page' of results. The value used with the parameter is pulled directly from the response provided by the API, and should not be modified.")] = None, sort_order : Annotated[Optional[StrictStr], Field(description="This order in which to return results.")] = None, tweet_fields : Annotated[Optional[List[Literal['attachments', 'author_id', 'context_annotations', 'conversation_id', 'created_at', 'entities', 'geo', 'id', 'in_reply_to_user_id', 'lang', 'non_public_metrics', 'organic_metrics', 'possibly_sensitive', 'promoted_metrics', 'public_metrics', 'referenced_tweets', 'reply_settings', 'source', 'text', 'withheld']]], Field(description="A comma separated list of Tweet fields to display.", unique_items=True)] = None, expansions : Annotated[Optional[List[Literal['attachments.media_keys', 'attachments.poll_ids', 'author_id', 'entities.mentions.username', 'geo.place_id', 'in_reply_to_user_id', 'referenced_tweets.id', 'referenced_tweets.id.author_id']]], Field(description="A comma separated list of fields to expand.", unique_items=True)] = None, media_fields : Annotated[Optional[List[Literal['alt_text', 'duration_ms', 'height', 'media_key', 'non_public_metrics', 'organic_metrics', 'preview_image_url', 'promoted_metrics', 'public_metrics', 'type', 'url', 'variants', 'width']]], Field(description="A comma separated list of Media fields to display.", unique_items=True)] = None, poll_fields : Annotated[Optional[List[Literal['duration_minutes', 'end_datetime', 'id', 'options', 'voting_status']]], Field(description="A comma separated list of Poll fields to display.", unique_items=True)] = None, user_fields : Annotated[Optional[List[Literal['created_at', 'description', 'entities', 'id', 'location', 'name', 'pinned_tweet_id', 'profile_image_url', 'protected', 'public_metrics', 'url', 'username', 'verified', 'withheld']]], Field(description="A comma separated list of User fields to display.", unique_items=True)] = None, place_fields : Annotated[Optional[List[Literal['contained_within', 'country', 'country_code', 'full_name', 'geo', 'id', 'name', 'place_type']]], Field(description="A comma separated list of Place fields to display.", unique_items=True)] = None, **kwargs):  # noqa: E501
        """Recent search  # noqa: E501

        Returns Tweets from the last 7 days that match a search query.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.tweets_recent_search_with_http_info(query, start_time, end_time, since_id, until_id, max_results, next_token, pagination_token, sort_order, tweet_fields, expansions, media_fields, poll_fields, user_fields, place_fields, async_req=True)
        >>> result = thread.get()

        :param query: One query/rule/filter for matching Tweets. Refer to https://t.co/rulelength to identify the max query length. (required)
        :type query: str
        :param start_time: YYYY-MM-DDTHH:mm:ssZ. The oldest UTC timestamp from which the Tweets will be provided. Timestamp is in second granularity and is inclusive (i.e. 12:00:01 includes the first second of the minute).
        :type start_time: datetime
        :param end_time: YYYY-MM-DDTHH:mm:ssZ. The newest, most recent UTC timestamp to which the Tweets will be provided. Timestamp is in second granularity and is exclusive (i.e. 12:00:01 excludes the first second of the minute).
        :type end_time: datetime
        :param since_id: Returns results with a Tweet ID greater than (that is, more recent than) the specified ID.
        :type since_id: str
        :param until_id: Returns results with a Tweet ID less than (that is, older than) the specified ID.
        :type until_id: str
        :param max_results: The maximum number of search results to be returned by a request.
        :type max_results: int
        :param next_token: This parameter is used to get the next 'page' of results. The value used with the parameter is pulled directly from the response provided by the API, and should not be modified.
        :type next_token: str
        :param pagination_token: This parameter is used to get the next 'page' of results. The value used with the parameter is pulled directly from the response provided by the API, and should not be modified.
        :type pagination_token: str
        :param sort_order: This order in which to return results.
        :type sort_order: str
        :param tweet_fields: A comma separated list of Tweet fields to display.
        :type tweet_fields: List[str]
        :param expansions: A comma separated list of fields to expand.
        :type expansions: List[str]
        :param media_fields: A comma separated list of Media fields to display.
        :type media_fields: List[str]
        :param poll_fields: A comma separated list of Poll fields to display.
        :type poll_fields: List[str]
        :param user_fields: A comma separated list of User fields to display.
        :type user_fields: List[str]
        :param place_fields: A comma separated list of Place fields to display.
        :type place_fields: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(Get2TweetsSearchRecentResponse, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'query',
            'start_time',
            'end_time',
            'since_id',
            'until_id',
            'max_results',
            'next_token',
            'pagination_token',
            'sort_order',
            'tweet_fields',
            'expansions',
            'media_fields',
            'poll_fields',
            'user_fields',
            'place_fields'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in local_var_params['kwargs'].items():
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method tweets_recent_search" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if local_var_params.get('query') is not None:  # noqa: E501
            query_params.append(('query', local_var_params['query']))
        if local_var_params.get('start_time') is not None:  # noqa: E501
            query_params.append(('start_time', local_var_params['start_time']))
        if local_var_params.get('end_time') is not None:  # noqa: E501
            query_params.append(('end_time', local_var_params['end_time']))
        if local_var_params.get('since_id') is not None:  # noqa: E501
            query_params.append(('since_id', local_var_params['since_id']))
        if local_var_params.get('until_id') is not None:  # noqa: E501
            query_params.append(('until_id', local_var_params['until_id']))
        if local_var_params.get('max_results') is not None:  # noqa: E501
            query_params.append(('max_results', local_var_params['max_results']))
        if local_var_params.get('next_token') is not None:  # noqa: E501
            query_params.append(('next_token', local_var_params['next_token']))
        if local_var_params.get('pagination_token') is not None:  # noqa: E501
            query_params.append(('pagination_token', local_var_params['pagination_token']))
        if local_var_params.get('sort_order') is not None:  # noqa: E501
            query_params.append(('sort_order', local_var_params['sort_order']))
        if local_var_params.get('tweet_fields') is not None:  # noqa: E501
            query_params.append(('tweet.fields', local_var_params['tweet_fields']))
            collection_formats['tweet.fields'] = 'csv'
        if local_var_params.get('expansions') is not None:  # noqa: E501
            query_params.append(('expansions', local_var_params['expansions']))
            collection_formats['expansions'] = 'csv'
        if local_var_params.get('media_fields') is not None:  # noqa: E501
            query_params.append(('media.fields', local_var_params['media_fields']))
            collection_formats['media.fields'] = 'csv'
        if local_var_params.get('poll_fields') is not None:  # noqa: E501
            query_params.append(('poll.fields', local_var_params['poll_fields']))
            collection_formats['poll.fields'] = 'csv'
        if local_var_params.get('user_fields') is not None:  # noqa: E501
            query_params.append(('user.fields', local_var_params['user_fields']))
            collection_formats['user.fields'] = 'csv'
        if local_var_params.get('place_fields') is not None:  # noqa: E501
            query_params.append(('place.fields', local_var_params['place_fields']))
            collection_formats['place.fields'] = 'csv'

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'application/problem+json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BearerToken', 'OAuth2UserToken', 'UserToken']  # noqa: E501

        response_types_map = {
            200: "Get2TweetsSearchRecentResponse",
        }

        return self.api_client.call_api(
            '/2/tweets/search/recent', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    @validate_arguments
    def users_id_like(self, id : Annotated[StrictStr, Field(..., description="The ID of the authenticated source User that is requesting to like the Tweet.")], users_likes_create_request : Optional[UsersLikesCreateRequest] = None, **kwargs) -> UsersLikesCreateResponse:  # noqa: E501
        """Causes the User (in the path) to like the specified Tweet  # noqa: E501

        Causes the User (in the path) to like the specified Tweet. The User in the path must match the User context authorizing the request.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.users_id_like(id, users_likes_create_request, async_req=True)
        >>> result = thread.get()

        :param id: The ID of the authenticated source User that is requesting to like the Tweet. (required)
        :type id: str
        :param users_likes_create_request:
        :type users_likes_create_request: UsersLikesCreateRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: UsersLikesCreateResponse
        """
        kwargs['_return_http_data_only'] = True
        return self.users_id_like_with_http_info(id, users_likes_create_request, **kwargs)  # noqa: E501

    @validate_arguments
    def users_id_like_with_http_info(self, id : Annotated[StrictStr, Field(..., description="The ID of the authenticated source User that is requesting to like the Tweet.")], users_likes_create_request : Optional[UsersLikesCreateRequest] = None, **kwargs):  # noqa: E501
        """Causes the User (in the path) to like the specified Tweet  # noqa: E501

        Causes the User (in the path) to like the specified Tweet. The User in the path must match the User context authorizing the request.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.users_id_like_with_http_info(id, users_likes_create_request, async_req=True)
        >>> result = thread.get()

        :param id: The ID of the authenticated source User that is requesting to like the Tweet. (required)
        :type id: str
        :param users_likes_create_request:
        :type users_likes_create_request: UsersLikesCreateRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(UsersLikesCreateResponse, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'id',
            'users_likes_create_request'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in local_var_params['kwargs'].items():
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method users_id_like" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        collection_formats = {}

        path_params = {}
        if local_var_params['id']:
            path_params['id'] = local_var_params['id']

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        if local_var_params['users_likes_create_request']:
            body_params = local_var_params['users_likes_create_request']

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'application/problem+json'])  # noqa: E501

        # HTTP header `Content-Type`
        content_types_list = local_var_params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if content_types_list:
                header_params['Content-Type'] = content_types_list

        # Authentication setting
        auth_settings = ['OAuth2UserToken', 'UserToken']  # noqa: E501

        response_types_map = {
            200: "UsersLikesCreateResponse",
        }

        return self.api_client.call_api(
            '/2/users/{id}/likes', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    @validate_arguments
    def users_id_liked_tweets(self, id : Annotated[constr(strict=True, regex=r'/^[0-9]{1,19}$/'), Field(..., description="The ID of the User to lookup.")], max_results : Annotated[Optional[conint(strict=True, ge=100, le=5)], Field(description="The maximum number of results.")] = None, pagination_token : Annotated[Optional[constr(strict=True, min_length=1)], Field(description="This parameter is used to get the next 'page' of results.")] = None, tweet_fields : Annotated[Optional[List[Literal['attachments', 'author_id', 'context_annotations', 'conversation_id', 'created_at', 'entities', 'geo', 'id', 'in_reply_to_user_id', 'lang', 'non_public_metrics', 'organic_metrics', 'possibly_sensitive', 'promoted_metrics', 'public_metrics', 'referenced_tweets', 'reply_settings', 'source', 'text', 'withheld']]], Field(description="A comma separated list of Tweet fields to display.", unique_items=True)] = None, expansions : Annotated[Optional[List[Literal['attachments.media_keys', 'attachments.poll_ids', 'author_id', 'entities.mentions.username', 'geo.place_id', 'in_reply_to_user_id', 'referenced_tweets.id', 'referenced_tweets.id.author_id']]], Field(description="A comma separated list of fields to expand.", unique_items=True)] = None, media_fields : Annotated[Optional[List[Literal['alt_text', 'duration_ms', 'height', 'media_key', 'non_public_metrics', 'organic_metrics', 'preview_image_url', 'promoted_metrics', 'public_metrics', 'type', 'url', 'variants', 'width']]], Field(description="A comma separated list of Media fields to display.", unique_items=True)] = None, poll_fields : Annotated[Optional[List[Literal['duration_minutes', 'end_datetime', 'id', 'options', 'voting_status']]], Field(description="A comma separated list of Poll fields to display.", unique_items=True)] = None, user_fields : Annotated[Optional[List[Literal['created_at', 'description', 'entities', 'id', 'location', 'name', 'pinned_tweet_id', 'profile_image_url', 'protected', 'public_metrics', 'url', 'username', 'verified', 'withheld']]], Field(description="A comma separated list of User fields to display.", unique_items=True)] = None, place_fields : Annotated[Optional[List[Literal['contained_within', 'country', 'country_code', 'full_name', 'geo', 'id', 'name', 'place_type']]], Field(description="A comma separated list of Place fields to display.", unique_items=True)] = None, **kwargs) -> Get2UsersIdLikedTweetsResponse:  # noqa: E501
        """Returns Tweet objects liked by the provided User ID  # noqa: E501

        Returns a list of Tweets liked by the provided User ID  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.users_id_liked_tweets(id, max_results, pagination_token, tweet_fields, expansions, media_fields, poll_fields, user_fields, place_fields, async_req=True)
        >>> result = thread.get()

        :param id: The ID of the User to lookup. (required)
        :type id: str
        :param max_results: The maximum number of results.
        :type max_results: int
        :param pagination_token: This parameter is used to get the next 'page' of results.
        :type pagination_token: str
        :param tweet_fields: A comma separated list of Tweet fields to display.
        :type tweet_fields: List[str]
        :param expansions: A comma separated list of fields to expand.
        :type expansions: List[str]
        :param media_fields: A comma separated list of Media fields to display.
        :type media_fields: List[str]
        :param poll_fields: A comma separated list of Poll fields to display.
        :type poll_fields: List[str]
        :param user_fields: A comma separated list of User fields to display.
        :type user_fields: List[str]
        :param place_fields: A comma separated list of Place fields to display.
        :type place_fields: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: Get2UsersIdLikedTweetsResponse
        """
        kwargs['_return_http_data_only'] = True
        return self.users_id_liked_tweets_with_http_info(id, max_results, pagination_token, tweet_fields, expansions, media_fields, poll_fields, user_fields, place_fields, **kwargs)  # noqa: E501

    @validate_arguments
    def users_id_liked_tweets_with_http_info(self, id : Annotated[constr(strict=True, regex=r'/^[0-9]{1,19}$/'), Field(..., description="The ID of the User to lookup.")], max_results : Annotated[Optional[conint(strict=True, ge=100, le=5)], Field(description="The maximum number of results.")] = None, pagination_token : Annotated[Optional[constr(strict=True, min_length=1)], Field(description="This parameter is used to get the next 'page' of results.")] = None, tweet_fields : Annotated[Optional[List[Literal['attachments', 'author_id', 'context_annotations', 'conversation_id', 'created_at', 'entities', 'geo', 'id', 'in_reply_to_user_id', 'lang', 'non_public_metrics', 'organic_metrics', 'possibly_sensitive', 'promoted_metrics', 'public_metrics', 'referenced_tweets', 'reply_settings', 'source', 'text', 'withheld']]], Field(description="A comma separated list of Tweet fields to display.", unique_items=True)] = None, expansions : Annotated[Optional[List[Literal['attachments.media_keys', 'attachments.poll_ids', 'author_id', 'entities.mentions.username', 'geo.place_id', 'in_reply_to_user_id', 'referenced_tweets.id', 'referenced_tweets.id.author_id']]], Field(description="A comma separated list of fields to expand.", unique_items=True)] = None, media_fields : Annotated[Optional[List[Literal['alt_text', 'duration_ms', 'height', 'media_key', 'non_public_metrics', 'organic_metrics', 'preview_image_url', 'promoted_metrics', 'public_metrics', 'type', 'url', 'variants', 'width']]], Field(description="A comma separated list of Media fields to display.", unique_items=True)] = None, poll_fields : Annotated[Optional[List[Literal['duration_minutes', 'end_datetime', 'id', 'options', 'voting_status']]], Field(description="A comma separated list of Poll fields to display.", unique_items=True)] = None, user_fields : Annotated[Optional[List[Literal['created_at', 'description', 'entities', 'id', 'location', 'name', 'pinned_tweet_id', 'profile_image_url', 'protected', 'public_metrics', 'url', 'username', 'verified', 'withheld']]], Field(description="A comma separated list of User fields to display.", unique_items=True)] = None, place_fields : Annotated[Optional[List[Literal['contained_within', 'country', 'country_code', 'full_name', 'geo', 'id', 'name', 'place_type']]], Field(description="A comma separated list of Place fields to display.", unique_items=True)] = None, **kwargs):  # noqa: E501
        """Returns Tweet objects liked by the provided User ID  # noqa: E501

        Returns a list of Tweets liked by the provided User ID  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.users_id_liked_tweets_with_http_info(id, max_results, pagination_token, tweet_fields, expansions, media_fields, poll_fields, user_fields, place_fields, async_req=True)
        >>> result = thread.get()

        :param id: The ID of the User to lookup. (required)
        :type id: str
        :param max_results: The maximum number of results.
        :type max_results: int
        :param pagination_token: This parameter is used to get the next 'page' of results.
        :type pagination_token: str
        :param tweet_fields: A comma separated list of Tweet fields to display.
        :type tweet_fields: List[str]
        :param expansions: A comma separated list of fields to expand.
        :type expansions: List[str]
        :param media_fields: A comma separated list of Media fields to display.
        :type media_fields: List[str]
        :param poll_fields: A comma separated list of Poll fields to display.
        :type poll_fields: List[str]
        :param user_fields: A comma separated list of User fields to display.
        :type user_fields: List[str]
        :param place_fields: A comma separated list of Place fields to display.
        :type place_fields: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(Get2UsersIdLikedTweetsResponse, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'id',
            'max_results',
            'pagination_token',
            'tweet_fields',
            'expansions',
            'media_fields',
            'poll_fields',
            'user_fields',
            'place_fields'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in local_var_params['kwargs'].items():
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method users_id_liked_tweets" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        collection_formats = {}

        path_params = {}
        if local_var_params['id']:
            path_params['id'] = local_var_params['id']

        query_params = []
        if local_var_params.get('max_results') is not None:  # noqa: E501
            query_params.append(('max_results', local_var_params['max_results']))
        if local_var_params.get('pagination_token') is not None:  # noqa: E501
            query_params.append(('pagination_token', local_var_params['pagination_token']))
        if local_var_params.get('tweet_fields') is not None:  # noqa: E501
            query_params.append(('tweet.fields', local_var_params['tweet_fields']))
            collection_formats['tweet.fields'] = 'csv'
        if local_var_params.get('expansions') is not None:  # noqa: E501
            query_params.append(('expansions', local_var_params['expansions']))
            collection_formats['expansions'] = 'csv'
        if local_var_params.get('media_fields') is not None:  # noqa: E501
            query_params.append(('media.fields', local_var_params['media_fields']))
            collection_formats['media.fields'] = 'csv'
        if local_var_params.get('poll_fields') is not None:  # noqa: E501
            query_params.append(('poll.fields', local_var_params['poll_fields']))
            collection_formats['poll.fields'] = 'csv'
        if local_var_params.get('user_fields') is not None:  # noqa: E501
            query_params.append(('user.fields', local_var_params['user_fields']))
            collection_formats['user.fields'] = 'csv'
        if local_var_params.get('place_fields') is not None:  # noqa: E501
            query_params.append(('place.fields', local_var_params['place_fields']))
            collection_formats['place.fields'] = 'csv'

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'application/problem+json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BearerToken', 'OAuth2UserToken', 'UserToken']  # noqa: E501

        response_types_map = {
            200: "Get2UsersIdLikedTweetsResponse",
        }

        return self.api_client.call_api(
            '/2/users/{id}/liked_tweets', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    @validate_arguments
    def users_id_mentions(self, id : Annotated[constr(strict=True, regex=r'/^[0-9]{1,19}$/'), Field(..., description="The ID of the User to lookup.")], since_id : Annotated[Optional[constr(strict=True, regex=r'/^[0-9]{1,19}$/')], Field(description="The minimum Tweet ID to be included in the result set. This parameter takes precedence over start_time if both are specified.")] = None, until_id : Annotated[Optional[constr(strict=True, regex=r'/^[0-9]{1,19}$/')], Field(description="The maximum Tweet ID to be included in the result set. This parameter takes precedence over end_time if both are specified.")] = None, max_results : Annotated[Optional[conint(strict=True, ge=100, le=5)], Field(description="The maximum number of results.")] = None, pagination_token : Annotated[Optional[constr(strict=True, min_length=1)], Field(description="This parameter is used to get the next 'page' of results.")] = None, start_time : Annotated[Optional[datetime], Field(description="YYYY-MM-DDTHH:mm:ssZ. The earliest UTC timestamp from which the Tweets will be provided. The since_id parameter takes precedence if it is also specified.")] = None, end_time : Annotated[Optional[datetime], Field(description="YYYY-MM-DDTHH:mm:ssZ. The latest UTC timestamp to which the Tweets will be provided. The until_id parameter takes precedence if it is also specified.")] = None, tweet_fields : Annotated[Optional[List[Literal['attachments', 'author_id', 'context_annotations', 'conversation_id', 'created_at', 'entities', 'geo', 'id', 'in_reply_to_user_id', 'lang', 'non_public_metrics', 'organic_metrics', 'possibly_sensitive', 'promoted_metrics', 'public_metrics', 'referenced_tweets', 'reply_settings', 'source', 'text', 'withheld']]], Field(description="A comma separated list of Tweet fields to display.", unique_items=True)] = None, expansions : Annotated[Optional[List[Literal['attachments.media_keys', 'attachments.poll_ids', 'author_id', 'entities.mentions.username', 'geo.place_id', 'in_reply_to_user_id', 'referenced_tweets.id', 'referenced_tweets.id.author_id']]], Field(description="A comma separated list of fields to expand.", unique_items=True)] = None, media_fields : Annotated[Optional[List[Literal['alt_text', 'duration_ms', 'height', 'media_key', 'non_public_metrics', 'organic_metrics', 'preview_image_url', 'promoted_metrics', 'public_metrics', 'type', 'url', 'variants', 'width']]], Field(description="A comma separated list of Media fields to display.", unique_items=True)] = None, poll_fields : Annotated[Optional[List[Literal['duration_minutes', 'end_datetime', 'id', 'options', 'voting_status']]], Field(description="A comma separated list of Poll fields to display.", unique_items=True)] = None, user_fields : Annotated[Optional[List[Literal['created_at', 'description', 'entities', 'id', 'location', 'name', 'pinned_tweet_id', 'profile_image_url', 'protected', 'public_metrics', 'url', 'username', 'verified', 'withheld']]], Field(description="A comma separated list of User fields to display.", unique_items=True)] = None, place_fields : Annotated[Optional[List[Literal['contained_within', 'country', 'country_code', 'full_name', 'geo', 'id', 'name', 'place_type']]], Field(description="A comma separated list of Place fields to display.", unique_items=True)] = None, **kwargs) -> Get2UsersIdMentionsResponse:  # noqa: E501
        """User mention timeline by User ID  # noqa: E501

        Returns Tweet objects that mention username associated to the provided User ID  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.users_id_mentions(id, since_id, until_id, max_results, pagination_token, start_time, end_time, tweet_fields, expansions, media_fields, poll_fields, user_fields, place_fields, async_req=True)
        >>> result = thread.get()

        :param id: The ID of the User to lookup. (required)
        :type id: str
        :param since_id: The minimum Tweet ID to be included in the result set. This parameter takes precedence over start_time if both are specified.
        :type since_id: str
        :param until_id: The maximum Tweet ID to be included in the result set. This parameter takes precedence over end_time if both are specified.
        :type until_id: str
        :param max_results: The maximum number of results.
        :type max_results: int
        :param pagination_token: This parameter is used to get the next 'page' of results.
        :type pagination_token: str
        :param start_time: YYYY-MM-DDTHH:mm:ssZ. The earliest UTC timestamp from which the Tweets will be provided. The since_id parameter takes precedence if it is also specified.
        :type start_time: datetime
        :param end_time: YYYY-MM-DDTHH:mm:ssZ. The latest UTC timestamp to which the Tweets will be provided. The until_id parameter takes precedence if it is also specified.
        :type end_time: datetime
        :param tweet_fields: A comma separated list of Tweet fields to display.
        :type tweet_fields: List[str]
        :param expansions: A comma separated list of fields to expand.
        :type expansions: List[str]
        :param media_fields: A comma separated list of Media fields to display.
        :type media_fields: List[str]
        :param poll_fields: A comma separated list of Poll fields to display.
        :type poll_fields: List[str]
        :param user_fields: A comma separated list of User fields to display.
        :type user_fields: List[str]
        :param place_fields: A comma separated list of Place fields to display.
        :type place_fields: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: Get2UsersIdMentionsResponse
        """
        kwargs['_return_http_data_only'] = True
        return self.users_id_mentions_with_http_info(id, since_id, until_id, max_results, pagination_token, start_time, end_time, tweet_fields, expansions, media_fields, poll_fields, user_fields, place_fields, **kwargs)  # noqa: E501

    @validate_arguments
    def users_id_mentions_with_http_info(self, id : Annotated[constr(strict=True, regex=r'/^[0-9]{1,19}$/'), Field(..., description="The ID of the User to lookup.")], since_id : Annotated[Optional[constr(strict=True, regex=r'/^[0-9]{1,19}$/')], Field(description="The minimum Tweet ID to be included in the result set. This parameter takes precedence over start_time if both are specified.")] = None, until_id : Annotated[Optional[constr(strict=True, regex=r'/^[0-9]{1,19}$/')], Field(description="The maximum Tweet ID to be included in the result set. This parameter takes precedence over end_time if both are specified.")] = None, max_results : Annotated[Optional[conint(strict=True, ge=100, le=5)], Field(description="The maximum number of results.")] = None, pagination_token : Annotated[Optional[constr(strict=True, min_length=1)], Field(description="This parameter is used to get the next 'page' of results.")] = None, start_time : Annotated[Optional[datetime], Field(description="YYYY-MM-DDTHH:mm:ssZ. The earliest UTC timestamp from which the Tweets will be provided. The since_id parameter takes precedence if it is also specified.")] = None, end_time : Annotated[Optional[datetime], Field(description="YYYY-MM-DDTHH:mm:ssZ. The latest UTC timestamp to which the Tweets will be provided. The until_id parameter takes precedence if it is also specified.")] = None, tweet_fields : Annotated[Optional[List[Literal['attachments', 'author_id', 'context_annotations', 'conversation_id', 'created_at', 'entities', 'geo', 'id', 'in_reply_to_user_id', 'lang', 'non_public_metrics', 'organic_metrics', 'possibly_sensitive', 'promoted_metrics', 'public_metrics', 'referenced_tweets', 'reply_settings', 'source', 'text', 'withheld']]], Field(description="A comma separated list of Tweet fields to display.", unique_items=True)] = None, expansions : Annotated[Optional[List[Literal['attachments.media_keys', 'attachments.poll_ids', 'author_id', 'entities.mentions.username', 'geo.place_id', 'in_reply_to_user_id', 'referenced_tweets.id', 'referenced_tweets.id.author_id']]], Field(description="A comma separated list of fields to expand.", unique_items=True)] = None, media_fields : Annotated[Optional[List[Literal['alt_text', 'duration_ms', 'height', 'media_key', 'non_public_metrics', 'organic_metrics', 'preview_image_url', 'promoted_metrics', 'public_metrics', 'type', 'url', 'variants', 'width']]], Field(description="A comma separated list of Media fields to display.", unique_items=True)] = None, poll_fields : Annotated[Optional[List[Literal['duration_minutes', 'end_datetime', 'id', 'options', 'voting_status']]], Field(description="A comma separated list of Poll fields to display.", unique_items=True)] = None, user_fields : Annotated[Optional[List[Literal['created_at', 'description', 'entities', 'id', 'location', 'name', 'pinned_tweet_id', 'profile_image_url', 'protected', 'public_metrics', 'url', 'username', 'verified', 'withheld']]], Field(description="A comma separated list of User fields to display.", unique_items=True)] = None, place_fields : Annotated[Optional[List[Literal['contained_within', 'country', 'country_code', 'full_name', 'geo', 'id', 'name', 'place_type']]], Field(description="A comma separated list of Place fields to display.", unique_items=True)] = None, **kwargs):  # noqa: E501
        """User mention timeline by User ID  # noqa: E501

        Returns Tweet objects that mention username associated to the provided User ID  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.users_id_mentions_with_http_info(id, since_id, until_id, max_results, pagination_token, start_time, end_time, tweet_fields, expansions, media_fields, poll_fields, user_fields, place_fields, async_req=True)
        >>> result = thread.get()

        :param id: The ID of the User to lookup. (required)
        :type id: str
        :param since_id: The minimum Tweet ID to be included in the result set. This parameter takes precedence over start_time if both are specified.
        :type since_id: str
        :param until_id: The maximum Tweet ID to be included in the result set. This parameter takes precedence over end_time if both are specified.
        :type until_id: str
        :param max_results: The maximum number of results.
        :type max_results: int
        :param pagination_token: This parameter is used to get the next 'page' of results.
        :type pagination_token: str
        :param start_time: YYYY-MM-DDTHH:mm:ssZ. The earliest UTC timestamp from which the Tweets will be provided. The since_id parameter takes precedence if it is also specified.
        :type start_time: datetime
        :param end_time: YYYY-MM-DDTHH:mm:ssZ. The latest UTC timestamp to which the Tweets will be provided. The until_id parameter takes precedence if it is also specified.
        :type end_time: datetime
        :param tweet_fields: A comma separated list of Tweet fields to display.
        :type tweet_fields: List[str]
        :param expansions: A comma separated list of fields to expand.
        :type expansions: List[str]
        :param media_fields: A comma separated list of Media fields to display.
        :type media_fields: List[str]
        :param poll_fields: A comma separated list of Poll fields to display.
        :type poll_fields: List[str]
        :param user_fields: A comma separated list of User fields to display.
        :type user_fields: List[str]
        :param place_fields: A comma separated list of Place fields to display.
        :type place_fields: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(Get2UsersIdMentionsResponse, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'id',
            'since_id',
            'until_id',
            'max_results',
            'pagination_token',
            'start_time',
            'end_time',
            'tweet_fields',
            'expansions',
            'media_fields',
            'poll_fields',
            'user_fields',
            'place_fields'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in local_var_params['kwargs'].items():
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method users_id_mentions" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        collection_formats = {}

        path_params = {}
        if local_var_params['id']:
            path_params['id'] = local_var_params['id']

        query_params = []
        if local_var_params.get('since_id') is not None:  # noqa: E501
            query_params.append(('since_id', local_var_params['since_id']))
        if local_var_params.get('until_id') is not None:  # noqa: E501
            query_params.append(('until_id', local_var_params['until_id']))
        if local_var_params.get('max_results') is not None:  # noqa: E501
            query_params.append(('max_results', local_var_params['max_results']))
        if local_var_params.get('pagination_token') is not None:  # noqa: E501
            query_params.append(('pagination_token', local_var_params['pagination_token']))
        if local_var_params.get('start_time') is not None:  # noqa: E501
            query_params.append(('start_time', local_var_params['start_time']))
        if local_var_params.get('end_time') is not None:  # noqa: E501
            query_params.append(('end_time', local_var_params['end_time']))
        if local_var_params.get('tweet_fields') is not None:  # noqa: E501
            query_params.append(('tweet.fields', local_var_params['tweet_fields']))
            collection_formats['tweet.fields'] = 'csv'
        if local_var_params.get('expansions') is not None:  # noqa: E501
            query_params.append(('expansions', local_var_params['expansions']))
            collection_formats['expansions'] = 'csv'
        if local_var_params.get('media_fields') is not None:  # noqa: E501
            query_params.append(('media.fields', local_var_params['media_fields']))
            collection_formats['media.fields'] = 'csv'
        if local_var_params.get('poll_fields') is not None:  # noqa: E501
            query_params.append(('poll.fields', local_var_params['poll_fields']))
            collection_formats['poll.fields'] = 'csv'
        if local_var_params.get('user_fields') is not None:  # noqa: E501
            query_params.append(('user.fields', local_var_params['user_fields']))
            collection_formats['user.fields'] = 'csv'
        if local_var_params.get('place_fields') is not None:  # noqa: E501
            query_params.append(('place.fields', local_var_params['place_fields']))
            collection_formats['place.fields'] = 'csv'

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'application/problem+json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BearerToken', 'OAuth2UserToken', 'UserToken']  # noqa: E501

        response_types_map = {
            200: "Get2UsersIdMentionsResponse",
        }

        return self.api_client.call_api(
            '/2/users/{id}/mentions', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    @validate_arguments
    def users_id_retweets(self, id : Annotated[StrictStr, Field(..., description="The ID of the authenticated source User that is requesting to retweet the Tweet.")], users_retweets_create_request : Optional[UsersRetweetsCreateRequest] = None, **kwargs) -> UsersRetweetsCreateResponse:  # noqa: E501
        """Causes the User (in the path) to retweet the specified Tweet.  # noqa: E501

        Causes the User (in the path) to retweet the specified Tweet. The User in the path must match the User context authorizing the request.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.users_id_retweets(id, users_retweets_create_request, async_req=True)
        >>> result = thread.get()

        :param id: The ID of the authenticated source User that is requesting to retweet the Tweet. (required)
        :type id: str
        :param users_retweets_create_request:
        :type users_retweets_create_request: UsersRetweetsCreateRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: UsersRetweetsCreateResponse
        """
        kwargs['_return_http_data_only'] = True
        return self.users_id_retweets_with_http_info(id, users_retweets_create_request, **kwargs)  # noqa: E501

    @validate_arguments
    def users_id_retweets_with_http_info(self, id : Annotated[StrictStr, Field(..., description="The ID of the authenticated source User that is requesting to retweet the Tweet.")], users_retweets_create_request : Optional[UsersRetweetsCreateRequest] = None, **kwargs):  # noqa: E501
        """Causes the User (in the path) to retweet the specified Tweet.  # noqa: E501

        Causes the User (in the path) to retweet the specified Tweet. The User in the path must match the User context authorizing the request.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.users_id_retweets_with_http_info(id, users_retweets_create_request, async_req=True)
        >>> result = thread.get()

        :param id: The ID of the authenticated source User that is requesting to retweet the Tweet. (required)
        :type id: str
        :param users_retweets_create_request:
        :type users_retweets_create_request: UsersRetweetsCreateRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(UsersRetweetsCreateResponse, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'id',
            'users_retweets_create_request'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in local_var_params['kwargs'].items():
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method users_id_retweets" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        collection_formats = {}

        path_params = {}
        if local_var_params['id']:
            path_params['id'] = local_var_params['id']

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        if local_var_params['users_retweets_create_request']:
            body_params = local_var_params['users_retweets_create_request']

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'application/problem+json'])  # noqa: E501

        # HTTP header `Content-Type`
        content_types_list = local_var_params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if content_types_list:
                header_params['Content-Type'] = content_types_list

        # Authentication setting
        auth_settings = ['OAuth2UserToken', 'UserToken']  # noqa: E501

        response_types_map = {
            200: "UsersRetweetsCreateResponse",
        }

        return self.api_client.call_api(
            '/2/users/{id}/retweets', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    @validate_arguments
    def users_id_timeline(self, id : Annotated[StrictStr, Field(..., description="The ID of the authenticated source User to list Reverse Chronological Timeline Tweets of.")], since_id : Annotated[Optional[constr(strict=True, regex=r'/^[0-9]{1,19}$/')], Field(description="The minimum Tweet ID to be included in the result set. This parameter takes precedence over start_time if both are specified.")] = None, until_id : Annotated[Optional[constr(strict=True, regex=r'/^[0-9]{1,19}$/')], Field(description="The maximum Tweet ID to be included in the result set. This parameter takes precedence over end_time if both are specified.")] = None, max_results : Annotated[Optional[conint(strict=True, ge=100, le=1)], Field(description="The maximum number of results.")] = None, pagination_token : Annotated[Optional[constr(strict=True, min_length=1)], Field(description="This parameter is used to get the next 'page' of results.")] = None, exclude : Annotated[Optional[List[Literal['replies', 'retweets']]], Field(description="The set of entities to exclude (e.g. 'replies' or 'retweets').", unique_items=True)] = None, start_time : Annotated[Optional[datetime], Field(description="YYYY-MM-DDTHH:mm:ssZ. The earliest UTC timestamp from which the Tweets will be provided. The since_id parameter takes precedence if it is also specified.")] = None, end_time : Annotated[Optional[datetime], Field(description="YYYY-MM-DDTHH:mm:ssZ. The latest UTC timestamp to which the Tweets will be provided. The until_id parameter takes precedence if it is also specified.")] = None, tweet_fields : Annotated[Optional[List[Literal['attachments', 'author_id', 'context_annotations', 'conversation_id', 'created_at', 'entities', 'geo', 'id', 'in_reply_to_user_id', 'lang', 'non_public_metrics', 'organic_metrics', 'possibly_sensitive', 'promoted_metrics', 'public_metrics', 'referenced_tweets', 'reply_settings', 'source', 'text', 'withheld']]], Field(description="A comma separated list of Tweet fields to display.", unique_items=True)] = None, expansions : Annotated[Optional[List[Literal['attachments.media_keys', 'attachments.poll_ids', 'author_id', 'entities.mentions.username', 'geo.place_id', 'in_reply_to_user_id', 'referenced_tweets.id', 'referenced_tweets.id.author_id']]], Field(description="A comma separated list of fields to expand.", unique_items=True)] = None, media_fields : Annotated[Optional[List[Literal['alt_text', 'duration_ms', 'height', 'media_key', 'non_public_metrics', 'organic_metrics', 'preview_image_url', 'promoted_metrics', 'public_metrics', 'type', 'url', 'variants', 'width']]], Field(description="A comma separated list of Media fields to display.", unique_items=True)] = None, poll_fields : Annotated[Optional[List[Literal['duration_minutes', 'end_datetime', 'id', 'options', 'voting_status']]], Field(description="A comma separated list of Poll fields to display.", unique_items=True)] = None, user_fields : Annotated[Optional[List[Literal['created_at', 'description', 'entities', 'id', 'location', 'name', 'pinned_tweet_id', 'profile_image_url', 'protected', 'public_metrics', 'url', 'username', 'verified', 'withheld']]], Field(description="A comma separated list of User fields to display.", unique_items=True)] = None, place_fields : Annotated[Optional[List[Literal['contained_within', 'country', 'country_code', 'full_name', 'geo', 'id', 'name', 'place_type']]], Field(description="A comma separated list of Place fields to display.", unique_items=True)] = None, **kwargs) -> Get2UsersIdTimelinesReverseChronologicalResponse:  # noqa: E501
        """User home timeline by User ID  # noqa: E501

        Returns Tweet objects that appears in the provided User ID's home timeline  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.users_id_timeline(id, since_id, until_id, max_results, pagination_token, exclude, start_time, end_time, tweet_fields, expansions, media_fields, poll_fields, user_fields, place_fields, async_req=True)
        >>> result = thread.get()

        :param id: The ID of the authenticated source User to list Reverse Chronological Timeline Tweets of. (required)
        :type id: str
        :param since_id: The minimum Tweet ID to be included in the result set. This parameter takes precedence over start_time if both are specified.
        :type since_id: str
        :param until_id: The maximum Tweet ID to be included in the result set. This parameter takes precedence over end_time if both are specified.
        :type until_id: str
        :param max_results: The maximum number of results.
        :type max_results: int
        :param pagination_token: This parameter is used to get the next 'page' of results.
        :type pagination_token: str
        :param exclude: The set of entities to exclude (e.g. 'replies' or 'retweets').
        :type exclude: List[str]
        :param start_time: YYYY-MM-DDTHH:mm:ssZ. The earliest UTC timestamp from which the Tweets will be provided. The since_id parameter takes precedence if it is also specified.
        :type start_time: datetime
        :param end_time: YYYY-MM-DDTHH:mm:ssZ. The latest UTC timestamp to which the Tweets will be provided. The until_id parameter takes precedence if it is also specified.
        :type end_time: datetime
        :param tweet_fields: A comma separated list of Tweet fields to display.
        :type tweet_fields: List[str]
        :param expansions: A comma separated list of fields to expand.
        :type expansions: List[str]
        :param media_fields: A comma separated list of Media fields to display.
        :type media_fields: List[str]
        :param poll_fields: A comma separated list of Poll fields to display.
        :type poll_fields: List[str]
        :param user_fields: A comma separated list of User fields to display.
        :type user_fields: List[str]
        :param place_fields: A comma separated list of Place fields to display.
        :type place_fields: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: Get2UsersIdTimelinesReverseChronologicalResponse
        """
        kwargs['_return_http_data_only'] = True
        return self.users_id_timeline_with_http_info(id, since_id, until_id, max_results, pagination_token, exclude, start_time, end_time, tweet_fields, expansions, media_fields, poll_fields, user_fields, place_fields, **kwargs)  # noqa: E501

    @validate_arguments
    def users_id_timeline_with_http_info(self, id : Annotated[StrictStr, Field(..., description="The ID of the authenticated source User to list Reverse Chronological Timeline Tweets of.")], since_id : Annotated[Optional[constr(strict=True, regex=r'/^[0-9]{1,19}$/')], Field(description="The minimum Tweet ID to be included in the result set. This parameter takes precedence over start_time if both are specified.")] = None, until_id : Annotated[Optional[constr(strict=True, regex=r'/^[0-9]{1,19}$/')], Field(description="The maximum Tweet ID to be included in the result set. This parameter takes precedence over end_time if both are specified.")] = None, max_results : Annotated[Optional[conint(strict=True, ge=100, le=1)], Field(description="The maximum number of results.")] = None, pagination_token : Annotated[Optional[constr(strict=True, min_length=1)], Field(description="This parameter is used to get the next 'page' of results.")] = None, exclude : Annotated[Optional[List[Literal['replies', 'retweets']]], Field(description="The set of entities to exclude (e.g. 'replies' or 'retweets').", unique_items=True)] = None, start_time : Annotated[Optional[datetime], Field(description="YYYY-MM-DDTHH:mm:ssZ. The earliest UTC timestamp from which the Tweets will be provided. The since_id parameter takes precedence if it is also specified.")] = None, end_time : Annotated[Optional[datetime], Field(description="YYYY-MM-DDTHH:mm:ssZ. The latest UTC timestamp to which the Tweets will be provided. The until_id parameter takes precedence if it is also specified.")] = None, tweet_fields : Annotated[Optional[List[Literal['attachments', 'author_id', 'context_annotations', 'conversation_id', 'created_at', 'entities', 'geo', 'id', 'in_reply_to_user_id', 'lang', 'non_public_metrics', 'organic_metrics', 'possibly_sensitive', 'promoted_metrics', 'public_metrics', 'referenced_tweets', 'reply_settings', 'source', 'text', 'withheld']]], Field(description="A comma separated list of Tweet fields to display.", unique_items=True)] = None, expansions : Annotated[Optional[List[Literal['attachments.media_keys', 'attachments.poll_ids', 'author_id', 'entities.mentions.username', 'geo.place_id', 'in_reply_to_user_id', 'referenced_tweets.id', 'referenced_tweets.id.author_id']]], Field(description="A comma separated list of fields to expand.", unique_items=True)] = None, media_fields : Annotated[Optional[List[Literal['alt_text', 'duration_ms', 'height', 'media_key', 'non_public_metrics', 'organic_metrics', 'preview_image_url', 'promoted_metrics', 'public_metrics', 'type', 'url', 'variants', 'width']]], Field(description="A comma separated list of Media fields to display.", unique_items=True)] = None, poll_fields : Annotated[Optional[List[Literal['duration_minutes', 'end_datetime', 'id', 'options', 'voting_status']]], Field(description="A comma separated list of Poll fields to display.", unique_items=True)] = None, user_fields : Annotated[Optional[List[Literal['created_at', 'description', 'entities', 'id', 'location', 'name', 'pinned_tweet_id', 'profile_image_url', 'protected', 'public_metrics', 'url', 'username', 'verified', 'withheld']]], Field(description="A comma separated list of User fields to display.", unique_items=True)] = None, place_fields : Annotated[Optional[List[Literal['contained_within', 'country', 'country_code', 'full_name', 'geo', 'id', 'name', 'place_type']]], Field(description="A comma separated list of Place fields to display.", unique_items=True)] = None, **kwargs):  # noqa: E501
        """User home timeline by User ID  # noqa: E501

        Returns Tweet objects that appears in the provided User ID's home timeline  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.users_id_timeline_with_http_info(id, since_id, until_id, max_results, pagination_token, exclude, start_time, end_time, tweet_fields, expansions, media_fields, poll_fields, user_fields, place_fields, async_req=True)
        >>> result = thread.get()

        :param id: The ID of the authenticated source User to list Reverse Chronological Timeline Tweets of. (required)
        :type id: str
        :param since_id: The minimum Tweet ID to be included in the result set. This parameter takes precedence over start_time if both are specified.
        :type since_id: str
        :param until_id: The maximum Tweet ID to be included in the result set. This parameter takes precedence over end_time if both are specified.
        :type until_id: str
        :param max_results: The maximum number of results.
        :type max_results: int
        :param pagination_token: This parameter is used to get the next 'page' of results.
        :type pagination_token: str
        :param exclude: The set of entities to exclude (e.g. 'replies' or 'retweets').
        :type exclude: List[str]
        :param start_time: YYYY-MM-DDTHH:mm:ssZ. The earliest UTC timestamp from which the Tweets will be provided. The since_id parameter takes precedence if it is also specified.
        :type start_time: datetime
        :param end_time: YYYY-MM-DDTHH:mm:ssZ. The latest UTC timestamp to which the Tweets will be provided. The until_id parameter takes precedence if it is also specified.
        :type end_time: datetime
        :param tweet_fields: A comma separated list of Tweet fields to display.
        :type tweet_fields: List[str]
        :param expansions: A comma separated list of fields to expand.
        :type expansions: List[str]
        :param media_fields: A comma separated list of Media fields to display.
        :type media_fields: List[str]
        :param poll_fields: A comma separated list of Poll fields to display.
        :type poll_fields: List[str]
        :param user_fields: A comma separated list of User fields to display.
        :type user_fields: List[str]
        :param place_fields: A comma separated list of Place fields to display.
        :type place_fields: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(Get2UsersIdTimelinesReverseChronologicalResponse, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'id',
            'since_id',
            'until_id',
            'max_results',
            'pagination_token',
            'exclude',
            'start_time',
            'end_time',
            'tweet_fields',
            'expansions',
            'media_fields',
            'poll_fields',
            'user_fields',
            'place_fields'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in local_var_params['kwargs'].items():
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method users_id_timeline" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        collection_formats = {}

        path_params = {}
        if local_var_params['id']:
            path_params['id'] = local_var_params['id']

        query_params = []
        if local_var_params.get('since_id') is not None:  # noqa: E501
            query_params.append(('since_id', local_var_params['since_id']))
        if local_var_params.get('until_id') is not None:  # noqa: E501
            query_params.append(('until_id', local_var_params['until_id']))
        if local_var_params.get('max_results') is not None:  # noqa: E501
            query_params.append(('max_results', local_var_params['max_results']))
        if local_var_params.get('pagination_token') is not None:  # noqa: E501
            query_params.append(('pagination_token', local_var_params['pagination_token']))
        if local_var_params.get('exclude') is not None:  # noqa: E501
            query_params.append(('exclude', local_var_params['exclude']))
            collection_formats['exclude'] = 'csv'
        if local_var_params.get('start_time') is not None:  # noqa: E501
            query_params.append(('start_time', local_var_params['start_time']))
        if local_var_params.get('end_time') is not None:  # noqa: E501
            query_params.append(('end_time', local_var_params['end_time']))
        if local_var_params.get('tweet_fields') is not None:  # noqa: E501
            query_params.append(('tweet.fields', local_var_params['tweet_fields']))
            collection_formats['tweet.fields'] = 'csv'
        if local_var_params.get('expansions') is not None:  # noqa: E501
            query_params.append(('expansions', local_var_params['expansions']))
            collection_formats['expansions'] = 'csv'
        if local_var_params.get('media_fields') is not None:  # noqa: E501
            query_params.append(('media.fields', local_var_params['media_fields']))
            collection_formats['media.fields'] = 'csv'
        if local_var_params.get('poll_fields') is not None:  # noqa: E501
            query_params.append(('poll.fields', local_var_params['poll_fields']))
            collection_formats['poll.fields'] = 'csv'
        if local_var_params.get('user_fields') is not None:  # noqa: E501
            query_params.append(('user.fields', local_var_params['user_fields']))
            collection_formats['user.fields'] = 'csv'
        if local_var_params.get('place_fields') is not None:  # noqa: E501
            query_params.append(('place.fields', local_var_params['place_fields']))
            collection_formats['place.fields'] = 'csv'

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'application/problem+json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['OAuth2UserToken', 'UserToken']  # noqa: E501

        response_types_map = {
            200: "Get2UsersIdTimelinesReverseChronologicalResponse",
        }

        return self.api_client.call_api(
            '/2/users/{id}/timelines/reverse_chronological', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    @validate_arguments
    def users_id_tweets(self, id : Annotated[constr(strict=True, regex=r'/^[0-9]{1,19}$/'), Field(..., description="The ID of the User to lookup.")], since_id : Annotated[Optional[constr(strict=True, regex=r'/^[0-9]{1,19}$/')], Field(description="The minimum Tweet ID to be included in the result set. This parameter takes precedence over start_time if both are specified.")] = None, until_id : Annotated[Optional[constr(strict=True, regex=r'/^[0-9]{1,19}$/')], Field(description="The maximum Tweet ID to be included in the result set. This parameter takes precedence over end_time if both are specified.")] = None, max_results : Annotated[Optional[conint(strict=True, ge=100, le=5)], Field(description="The maximum number of results.")] = None, pagination_token : Annotated[Optional[constr(strict=True, min_length=1)], Field(description="This parameter is used to get the next 'page' of results.")] = None, exclude : Annotated[Optional[List[Literal['replies', 'retweets']]], Field(description="The set of entities to exclude (e.g. 'replies' or 'retweets').", unique_items=True)] = None, start_time : Annotated[Optional[datetime], Field(description="YYYY-MM-DDTHH:mm:ssZ. The earliest UTC timestamp from which the Tweets will be provided. The since_id parameter takes precedence if it is also specified.")] = None, end_time : Annotated[Optional[datetime], Field(description="YYYY-MM-DDTHH:mm:ssZ. The latest UTC timestamp to which the Tweets will be provided. The until_id parameter takes precedence if it is also specified.")] = None, tweet_fields : Annotated[Optional[List[Literal['attachments', 'author_id', 'context_annotations', 'conversation_id', 'created_at', 'entities', 'geo', 'id', 'in_reply_to_user_id', 'lang', 'non_public_metrics', 'organic_metrics', 'possibly_sensitive', 'promoted_metrics', 'public_metrics', 'referenced_tweets', 'reply_settings', 'source', 'text', 'withheld']]], Field(description="A comma separated list of Tweet fields to display.", unique_items=True)] = None, expansions : Annotated[Optional[List[Literal['attachments.media_keys', 'attachments.poll_ids', 'author_id', 'entities.mentions.username', 'geo.place_id', 'in_reply_to_user_id', 'referenced_tweets.id', 'referenced_tweets.id.author_id']]], Field(description="A comma separated list of fields to expand.", unique_items=True)] = None, media_fields : Annotated[Optional[List[Literal['alt_text', 'duration_ms', 'height', 'media_key', 'non_public_metrics', 'organic_metrics', 'preview_image_url', 'promoted_metrics', 'public_metrics', 'type', 'url', 'variants', 'width']]], Field(description="A comma separated list of Media fields to display.", unique_items=True)] = None, poll_fields : Annotated[Optional[List[Literal['duration_minutes', 'end_datetime', 'id', 'options', 'voting_status']]], Field(description="A comma separated list of Poll fields to display.", unique_items=True)] = None, user_fields : Annotated[Optional[List[Literal['created_at', 'description', 'entities', 'id', 'location', 'name', 'pinned_tweet_id', 'profile_image_url', 'protected', 'public_metrics', 'url', 'username', 'verified', 'withheld']]], Field(description="A comma separated list of User fields to display.", unique_items=True)] = None, place_fields : Annotated[Optional[List[Literal['contained_within', 'country', 'country_code', 'full_name', 'geo', 'id', 'name', 'place_type']]], Field(description="A comma separated list of Place fields to display.", unique_items=True)] = None, **kwargs) -> Get2UsersIdTweetsResponse:  # noqa: E501
        """User Tweets timeline by User ID  # noqa: E501

        Returns a list of Tweets authored by the provided User ID  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.users_id_tweets(id, since_id, until_id, max_results, pagination_token, exclude, start_time, end_time, tweet_fields, expansions, media_fields, poll_fields, user_fields, place_fields, async_req=True)
        >>> result = thread.get()

        :param id: The ID of the User to lookup. (required)
        :type id: str
        :param since_id: The minimum Tweet ID to be included in the result set. This parameter takes precedence over start_time if both are specified.
        :type since_id: str
        :param until_id: The maximum Tweet ID to be included in the result set. This parameter takes precedence over end_time if both are specified.
        :type until_id: str
        :param max_results: The maximum number of results.
        :type max_results: int
        :param pagination_token: This parameter is used to get the next 'page' of results.
        :type pagination_token: str
        :param exclude: The set of entities to exclude (e.g. 'replies' or 'retweets').
        :type exclude: List[str]
        :param start_time: YYYY-MM-DDTHH:mm:ssZ. The earliest UTC timestamp from which the Tweets will be provided. The since_id parameter takes precedence if it is also specified.
        :type start_time: datetime
        :param end_time: YYYY-MM-DDTHH:mm:ssZ. The latest UTC timestamp to which the Tweets will be provided. The until_id parameter takes precedence if it is also specified.
        :type end_time: datetime
        :param tweet_fields: A comma separated list of Tweet fields to display.
        :type tweet_fields: List[str]
        :param expansions: A comma separated list of fields to expand.
        :type expansions: List[str]
        :param media_fields: A comma separated list of Media fields to display.
        :type media_fields: List[str]
        :param poll_fields: A comma separated list of Poll fields to display.
        :type poll_fields: List[str]
        :param user_fields: A comma separated list of User fields to display.
        :type user_fields: List[str]
        :param place_fields: A comma separated list of Place fields to display.
        :type place_fields: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: Get2UsersIdTweetsResponse
        """
        kwargs['_return_http_data_only'] = True
        return self.users_id_tweets_with_http_info(id, since_id, until_id, max_results, pagination_token, exclude, start_time, end_time, tweet_fields, expansions, media_fields, poll_fields, user_fields, place_fields, **kwargs)  # noqa: E501

    @validate_arguments
    def users_id_tweets_with_http_info(self, id : Annotated[constr(strict=True, regex=r'/^[0-9]{1,19}$/'), Field(..., description="The ID of the User to lookup.")], since_id : Annotated[Optional[constr(strict=True, regex=r'/^[0-9]{1,19}$/')], Field(description="The minimum Tweet ID to be included in the result set. This parameter takes precedence over start_time if both are specified.")] = None, until_id : Annotated[Optional[constr(strict=True, regex=r'/^[0-9]{1,19}$/')], Field(description="The maximum Tweet ID to be included in the result set. This parameter takes precedence over end_time if both are specified.")] = None, max_results : Annotated[Optional[conint(strict=True, ge=100, le=5)], Field(description="The maximum number of results.")] = None, pagination_token : Annotated[Optional[constr(strict=True, min_length=1)], Field(description="This parameter is used to get the next 'page' of results.")] = None, exclude : Annotated[Optional[List[Literal['replies', 'retweets']]], Field(description="The set of entities to exclude (e.g. 'replies' or 'retweets').", unique_items=True)] = None, start_time : Annotated[Optional[datetime], Field(description="YYYY-MM-DDTHH:mm:ssZ. The earliest UTC timestamp from which the Tweets will be provided. The since_id parameter takes precedence if it is also specified.")] = None, end_time : Annotated[Optional[datetime], Field(description="YYYY-MM-DDTHH:mm:ssZ. The latest UTC timestamp to which the Tweets will be provided. The until_id parameter takes precedence if it is also specified.")] = None, tweet_fields : Annotated[Optional[List[Literal['attachments', 'author_id', 'context_annotations', 'conversation_id', 'created_at', 'entities', 'geo', 'id', 'in_reply_to_user_id', 'lang', 'non_public_metrics', 'organic_metrics', 'possibly_sensitive', 'promoted_metrics', 'public_metrics', 'referenced_tweets', 'reply_settings', 'source', 'text', 'withheld']]], Field(description="A comma separated list of Tweet fields to display.", unique_items=True)] = None, expansions : Annotated[Optional[List[Literal['attachments.media_keys', 'attachments.poll_ids', 'author_id', 'entities.mentions.username', 'geo.place_id', 'in_reply_to_user_id', 'referenced_tweets.id', 'referenced_tweets.id.author_id']]], Field(description="A comma separated list of fields to expand.", unique_items=True)] = None, media_fields : Annotated[Optional[List[Literal['alt_text', 'duration_ms', 'height', 'media_key', 'non_public_metrics', 'organic_metrics', 'preview_image_url', 'promoted_metrics', 'public_metrics', 'type', 'url', 'variants', 'width']]], Field(description="A comma separated list of Media fields to display.", unique_items=True)] = None, poll_fields : Annotated[Optional[List[Literal['duration_minutes', 'end_datetime', 'id', 'options', 'voting_status']]], Field(description="A comma separated list of Poll fields to display.", unique_items=True)] = None, user_fields : Annotated[Optional[List[Literal['created_at', 'description', 'entities', 'id', 'location', 'name', 'pinned_tweet_id', 'profile_image_url', 'protected', 'public_metrics', 'url', 'username', 'verified', 'withheld']]], Field(description="A comma separated list of User fields to display.", unique_items=True)] = None, place_fields : Annotated[Optional[List[Literal['contained_within', 'country', 'country_code', 'full_name', 'geo', 'id', 'name', 'place_type']]], Field(description="A comma separated list of Place fields to display.", unique_items=True)] = None, **kwargs):  # noqa: E501
        """User Tweets timeline by User ID  # noqa: E501

        Returns a list of Tweets authored by the provided User ID  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.users_id_tweets_with_http_info(id, since_id, until_id, max_results, pagination_token, exclude, start_time, end_time, tweet_fields, expansions, media_fields, poll_fields, user_fields, place_fields, async_req=True)
        >>> result = thread.get()

        :param id: The ID of the User to lookup. (required)
        :type id: str
        :param since_id: The minimum Tweet ID to be included in the result set. This parameter takes precedence over start_time if both are specified.
        :type since_id: str
        :param until_id: The maximum Tweet ID to be included in the result set. This parameter takes precedence over end_time if both are specified.
        :type until_id: str
        :param max_results: The maximum number of results.
        :type max_results: int
        :param pagination_token: This parameter is used to get the next 'page' of results.
        :type pagination_token: str
        :param exclude: The set of entities to exclude (e.g. 'replies' or 'retweets').
        :type exclude: List[str]
        :param start_time: YYYY-MM-DDTHH:mm:ssZ. The earliest UTC timestamp from which the Tweets will be provided. The since_id parameter takes precedence if it is also specified.
        :type start_time: datetime
        :param end_time: YYYY-MM-DDTHH:mm:ssZ. The latest UTC timestamp to which the Tweets will be provided. The until_id parameter takes precedence if it is also specified.
        :type end_time: datetime
        :param tweet_fields: A comma separated list of Tweet fields to display.
        :type tweet_fields: List[str]
        :param expansions: A comma separated list of fields to expand.
        :type expansions: List[str]
        :param media_fields: A comma separated list of Media fields to display.
        :type media_fields: List[str]
        :param poll_fields: A comma separated list of Poll fields to display.
        :type poll_fields: List[str]
        :param user_fields: A comma separated list of User fields to display.
        :type user_fields: List[str]
        :param place_fields: A comma separated list of Place fields to display.
        :type place_fields: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(Get2UsersIdTweetsResponse, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'id',
            'since_id',
            'until_id',
            'max_results',
            'pagination_token',
            'exclude',
            'start_time',
            'end_time',
            'tweet_fields',
            'expansions',
            'media_fields',
            'poll_fields',
            'user_fields',
            'place_fields'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in local_var_params['kwargs'].items():
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method users_id_tweets" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        collection_formats = {}

        path_params = {}
        if local_var_params['id']:
            path_params['id'] = local_var_params['id']

        query_params = []
        if local_var_params.get('since_id') is not None:  # noqa: E501
            query_params.append(('since_id', local_var_params['since_id']))
        if local_var_params.get('until_id') is not None:  # noqa: E501
            query_params.append(('until_id', local_var_params['until_id']))
        if local_var_params.get('max_results') is not None:  # noqa: E501
            query_params.append(('max_results', local_var_params['max_results']))
        if local_var_params.get('pagination_token') is not None:  # noqa: E501
            query_params.append(('pagination_token', local_var_params['pagination_token']))
        if local_var_params.get('exclude') is not None:  # noqa: E501
            query_params.append(('exclude', local_var_params['exclude']))
            collection_formats['exclude'] = 'csv'
        if local_var_params.get('start_time') is not None:  # noqa: E501
            query_params.append(('start_time', local_var_params['start_time']))
        if local_var_params.get('end_time') is not None:  # noqa: E501
            query_params.append(('end_time', local_var_params['end_time']))
        if local_var_params.get('tweet_fields') is not None:  # noqa: E501
            query_params.append(('tweet.fields', local_var_params['tweet_fields']))
            collection_formats['tweet.fields'] = 'csv'
        if local_var_params.get('expansions') is not None:  # noqa: E501
            query_params.append(('expansions', local_var_params['expansions']))
            collection_formats['expansions'] = 'csv'
        if local_var_params.get('media_fields') is not None:  # noqa: E501
            query_params.append(('media.fields', local_var_params['media_fields']))
            collection_formats['media.fields'] = 'csv'
        if local_var_params.get('poll_fields') is not None:  # noqa: E501
            query_params.append(('poll.fields', local_var_params['poll_fields']))
            collection_formats['poll.fields'] = 'csv'
        if local_var_params.get('user_fields') is not None:  # noqa: E501
            query_params.append(('user.fields', local_var_params['user_fields']))
            collection_formats['user.fields'] = 'csv'
        if local_var_params.get('place_fields') is not None:  # noqa: E501
            query_params.append(('place.fields', local_var_params['place_fields']))
            collection_formats['place.fields'] = 'csv'

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'application/problem+json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BearerToken', 'OAuth2UserToken', 'UserToken']  # noqa: E501

        response_types_map = {
            200: "Get2UsersIdTweetsResponse",
        }

        return self.api_client.call_api(
            '/2/users/{id}/tweets', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    @validate_arguments
    def users_id_unlike(self, id : Annotated[StrictStr, Field(..., description="The ID of the authenticated source User that is requesting to unlike the Tweet.")], tweet_id : Annotated[constr(strict=True, regex=r'/^[0-9]{1,19}$/'), Field(..., description="The ID of the Tweet that the User is requesting to unlike.")], **kwargs) -> UsersLikesDeleteResponse:  # noqa: E501
        """Causes the User (in the path) to unlike the specified Tweet  # noqa: E501

        Causes the User (in the path) to unlike the specified Tweet. The User must match the User context authorizing the request  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.users_id_unlike(id, tweet_id, async_req=True)
        >>> result = thread.get()

        :param id: The ID of the authenticated source User that is requesting to unlike the Tweet. (required)
        :type id: str
        :param tweet_id: The ID of the Tweet that the User is requesting to unlike. (required)
        :type tweet_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: UsersLikesDeleteResponse
        """
        kwargs['_return_http_data_only'] = True
        return self.users_id_unlike_with_http_info(id, tweet_id, **kwargs)  # noqa: E501

    @validate_arguments
    def users_id_unlike_with_http_info(self, id : Annotated[StrictStr, Field(..., description="The ID of the authenticated source User that is requesting to unlike the Tweet.")], tweet_id : Annotated[constr(strict=True, regex=r'/^[0-9]{1,19}$/'), Field(..., description="The ID of the Tweet that the User is requesting to unlike.")], **kwargs):  # noqa: E501
        """Causes the User (in the path) to unlike the specified Tweet  # noqa: E501

        Causes the User (in the path) to unlike the specified Tweet. The User must match the User context authorizing the request  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.users_id_unlike_with_http_info(id, tweet_id, async_req=True)
        >>> result = thread.get()

        :param id: The ID of the authenticated source User that is requesting to unlike the Tweet. (required)
        :type id: str
        :param tweet_id: The ID of the Tweet that the User is requesting to unlike. (required)
        :type tweet_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(UsersLikesDeleteResponse, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'id',
            'tweet_id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in local_var_params['kwargs'].items():
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method users_id_unlike" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        collection_formats = {}

        path_params = {}
        if local_var_params['id']:
            path_params['id'] = local_var_params['id']
        if local_var_params['tweet_id']:
            path_params['tweet_id'] = local_var_params['tweet_id']

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'application/problem+json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['OAuth2UserToken', 'UserToken']  # noqa: E501

        response_types_map = {
            200: "UsersLikesDeleteResponse",
        }

        return self.api_client.call_api(
            '/2/users/{id}/likes/{tweet_id}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    @validate_arguments
    def users_id_unretweets(self, id : Annotated[StrictStr, Field(..., description="The ID of the authenticated source User that is requesting to retweet the Tweet.")], source_tweet_id : Annotated[constr(strict=True, regex=r'/^[0-9]{1,19}$/'), Field(..., description="The ID of the Tweet that the User is requesting to unretweet.")], **kwargs) -> UsersRetweetsDeleteResponse:  # noqa: E501
        """Causes the User (in the path) to unretweet the specified Tweet  # noqa: E501

        Causes the User (in the path) to unretweet the specified Tweet. The User must match the User context authorizing the request  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.users_id_unretweets(id, source_tweet_id, async_req=True)
        >>> result = thread.get()

        :param id: The ID of the authenticated source User that is requesting to retweet the Tweet. (required)
        :type id: str
        :param source_tweet_id: The ID of the Tweet that the User is requesting to unretweet. (required)
        :type source_tweet_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: UsersRetweetsDeleteResponse
        """
        kwargs['_return_http_data_only'] = True
        return self.users_id_unretweets_with_http_info(id, source_tweet_id, **kwargs)  # noqa: E501

    @validate_arguments
    def users_id_unretweets_with_http_info(self, id : Annotated[StrictStr, Field(..., description="The ID of the authenticated source User that is requesting to retweet the Tweet.")], source_tweet_id : Annotated[constr(strict=True, regex=r'/^[0-9]{1,19}$/'), Field(..., description="The ID of the Tweet that the User is requesting to unretweet.")], **kwargs):  # noqa: E501
        """Causes the User (in the path) to unretweet the specified Tweet  # noqa: E501

        Causes the User (in the path) to unretweet the specified Tweet. The User must match the User context authorizing the request  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.users_id_unretweets_with_http_info(id, source_tweet_id, async_req=True)
        >>> result = thread.get()

        :param id: The ID of the authenticated source User that is requesting to retweet the Tweet. (required)
        :type id: str
        :param source_tweet_id: The ID of the Tweet that the User is requesting to unretweet. (required)
        :type source_tweet_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(UsersRetweetsDeleteResponse, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'id',
            'source_tweet_id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in local_var_params['kwargs'].items():
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method users_id_unretweets" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        collection_formats = {}

        path_params = {}
        if local_var_params['id']:
            path_params['id'] = local_var_params['id']
        if local_var_params['source_tweet_id']:
            path_params['source_tweet_id'] = local_var_params['source_tweet_id']

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'application/problem+json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['OAuth2UserToken', 'UserToken']  # noqa: E501

        response_types_map = {
            200: "UsersRetweetsDeleteResponse",
        }

        return self.api_client.call_api(
            '/2/users/{id}/retweets/{source_tweet_id}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))
