# coding: utf-8

"""
    Twitter API v2

    Twitter API v2 available endpoints  # noqa: E501

    The version of the OpenAPI document: 2.49
    Generated by: https://openapi-generator.tech
"""


from __future__ import absolute_import

import re  # noqa: F401

from pydantic import validate_arguments, ValidationError
from typing_extensions import Annotated

from pydantic import Field, StrictStr, conint, constr

from typing import List, Literal, Optional

from twitter import models
from twitter.models import Get2SpacesByCreatorIdsResponse, Get2SpacesIdBuyersResponse, Get2SpacesIdResponse, Get2SpacesIdTweetsResponse, Get2SpacesResponse, Get2SpacesSearchResponse

from twitter.api_client import ApiClient
from twitter.exceptions import (  # noqa: F401
    ApiTypeError,
    ApiValueError
)


class SpacesApi(object):
    """NOTE: This class is auto generated by OpenAPI Generator
    Ref: https://openapi-generator.tech

    Do not edit the class manually.
    """

    def __init__(self, api_client=None):
        if api_client is None:
            api_client = ApiClient()
        self.api_client = api_client

    @validate_arguments
    def find_space_by_id(self, id : Annotated[constr(strict=True, regex=r'/^[a-zA-Z0-9]{1,13}$/'), Field(..., description="The ID of the Space to be retrieved.")], space_fields : Annotated[Optional[List[Literal['created_at', 'creator_id', 'ended_at', 'host_ids', 'id', 'invited_user_ids', 'is_ticketed', 'lang', 'participant_count', 'scheduled_start', 'speaker_ids', 'started_at', 'state', 'subscriber_count', 'title', 'topic_ids', 'updated_at']]], Field(description="A comma separated list of Space fields to display.", unique_items=True)] = None, expansions : Annotated[Optional[List[Literal['creator_id', 'host_ids', 'invited_user_ids', 'speaker_ids', 'topic_ids']]], Field(description="A comma separated list of fields to expand.", unique_items=True)] = None, user_fields : Annotated[Optional[List[Literal['created_at', 'description', 'entities', 'id', 'location', 'name', 'pinned_tweet_id', 'profile_image_url', 'protected', 'public_metrics', 'url', 'username', 'verified', 'withheld']]], Field(description="A comma separated list of User fields to display.", unique_items=True)] = None, topic_fields : Annotated[Optional[List[Literal['description', 'id', 'name']]], Field(description="A comma separated list of Topic fields to display.", unique_items=True)] = None, **kwargs) -> Get2SpacesIdResponse:  # noqa: E501
        """Space lookup by Space ID  # noqa: E501

        Returns a variety of information about the Space specified by the requested ID  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.find_space_by_id(id, space_fields, expansions, user_fields, topic_fields, async_req=True)
        >>> result = thread.get()

        :param id: The ID of the Space to be retrieved. (required)
        :type id: str
        :param space_fields: A comma separated list of Space fields to display.
        :type space_fields: List[str]
        :param expansions: A comma separated list of fields to expand.
        :type expansions: List[str]
        :param user_fields: A comma separated list of User fields to display.
        :type user_fields: List[str]
        :param topic_fields: A comma separated list of Topic fields to display.
        :type topic_fields: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: Get2SpacesIdResponse
        """
        kwargs['_return_http_data_only'] = True
        return self.find_space_by_id_with_http_info(id, space_fields, expansions, user_fields, topic_fields, **kwargs)  # noqa: E501

    @validate_arguments
    def find_space_by_id_with_http_info(self, id : Annotated[constr(strict=True, regex=r'/^[a-zA-Z0-9]{1,13}$/'), Field(..., description="The ID of the Space to be retrieved.")], space_fields : Annotated[Optional[List[Literal['created_at', 'creator_id', 'ended_at', 'host_ids', 'id', 'invited_user_ids', 'is_ticketed', 'lang', 'participant_count', 'scheduled_start', 'speaker_ids', 'started_at', 'state', 'subscriber_count', 'title', 'topic_ids', 'updated_at']]], Field(description="A comma separated list of Space fields to display.", unique_items=True)] = None, expansions : Annotated[Optional[List[Literal['creator_id', 'host_ids', 'invited_user_ids', 'speaker_ids', 'topic_ids']]], Field(description="A comma separated list of fields to expand.", unique_items=True)] = None, user_fields : Annotated[Optional[List[Literal['created_at', 'description', 'entities', 'id', 'location', 'name', 'pinned_tweet_id', 'profile_image_url', 'protected', 'public_metrics', 'url', 'username', 'verified', 'withheld']]], Field(description="A comma separated list of User fields to display.", unique_items=True)] = None, topic_fields : Annotated[Optional[List[Literal['description', 'id', 'name']]], Field(description="A comma separated list of Topic fields to display.", unique_items=True)] = None, **kwargs):  # noqa: E501
        """Space lookup by Space ID  # noqa: E501

        Returns a variety of information about the Space specified by the requested ID  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.find_space_by_id_with_http_info(id, space_fields, expansions, user_fields, topic_fields, async_req=True)
        >>> result = thread.get()

        :param id: The ID of the Space to be retrieved. (required)
        :type id: str
        :param space_fields: A comma separated list of Space fields to display.
        :type space_fields: List[str]
        :param expansions: A comma separated list of fields to expand.
        :type expansions: List[str]
        :param user_fields: A comma separated list of User fields to display.
        :type user_fields: List[str]
        :param topic_fields: A comma separated list of Topic fields to display.
        :type topic_fields: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(Get2SpacesIdResponse, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'id',
            'space_fields',
            'expansions',
            'user_fields',
            'topic_fields'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in local_var_params['kwargs'].items():
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method find_space_by_id" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        collection_formats = {}

        path_params = {}
        if local_var_params['id']:
            path_params['id'] = local_var_params['id']

        query_params = []
        if local_var_params.get('space_fields') is not None:  # noqa: E501
            query_params.append(('space.fields', local_var_params['space_fields']))
            collection_formats['space.fields'] = 'csv'
        if local_var_params.get('expansions') is not None:  # noqa: E501
            query_params.append(('expansions', local_var_params['expansions']))
            collection_formats['expansions'] = 'csv'
        if local_var_params.get('user_fields') is not None:  # noqa: E501
            query_params.append(('user.fields', local_var_params['user_fields']))
            collection_formats['user.fields'] = 'csv'
        if local_var_params.get('topic_fields') is not None:  # noqa: E501
            query_params.append(('topic.fields', local_var_params['topic_fields']))
            collection_formats['topic.fields'] = 'csv'

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'application/problem+json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BearerToken', 'OAuth2UserToken']  # noqa: E501

        response_types_map = {
            200: "Get2SpacesIdResponse",
        }

        return self.api_client.call_api(
            '/2/spaces/{id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    @validate_arguments
    def find_spaces_by_creator_ids(self, user_ids : Annotated[List[constr(strict=True, regex=r'/^[0-9]{1,19}$/')], Field(..., description="The IDs of Users to search through.")], space_fields : Annotated[Optional[List[Literal['created_at', 'creator_id', 'ended_at', 'host_ids', 'id', 'invited_user_ids', 'is_ticketed', 'lang', 'participant_count', 'scheduled_start', 'speaker_ids', 'started_at', 'state', 'subscriber_count', 'title', 'topic_ids', 'updated_at']]], Field(description="A comma separated list of Space fields to display.", unique_items=True)] = None, expansions : Annotated[Optional[List[Literal['creator_id', 'host_ids', 'invited_user_ids', 'speaker_ids', 'topic_ids']]], Field(description="A comma separated list of fields to expand.", unique_items=True)] = None, user_fields : Annotated[Optional[List[Literal['created_at', 'description', 'entities', 'id', 'location', 'name', 'pinned_tweet_id', 'profile_image_url', 'protected', 'public_metrics', 'url', 'username', 'verified', 'withheld']]], Field(description="A comma separated list of User fields to display.", unique_items=True)] = None, topic_fields : Annotated[Optional[List[Literal['description', 'id', 'name']]], Field(description="A comma separated list of Topic fields to display.", unique_items=True)] = None, **kwargs) -> Get2SpacesByCreatorIdsResponse:  # noqa: E501
        """Space lookup by their creators  # noqa: E501

        Returns a variety of information about the Spaces created by the provided User IDs  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.find_spaces_by_creator_ids(user_ids, space_fields, expansions, user_fields, topic_fields, async_req=True)
        >>> result = thread.get()

        :param user_ids: The IDs of Users to search through. (required)
        :type user_ids: List[str]
        :param space_fields: A comma separated list of Space fields to display.
        :type space_fields: List[str]
        :param expansions: A comma separated list of fields to expand.
        :type expansions: List[str]
        :param user_fields: A comma separated list of User fields to display.
        :type user_fields: List[str]
        :param topic_fields: A comma separated list of Topic fields to display.
        :type topic_fields: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: Get2SpacesByCreatorIdsResponse
        """
        kwargs['_return_http_data_only'] = True
        return self.find_spaces_by_creator_ids_with_http_info(user_ids, space_fields, expansions, user_fields, topic_fields, **kwargs)  # noqa: E501

    @validate_arguments
    def find_spaces_by_creator_ids_with_http_info(self, user_ids : Annotated[List[constr(strict=True, regex=r'/^[0-9]{1,19}$/')], Field(..., description="The IDs of Users to search through.")], space_fields : Annotated[Optional[List[Literal['created_at', 'creator_id', 'ended_at', 'host_ids', 'id', 'invited_user_ids', 'is_ticketed', 'lang', 'participant_count', 'scheduled_start', 'speaker_ids', 'started_at', 'state', 'subscriber_count', 'title', 'topic_ids', 'updated_at']]], Field(description="A comma separated list of Space fields to display.", unique_items=True)] = None, expansions : Annotated[Optional[List[Literal['creator_id', 'host_ids', 'invited_user_ids', 'speaker_ids', 'topic_ids']]], Field(description="A comma separated list of fields to expand.", unique_items=True)] = None, user_fields : Annotated[Optional[List[Literal['created_at', 'description', 'entities', 'id', 'location', 'name', 'pinned_tweet_id', 'profile_image_url', 'protected', 'public_metrics', 'url', 'username', 'verified', 'withheld']]], Field(description="A comma separated list of User fields to display.", unique_items=True)] = None, topic_fields : Annotated[Optional[List[Literal['description', 'id', 'name']]], Field(description="A comma separated list of Topic fields to display.", unique_items=True)] = None, **kwargs):  # noqa: E501
        """Space lookup by their creators  # noqa: E501

        Returns a variety of information about the Spaces created by the provided User IDs  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.find_spaces_by_creator_ids_with_http_info(user_ids, space_fields, expansions, user_fields, topic_fields, async_req=True)
        >>> result = thread.get()

        :param user_ids: The IDs of Users to search through. (required)
        :type user_ids: List[str]
        :param space_fields: A comma separated list of Space fields to display.
        :type space_fields: List[str]
        :param expansions: A comma separated list of fields to expand.
        :type expansions: List[str]
        :param user_fields: A comma separated list of User fields to display.
        :type user_fields: List[str]
        :param topic_fields: A comma separated list of Topic fields to display.
        :type topic_fields: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(Get2SpacesByCreatorIdsResponse, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'user_ids',
            'space_fields',
            'expansions',
            'user_fields',
            'topic_fields'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in local_var_params['kwargs'].items():
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method find_spaces_by_creator_ids" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if local_var_params.get('user_ids') is not None:  # noqa: E501
            query_params.append(('user_ids', local_var_params['user_ids']))
            collection_formats['user_ids'] = 'multi'
        if local_var_params.get('space_fields') is not None:  # noqa: E501
            query_params.append(('space.fields', local_var_params['space_fields']))
            collection_formats['space.fields'] = 'csv'
        if local_var_params.get('expansions') is not None:  # noqa: E501
            query_params.append(('expansions', local_var_params['expansions']))
            collection_formats['expansions'] = 'csv'
        if local_var_params.get('user_fields') is not None:  # noqa: E501
            query_params.append(('user.fields', local_var_params['user_fields']))
            collection_formats['user.fields'] = 'csv'
        if local_var_params.get('topic_fields') is not None:  # noqa: E501
            query_params.append(('topic.fields', local_var_params['topic_fields']))
            collection_formats['topic.fields'] = 'csv'

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'application/problem+json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BearerToken', 'OAuth2UserToken']  # noqa: E501

        response_types_map = {
            200: "Get2SpacesByCreatorIdsResponse",
        }

        return self.api_client.call_api(
            '/2/spaces/by/creator_ids', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    @validate_arguments
    def find_spaces_by_ids(self, ids : Annotated[List[constr(strict=True, regex=r'/^[a-zA-Z0-9]{1,13}$/')], Field(..., description="The list of Space IDs to return.")], space_fields : Annotated[Optional[List[Literal['created_at', 'creator_id', 'ended_at', 'host_ids', 'id', 'invited_user_ids', 'is_ticketed', 'lang', 'participant_count', 'scheduled_start', 'speaker_ids', 'started_at', 'state', 'subscriber_count', 'title', 'topic_ids', 'updated_at']]], Field(description="A comma separated list of Space fields to display.", unique_items=True)] = None, expansions : Annotated[Optional[List[Literal['creator_id', 'host_ids', 'invited_user_ids', 'speaker_ids', 'topic_ids']]], Field(description="A comma separated list of fields to expand.", unique_items=True)] = None, user_fields : Annotated[Optional[List[Literal['created_at', 'description', 'entities', 'id', 'location', 'name', 'pinned_tweet_id', 'profile_image_url', 'protected', 'public_metrics', 'url', 'username', 'verified', 'withheld']]], Field(description="A comma separated list of User fields to display.", unique_items=True)] = None, topic_fields : Annotated[Optional[List[Literal['description', 'id', 'name']]], Field(description="A comma separated list of Topic fields to display.", unique_items=True)] = None, **kwargs) -> Get2SpacesResponse:  # noqa: E501
        """Space lookup up Space IDs  # noqa: E501

        Returns a variety of information about the Spaces specified by the requested IDs  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.find_spaces_by_ids(ids, space_fields, expansions, user_fields, topic_fields, async_req=True)
        >>> result = thread.get()

        :param ids: The list of Space IDs to return. (required)
        :type ids: List[str]
        :param space_fields: A comma separated list of Space fields to display.
        :type space_fields: List[str]
        :param expansions: A comma separated list of fields to expand.
        :type expansions: List[str]
        :param user_fields: A comma separated list of User fields to display.
        :type user_fields: List[str]
        :param topic_fields: A comma separated list of Topic fields to display.
        :type topic_fields: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: Get2SpacesResponse
        """
        kwargs['_return_http_data_only'] = True
        return self.find_spaces_by_ids_with_http_info(ids, space_fields, expansions, user_fields, topic_fields, **kwargs)  # noqa: E501

    @validate_arguments
    def find_spaces_by_ids_with_http_info(self, ids : Annotated[List[constr(strict=True, regex=r'/^[a-zA-Z0-9]{1,13}$/')], Field(..., description="The list of Space IDs to return.")], space_fields : Annotated[Optional[List[Literal['created_at', 'creator_id', 'ended_at', 'host_ids', 'id', 'invited_user_ids', 'is_ticketed', 'lang', 'participant_count', 'scheduled_start', 'speaker_ids', 'started_at', 'state', 'subscriber_count', 'title', 'topic_ids', 'updated_at']]], Field(description="A comma separated list of Space fields to display.", unique_items=True)] = None, expansions : Annotated[Optional[List[Literal['creator_id', 'host_ids', 'invited_user_ids', 'speaker_ids', 'topic_ids']]], Field(description="A comma separated list of fields to expand.", unique_items=True)] = None, user_fields : Annotated[Optional[List[Literal['created_at', 'description', 'entities', 'id', 'location', 'name', 'pinned_tweet_id', 'profile_image_url', 'protected', 'public_metrics', 'url', 'username', 'verified', 'withheld']]], Field(description="A comma separated list of User fields to display.", unique_items=True)] = None, topic_fields : Annotated[Optional[List[Literal['description', 'id', 'name']]], Field(description="A comma separated list of Topic fields to display.", unique_items=True)] = None, **kwargs):  # noqa: E501
        """Space lookup up Space IDs  # noqa: E501

        Returns a variety of information about the Spaces specified by the requested IDs  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.find_spaces_by_ids_with_http_info(ids, space_fields, expansions, user_fields, topic_fields, async_req=True)
        >>> result = thread.get()

        :param ids: The list of Space IDs to return. (required)
        :type ids: List[str]
        :param space_fields: A comma separated list of Space fields to display.
        :type space_fields: List[str]
        :param expansions: A comma separated list of fields to expand.
        :type expansions: List[str]
        :param user_fields: A comma separated list of User fields to display.
        :type user_fields: List[str]
        :param topic_fields: A comma separated list of Topic fields to display.
        :type topic_fields: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(Get2SpacesResponse, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'ids',
            'space_fields',
            'expansions',
            'user_fields',
            'topic_fields'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in local_var_params['kwargs'].items():
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method find_spaces_by_ids" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if local_var_params.get('ids') is not None:  # noqa: E501
            query_params.append(('ids', local_var_params['ids']))
            collection_formats['ids'] = 'multi'
        if local_var_params.get('space_fields') is not None:  # noqa: E501
            query_params.append(('space.fields', local_var_params['space_fields']))
            collection_formats['space.fields'] = 'csv'
        if local_var_params.get('expansions') is not None:  # noqa: E501
            query_params.append(('expansions', local_var_params['expansions']))
            collection_formats['expansions'] = 'csv'
        if local_var_params.get('user_fields') is not None:  # noqa: E501
            query_params.append(('user.fields', local_var_params['user_fields']))
            collection_formats['user.fields'] = 'csv'
        if local_var_params.get('topic_fields') is not None:  # noqa: E501
            query_params.append(('topic.fields', local_var_params['topic_fields']))
            collection_formats['topic.fields'] = 'csv'

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'application/problem+json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BearerToken', 'OAuth2UserToken']  # noqa: E501

        response_types_map = {
            200: "Get2SpacesResponse",
        }

        return self.api_client.call_api(
            '/2/spaces', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    @validate_arguments
    def search_spaces(self, query : Annotated[constr(strict=True, max_length=2048, min_length=1), Field(..., description="The search query.")], state : Annotated[Optional[StrictStr], Field(description="The state of Spaces to search for.")] = None, max_results : Annotated[Optional[conint(strict=True, ge=100, le=1)], Field(description="The number of results to return.")] = None, space_fields : Annotated[Optional[List[Literal['created_at', 'creator_id', 'ended_at', 'host_ids', 'id', 'invited_user_ids', 'is_ticketed', 'lang', 'participant_count', 'scheduled_start', 'speaker_ids', 'started_at', 'state', 'subscriber_count', 'title', 'topic_ids', 'updated_at']]], Field(description="A comma separated list of Space fields to display.", unique_items=True)] = None, expansions : Annotated[Optional[List[Literal['creator_id', 'host_ids', 'invited_user_ids', 'speaker_ids', 'topic_ids']]], Field(description="A comma separated list of fields to expand.", unique_items=True)] = None, user_fields : Annotated[Optional[List[Literal['created_at', 'description', 'entities', 'id', 'location', 'name', 'pinned_tweet_id', 'profile_image_url', 'protected', 'public_metrics', 'url', 'username', 'verified', 'withheld']]], Field(description="A comma separated list of User fields to display.", unique_items=True)] = None, topic_fields : Annotated[Optional[List[Literal['description', 'id', 'name']]], Field(description="A comma separated list of Topic fields to display.", unique_items=True)] = None, **kwargs) -> Get2SpacesSearchResponse:  # noqa: E501
        """Search for Spaces  # noqa: E501

        Returns Spaces that match the provided query.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.search_spaces(query, state, max_results, space_fields, expansions, user_fields, topic_fields, async_req=True)
        >>> result = thread.get()

        :param query: The search query. (required)
        :type query: str
        :param state: The state of Spaces to search for.
        :type state: str
        :param max_results: The number of results to return.
        :type max_results: int
        :param space_fields: A comma separated list of Space fields to display.
        :type space_fields: List[str]
        :param expansions: A comma separated list of fields to expand.
        :type expansions: List[str]
        :param user_fields: A comma separated list of User fields to display.
        :type user_fields: List[str]
        :param topic_fields: A comma separated list of Topic fields to display.
        :type topic_fields: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: Get2SpacesSearchResponse
        """
        kwargs['_return_http_data_only'] = True
        return self.search_spaces_with_http_info(query, state, max_results, space_fields, expansions, user_fields, topic_fields, **kwargs)  # noqa: E501

    @validate_arguments
    def search_spaces_with_http_info(self, query : Annotated[constr(strict=True, max_length=2048, min_length=1), Field(..., description="The search query.")], state : Annotated[Optional[StrictStr], Field(description="The state of Spaces to search for.")] = None, max_results : Annotated[Optional[conint(strict=True, ge=100, le=1)], Field(description="The number of results to return.")] = None, space_fields : Annotated[Optional[List[Literal['created_at', 'creator_id', 'ended_at', 'host_ids', 'id', 'invited_user_ids', 'is_ticketed', 'lang', 'participant_count', 'scheduled_start', 'speaker_ids', 'started_at', 'state', 'subscriber_count', 'title', 'topic_ids', 'updated_at']]], Field(description="A comma separated list of Space fields to display.", unique_items=True)] = None, expansions : Annotated[Optional[List[Literal['creator_id', 'host_ids', 'invited_user_ids', 'speaker_ids', 'topic_ids']]], Field(description="A comma separated list of fields to expand.", unique_items=True)] = None, user_fields : Annotated[Optional[List[Literal['created_at', 'description', 'entities', 'id', 'location', 'name', 'pinned_tweet_id', 'profile_image_url', 'protected', 'public_metrics', 'url', 'username', 'verified', 'withheld']]], Field(description="A comma separated list of User fields to display.", unique_items=True)] = None, topic_fields : Annotated[Optional[List[Literal['description', 'id', 'name']]], Field(description="A comma separated list of Topic fields to display.", unique_items=True)] = None, **kwargs):  # noqa: E501
        """Search for Spaces  # noqa: E501

        Returns Spaces that match the provided query.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.search_spaces_with_http_info(query, state, max_results, space_fields, expansions, user_fields, topic_fields, async_req=True)
        >>> result = thread.get()

        :param query: The search query. (required)
        :type query: str
        :param state: The state of Spaces to search for.
        :type state: str
        :param max_results: The number of results to return.
        :type max_results: int
        :param space_fields: A comma separated list of Space fields to display.
        :type space_fields: List[str]
        :param expansions: A comma separated list of fields to expand.
        :type expansions: List[str]
        :param user_fields: A comma separated list of User fields to display.
        :type user_fields: List[str]
        :param topic_fields: A comma separated list of Topic fields to display.
        :type topic_fields: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(Get2SpacesSearchResponse, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'query',
            'state',
            'max_results',
            'space_fields',
            'expansions',
            'user_fields',
            'topic_fields'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in local_var_params['kwargs'].items():
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method search_spaces" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if local_var_params.get('query') is not None:  # noqa: E501
            query_params.append(('query', local_var_params['query']))
        if local_var_params.get('state') is not None:  # noqa: E501
            query_params.append(('state', local_var_params['state']))
        if local_var_params.get('max_results') is not None:  # noqa: E501
            query_params.append(('max_results', local_var_params['max_results']))
        if local_var_params.get('space_fields') is not None:  # noqa: E501
            query_params.append(('space.fields', local_var_params['space_fields']))
            collection_formats['space.fields'] = 'csv'
        if local_var_params.get('expansions') is not None:  # noqa: E501
            query_params.append(('expansions', local_var_params['expansions']))
            collection_formats['expansions'] = 'csv'
        if local_var_params.get('user_fields') is not None:  # noqa: E501
            query_params.append(('user.fields', local_var_params['user_fields']))
            collection_formats['user.fields'] = 'csv'
        if local_var_params.get('topic_fields') is not None:  # noqa: E501
            query_params.append(('topic.fields', local_var_params['topic_fields']))
            collection_formats['topic.fields'] = 'csv'

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'application/problem+json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BearerToken', 'OAuth2UserToken']  # noqa: E501

        response_types_map = {
            200: "Get2SpacesSearchResponse",
        }

        return self.api_client.call_api(
            '/2/spaces/search', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    @validate_arguments
    def space_buyers(self, id : Annotated[constr(strict=True, regex=r'/^[a-zA-Z0-9]{1,13}$/'), Field(..., description="The ID of the Space to be retrieved.")], pagination_token : Annotated[Optional[constr(strict=True, min_length=16)], Field(description="This parameter is used to get a specified 'page' of results.")] = None, max_results : Annotated[Optional[conint(strict=True, ge=100, le=1)], Field(description="The maximum number of results.")] = None, user_fields : Annotated[Optional[List[Literal['created_at', 'description', 'entities', 'id', 'location', 'name', 'pinned_tweet_id', 'profile_image_url', 'protected', 'public_metrics', 'url', 'username', 'verified', 'withheld']]], Field(description="A comma separated list of User fields to display.", unique_items=True)] = None, expansions : Annotated[Optional[List[Literal['pinned_tweet_id']]], Field(description="A comma separated list of fields to expand.", unique_items=True)] = None, tweet_fields : Annotated[Optional[List[Literal['attachments', 'author_id', 'context_annotations', 'conversation_id', 'created_at', 'entities', 'geo', 'id', 'in_reply_to_user_id', 'lang', 'non_public_metrics', 'organic_metrics', 'possibly_sensitive', 'promoted_metrics', 'public_metrics', 'referenced_tweets', 'reply_settings', 'source', 'text', 'withheld']]], Field(description="A comma separated list of Tweet fields to display.", unique_items=True)] = None, **kwargs) -> Get2SpacesIdBuyersResponse:  # noqa: E501
        """Retrieve the list of Users who purchased a ticket to the given space  # noqa: E501

        Retrieves the list of Users who purchased a ticket to the given space  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.space_buyers(id, pagination_token, max_results, user_fields, expansions, tweet_fields, async_req=True)
        >>> result = thread.get()

        :param id: The ID of the Space to be retrieved. (required)
        :type id: str
        :param pagination_token: This parameter is used to get a specified 'page' of results.
        :type pagination_token: str
        :param max_results: The maximum number of results.
        :type max_results: int
        :param user_fields: A comma separated list of User fields to display.
        :type user_fields: List[str]
        :param expansions: A comma separated list of fields to expand.
        :type expansions: List[str]
        :param tweet_fields: A comma separated list of Tweet fields to display.
        :type tweet_fields: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: Get2SpacesIdBuyersResponse
        """
        kwargs['_return_http_data_only'] = True
        return self.space_buyers_with_http_info(id, pagination_token, max_results, user_fields, expansions, tweet_fields, **kwargs)  # noqa: E501

    @validate_arguments
    def space_buyers_with_http_info(self, id : Annotated[constr(strict=True, regex=r'/^[a-zA-Z0-9]{1,13}$/'), Field(..., description="The ID of the Space to be retrieved.")], pagination_token : Annotated[Optional[constr(strict=True, min_length=16)], Field(description="This parameter is used to get a specified 'page' of results.")] = None, max_results : Annotated[Optional[conint(strict=True, ge=100, le=1)], Field(description="The maximum number of results.")] = None, user_fields : Annotated[Optional[List[Literal['created_at', 'description', 'entities', 'id', 'location', 'name', 'pinned_tweet_id', 'profile_image_url', 'protected', 'public_metrics', 'url', 'username', 'verified', 'withheld']]], Field(description="A comma separated list of User fields to display.", unique_items=True)] = None, expansions : Annotated[Optional[List[Literal['pinned_tweet_id']]], Field(description="A comma separated list of fields to expand.", unique_items=True)] = None, tweet_fields : Annotated[Optional[List[Literal['attachments', 'author_id', 'context_annotations', 'conversation_id', 'created_at', 'entities', 'geo', 'id', 'in_reply_to_user_id', 'lang', 'non_public_metrics', 'organic_metrics', 'possibly_sensitive', 'promoted_metrics', 'public_metrics', 'referenced_tweets', 'reply_settings', 'source', 'text', 'withheld']]], Field(description="A comma separated list of Tweet fields to display.", unique_items=True)] = None, **kwargs):  # noqa: E501
        """Retrieve the list of Users who purchased a ticket to the given space  # noqa: E501

        Retrieves the list of Users who purchased a ticket to the given space  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.space_buyers_with_http_info(id, pagination_token, max_results, user_fields, expansions, tweet_fields, async_req=True)
        >>> result = thread.get()

        :param id: The ID of the Space to be retrieved. (required)
        :type id: str
        :param pagination_token: This parameter is used to get a specified 'page' of results.
        :type pagination_token: str
        :param max_results: The maximum number of results.
        :type max_results: int
        :param user_fields: A comma separated list of User fields to display.
        :type user_fields: List[str]
        :param expansions: A comma separated list of fields to expand.
        :type expansions: List[str]
        :param tweet_fields: A comma separated list of Tweet fields to display.
        :type tweet_fields: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(Get2SpacesIdBuyersResponse, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'id',
            'pagination_token',
            'max_results',
            'user_fields',
            'expansions',
            'tweet_fields'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in local_var_params['kwargs'].items():
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method space_buyers" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        collection_formats = {}

        path_params = {}
        if local_var_params['id']:
            path_params['id'] = local_var_params['id']

        query_params = []
        if local_var_params.get('pagination_token') is not None:  # noqa: E501
            query_params.append(('pagination_token', local_var_params['pagination_token']))
        if local_var_params.get('max_results') is not None:  # noqa: E501
            query_params.append(('max_results', local_var_params['max_results']))
        if local_var_params.get('user_fields') is not None:  # noqa: E501
            query_params.append(('user.fields', local_var_params['user_fields']))
            collection_formats['user.fields'] = 'csv'
        if local_var_params.get('expansions') is not None:  # noqa: E501
            query_params.append(('expansions', local_var_params['expansions']))
            collection_formats['expansions'] = 'csv'
        if local_var_params.get('tweet_fields') is not None:  # noqa: E501
            query_params.append(('tweet.fields', local_var_params['tweet_fields']))
            collection_formats['tweet.fields'] = 'csv'

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'application/problem+json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['OAuth2UserToken']  # noqa: E501

        response_types_map = {
            200: "Get2SpacesIdBuyersResponse",
        }

        return self.api_client.call_api(
            '/2/spaces/{id}/buyers', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    @validate_arguments
    def space_tweets(self, id : Annotated[constr(strict=True, regex=r'/^[a-zA-Z0-9]{1,13}$/'), Field(..., description="The ID of the Space to be retrieved.")], max_results : Annotated[Optional[conint(strict=True, ge=100, le=1)], Field(description="The number of Tweets to fetch from the provided space. If not provided, the value will default to the maximum of 100.")] = None, tweet_fields : Annotated[Optional[List[Literal['attachments', 'author_id', 'context_annotations', 'conversation_id', 'created_at', 'entities', 'geo', 'id', 'in_reply_to_user_id', 'lang', 'non_public_metrics', 'organic_metrics', 'possibly_sensitive', 'promoted_metrics', 'public_metrics', 'referenced_tweets', 'reply_settings', 'source', 'text', 'withheld']]], Field(description="A comma separated list of Tweet fields to display.", unique_items=True)] = None, expansions : Annotated[Optional[List[Literal['attachments.media_keys', 'attachments.poll_ids', 'author_id', 'entities.mentions.username', 'geo.place_id', 'in_reply_to_user_id', 'referenced_tweets.id', 'referenced_tweets.id.author_id']]], Field(description="A comma separated list of fields to expand.", unique_items=True)] = None, media_fields : Annotated[Optional[List[Literal['alt_text', 'duration_ms', 'height', 'media_key', 'non_public_metrics', 'organic_metrics', 'preview_image_url', 'promoted_metrics', 'public_metrics', 'type', 'url', 'variants', 'width']]], Field(description="A comma separated list of Media fields to display.", unique_items=True)] = None, poll_fields : Annotated[Optional[List[Literal['duration_minutes', 'end_datetime', 'id', 'options', 'voting_status']]], Field(description="A comma separated list of Poll fields to display.", unique_items=True)] = None, user_fields : Annotated[Optional[List[Literal['created_at', 'description', 'entities', 'id', 'location', 'name', 'pinned_tweet_id', 'profile_image_url', 'protected', 'public_metrics', 'url', 'username', 'verified', 'withheld']]], Field(description="A comma separated list of User fields to display.", unique_items=True)] = None, place_fields : Annotated[Optional[List[Literal['contained_within', 'country', 'country_code', 'full_name', 'geo', 'id', 'name', 'place_type']]], Field(description="A comma separated list of Place fields to display.", unique_items=True)] = None, **kwargs) -> Get2SpacesIdTweetsResponse:  # noqa: E501
        """Retrieve Tweets from a Space.  # noqa: E501

        Retrieves Tweets shared in the specified Space.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.space_tweets(id, max_results, tweet_fields, expansions, media_fields, poll_fields, user_fields, place_fields, async_req=True)
        >>> result = thread.get()

        :param id: The ID of the Space to be retrieved. (required)
        :type id: str
        :param max_results: The number of Tweets to fetch from the provided space. If not provided, the value will default to the maximum of 100.
        :type max_results: int
        :param tweet_fields: A comma separated list of Tweet fields to display.
        :type tweet_fields: List[str]
        :param expansions: A comma separated list of fields to expand.
        :type expansions: List[str]
        :param media_fields: A comma separated list of Media fields to display.
        :type media_fields: List[str]
        :param poll_fields: A comma separated list of Poll fields to display.
        :type poll_fields: List[str]
        :param user_fields: A comma separated list of User fields to display.
        :type user_fields: List[str]
        :param place_fields: A comma separated list of Place fields to display.
        :type place_fields: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: Get2SpacesIdTweetsResponse
        """
        kwargs['_return_http_data_only'] = True
        return self.space_tweets_with_http_info(id, max_results, tweet_fields, expansions, media_fields, poll_fields, user_fields, place_fields, **kwargs)  # noqa: E501

    @validate_arguments
    def space_tweets_with_http_info(self, id : Annotated[constr(strict=True, regex=r'/^[a-zA-Z0-9]{1,13}$/'), Field(..., description="The ID of the Space to be retrieved.")], max_results : Annotated[Optional[conint(strict=True, ge=100, le=1)], Field(description="The number of Tweets to fetch from the provided space. If not provided, the value will default to the maximum of 100.")] = None, tweet_fields : Annotated[Optional[List[Literal['attachments', 'author_id', 'context_annotations', 'conversation_id', 'created_at', 'entities', 'geo', 'id', 'in_reply_to_user_id', 'lang', 'non_public_metrics', 'organic_metrics', 'possibly_sensitive', 'promoted_metrics', 'public_metrics', 'referenced_tweets', 'reply_settings', 'source', 'text', 'withheld']]], Field(description="A comma separated list of Tweet fields to display.", unique_items=True)] = None, expansions : Annotated[Optional[List[Literal['attachments.media_keys', 'attachments.poll_ids', 'author_id', 'entities.mentions.username', 'geo.place_id', 'in_reply_to_user_id', 'referenced_tweets.id', 'referenced_tweets.id.author_id']]], Field(description="A comma separated list of fields to expand.", unique_items=True)] = None, media_fields : Annotated[Optional[List[Literal['alt_text', 'duration_ms', 'height', 'media_key', 'non_public_metrics', 'organic_metrics', 'preview_image_url', 'promoted_metrics', 'public_metrics', 'type', 'url', 'variants', 'width']]], Field(description="A comma separated list of Media fields to display.", unique_items=True)] = None, poll_fields : Annotated[Optional[List[Literal['duration_minutes', 'end_datetime', 'id', 'options', 'voting_status']]], Field(description="A comma separated list of Poll fields to display.", unique_items=True)] = None, user_fields : Annotated[Optional[List[Literal['created_at', 'description', 'entities', 'id', 'location', 'name', 'pinned_tweet_id', 'profile_image_url', 'protected', 'public_metrics', 'url', 'username', 'verified', 'withheld']]], Field(description="A comma separated list of User fields to display.", unique_items=True)] = None, place_fields : Annotated[Optional[List[Literal['contained_within', 'country', 'country_code', 'full_name', 'geo', 'id', 'name', 'place_type']]], Field(description="A comma separated list of Place fields to display.", unique_items=True)] = None, **kwargs):  # noqa: E501
        """Retrieve Tweets from a Space.  # noqa: E501

        Retrieves Tweets shared in the specified Space.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.space_tweets_with_http_info(id, max_results, tweet_fields, expansions, media_fields, poll_fields, user_fields, place_fields, async_req=True)
        >>> result = thread.get()

        :param id: The ID of the Space to be retrieved. (required)
        :type id: str
        :param max_results: The number of Tweets to fetch from the provided space. If not provided, the value will default to the maximum of 100.
        :type max_results: int
        :param tweet_fields: A comma separated list of Tweet fields to display.
        :type tweet_fields: List[str]
        :param expansions: A comma separated list of fields to expand.
        :type expansions: List[str]
        :param media_fields: A comma separated list of Media fields to display.
        :type media_fields: List[str]
        :param poll_fields: A comma separated list of Poll fields to display.
        :type poll_fields: List[str]
        :param user_fields: A comma separated list of User fields to display.
        :type user_fields: List[str]
        :param place_fields: A comma separated list of Place fields to display.
        :type place_fields: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(Get2SpacesIdTweetsResponse, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'id',
            'max_results',
            'tweet_fields',
            'expansions',
            'media_fields',
            'poll_fields',
            'user_fields',
            'place_fields'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in local_var_params['kwargs'].items():
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method space_tweets" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        collection_formats = {}

        path_params = {}
        if local_var_params['id']:
            path_params['id'] = local_var_params['id']

        query_params = []
        if local_var_params.get('max_results') is not None:  # noqa: E501
            query_params.append(('max_results', local_var_params['max_results']))
        if local_var_params.get('tweet_fields') is not None:  # noqa: E501
            query_params.append(('tweet.fields', local_var_params['tweet_fields']))
            collection_formats['tweet.fields'] = 'csv'
        if local_var_params.get('expansions') is not None:  # noqa: E501
            query_params.append(('expansions', local_var_params['expansions']))
            collection_formats['expansions'] = 'csv'
        if local_var_params.get('media_fields') is not None:  # noqa: E501
            query_params.append(('media.fields', local_var_params['media_fields']))
            collection_formats['media.fields'] = 'csv'
        if local_var_params.get('poll_fields') is not None:  # noqa: E501
            query_params.append(('poll.fields', local_var_params['poll_fields']))
            collection_formats['poll.fields'] = 'csv'
        if local_var_params.get('user_fields') is not None:  # noqa: E501
            query_params.append(('user.fields', local_var_params['user_fields']))
            collection_formats['user.fields'] = 'csv'
        if local_var_params.get('place_fields') is not None:  # noqa: E501
            query_params.append(('place.fields', local_var_params['place_fields']))
            collection_formats['place.fields'] = 'csv'

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'application/problem+json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BearerToken', 'OAuth2UserToken']  # noqa: E501

        response_types_map = {
            200: "Get2SpacesIdTweetsResponse",
        }

        return self.api_client.call_api(
            '/2/spaces/{id}/tweets', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))
