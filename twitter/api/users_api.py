# coding: utf-8

"""
    Twitter API v2

    Twitter API v2 available endpoints  # noqa: E501

    The version of the OpenAPI document: 2.49
    Generated by: https://openapi-generator.tech
"""


from __future__ import absolute_import

import re  # noqa: F401

from pydantic import validate_arguments, ValidationError
from typing_extensions import Annotated

from pydantic import Field, StrictStr, conint, constr

from typing import List, Literal, Optional

from twitter import models
from twitter.models import BlockUserMutationResponse, BlockUserRequest, Get2ListsIdFollowersResponse, Get2ListsIdMembersResponse, Get2TweetsIdLikingUsersResponse, Get2TweetsIdRetweetedByResponse, Get2UsersByResponse, Get2UsersByUsernameUsernameResponse, Get2UsersIdBlockingResponse, Get2UsersIdFollowersResponse, Get2UsersIdFollowingResponse, Get2UsersIdMutingResponse, Get2UsersIdResponse, Get2UsersMeResponse, Get2UsersResponse, MuteUserMutationResponse, MuteUserRequest, UsersFollowingCreateRequest, UsersFollowingCreateResponse, UsersFollowingDeleteResponse

from twitter.api_client import ApiClient
from twitter.exceptions import (  # noqa: F401
    ApiTypeError,
    ApiValueError
)


class UsersApi(object):
    """NOTE: This class is auto generated by OpenAPI Generator
    Ref: https://openapi-generator.tech

    Do not edit the class manually.
    """

    def __init__(self, api_client=None):
        if api_client is None:
            api_client = ApiClient()
        self.api_client = api_client

    @validate_arguments
    def find_my_user(self, user_fields : Annotated[Optional[List[Literal['created_at', 'description', 'entities', 'id', 'location', 'name', 'pinned_tweet_id', 'profile_image_url', 'protected', 'public_metrics', 'url', 'username', 'verified', 'withheld']]], Field(description="A comma separated list of User fields to display.", unique_items=True)] = None, expansions : Annotated[Optional[List[Literal['pinned_tweet_id']]], Field(description="A comma separated list of fields to expand.", unique_items=True)] = None, tweet_fields : Annotated[Optional[List[Literal['attachments', 'author_id', 'context_annotations', 'conversation_id', 'created_at', 'entities', 'geo', 'id', 'in_reply_to_user_id', 'lang', 'non_public_metrics', 'organic_metrics', 'possibly_sensitive', 'promoted_metrics', 'public_metrics', 'referenced_tweets', 'reply_settings', 'source', 'text', 'withheld']]], Field(description="A comma separated list of Tweet fields to display.", unique_items=True)] = None, **kwargs) -> Get2UsersMeResponse:  # noqa: E501
        """User lookup me  # noqa: E501

        This endpoint returns information about the requesting User.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.find_my_user(user_fields, expansions, tweet_fields, async_req=True)
        >>> result = thread.get()

        :param user_fields: A comma separated list of User fields to display.
        :type user_fields: List[str]
        :param expansions: A comma separated list of fields to expand.
        :type expansions: List[str]
        :param tweet_fields: A comma separated list of Tweet fields to display.
        :type tweet_fields: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: Get2UsersMeResponse
        """
        kwargs['_return_http_data_only'] = True
        return self.find_my_user_with_http_info(user_fields, expansions, tweet_fields, **kwargs)  # noqa: E501

    @validate_arguments
    def find_my_user_with_http_info(self, user_fields : Annotated[Optional[List[Literal['created_at', 'description', 'entities', 'id', 'location', 'name', 'pinned_tweet_id', 'profile_image_url', 'protected', 'public_metrics', 'url', 'username', 'verified', 'withheld']]], Field(description="A comma separated list of User fields to display.", unique_items=True)] = None, expansions : Annotated[Optional[List[Literal['pinned_tweet_id']]], Field(description="A comma separated list of fields to expand.", unique_items=True)] = None, tweet_fields : Annotated[Optional[List[Literal['attachments', 'author_id', 'context_annotations', 'conversation_id', 'created_at', 'entities', 'geo', 'id', 'in_reply_to_user_id', 'lang', 'non_public_metrics', 'organic_metrics', 'possibly_sensitive', 'promoted_metrics', 'public_metrics', 'referenced_tweets', 'reply_settings', 'source', 'text', 'withheld']]], Field(description="A comma separated list of Tweet fields to display.", unique_items=True)] = None, **kwargs):  # noqa: E501
        """User lookup me  # noqa: E501

        This endpoint returns information about the requesting User.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.find_my_user_with_http_info(user_fields, expansions, tweet_fields, async_req=True)
        >>> result = thread.get()

        :param user_fields: A comma separated list of User fields to display.
        :type user_fields: List[str]
        :param expansions: A comma separated list of fields to expand.
        :type expansions: List[str]
        :param tweet_fields: A comma separated list of Tweet fields to display.
        :type tweet_fields: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(Get2UsersMeResponse, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'user_fields',
            'expansions',
            'tweet_fields'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in local_var_params['kwargs'].items():
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method find_my_user" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if local_var_params.get('user_fields') is not None:  # noqa: E501
            query_params.append(('user.fields', local_var_params['user_fields']))
            collection_formats['user.fields'] = 'csv'
        if local_var_params.get('expansions') is not None:  # noqa: E501
            query_params.append(('expansions', local_var_params['expansions']))
            collection_formats['expansions'] = 'csv'
        if local_var_params.get('tweet_fields') is not None:  # noqa: E501
            query_params.append(('tweet.fields', local_var_params['tweet_fields']))
            collection_formats['tweet.fields'] = 'csv'

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'application/problem+json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['OAuth2UserToken', 'UserToken']  # noqa: E501

        response_types_map = {
            200: "Get2UsersMeResponse",
        }

        return self.api_client.call_api(
            '/2/users/me', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    @validate_arguments
    def find_user_by_id(self, id : Annotated[constr(strict=True, regex=r'/^[0-9]{1,19}$/'), Field(..., description="The ID of the User to lookup.")], user_fields : Annotated[Optional[List[Literal['created_at', 'description', 'entities', 'id', 'location', 'name', 'pinned_tweet_id', 'profile_image_url', 'protected', 'public_metrics', 'url', 'username', 'verified', 'withheld']]], Field(description="A comma separated list of User fields to display.", unique_items=True)] = None, expansions : Annotated[Optional[List[Literal['pinned_tweet_id']]], Field(description="A comma separated list of fields to expand.", unique_items=True)] = None, tweet_fields : Annotated[Optional[List[Literal['attachments', 'author_id', 'context_annotations', 'conversation_id', 'created_at', 'entities', 'geo', 'id', 'in_reply_to_user_id', 'lang', 'non_public_metrics', 'organic_metrics', 'possibly_sensitive', 'promoted_metrics', 'public_metrics', 'referenced_tweets', 'reply_settings', 'source', 'text', 'withheld']]], Field(description="A comma separated list of Tweet fields to display.", unique_items=True)] = None, **kwargs) -> Get2UsersIdResponse:  # noqa: E501
        """User lookup by ID  # noqa: E501

        This endpoint returns information about a User. Specify User by ID.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.find_user_by_id(id, user_fields, expansions, tweet_fields, async_req=True)
        >>> result = thread.get()

        :param id: The ID of the User to lookup. (required)
        :type id: str
        :param user_fields: A comma separated list of User fields to display.
        :type user_fields: List[str]
        :param expansions: A comma separated list of fields to expand.
        :type expansions: List[str]
        :param tweet_fields: A comma separated list of Tweet fields to display.
        :type tweet_fields: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: Get2UsersIdResponse
        """
        kwargs['_return_http_data_only'] = True
        return self.find_user_by_id_with_http_info(id, user_fields, expansions, tweet_fields, **kwargs)  # noqa: E501

    @validate_arguments
    def find_user_by_id_with_http_info(self, id : Annotated[constr(strict=True, regex=r'/^[0-9]{1,19}$/'), Field(..., description="The ID of the User to lookup.")], user_fields : Annotated[Optional[List[Literal['created_at', 'description', 'entities', 'id', 'location', 'name', 'pinned_tweet_id', 'profile_image_url', 'protected', 'public_metrics', 'url', 'username', 'verified', 'withheld']]], Field(description="A comma separated list of User fields to display.", unique_items=True)] = None, expansions : Annotated[Optional[List[Literal['pinned_tweet_id']]], Field(description="A comma separated list of fields to expand.", unique_items=True)] = None, tweet_fields : Annotated[Optional[List[Literal['attachments', 'author_id', 'context_annotations', 'conversation_id', 'created_at', 'entities', 'geo', 'id', 'in_reply_to_user_id', 'lang', 'non_public_metrics', 'organic_metrics', 'possibly_sensitive', 'promoted_metrics', 'public_metrics', 'referenced_tweets', 'reply_settings', 'source', 'text', 'withheld']]], Field(description="A comma separated list of Tweet fields to display.", unique_items=True)] = None, **kwargs):  # noqa: E501
        """User lookup by ID  # noqa: E501

        This endpoint returns information about a User. Specify User by ID.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.find_user_by_id_with_http_info(id, user_fields, expansions, tweet_fields, async_req=True)
        >>> result = thread.get()

        :param id: The ID of the User to lookup. (required)
        :type id: str
        :param user_fields: A comma separated list of User fields to display.
        :type user_fields: List[str]
        :param expansions: A comma separated list of fields to expand.
        :type expansions: List[str]
        :param tweet_fields: A comma separated list of Tweet fields to display.
        :type tweet_fields: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(Get2UsersIdResponse, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'id',
            'user_fields',
            'expansions',
            'tweet_fields'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in local_var_params['kwargs'].items():
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method find_user_by_id" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        collection_formats = {}

        path_params = {}
        if local_var_params['id']:
            path_params['id'] = local_var_params['id']

        query_params = []
        if local_var_params.get('user_fields') is not None:  # noqa: E501
            query_params.append(('user.fields', local_var_params['user_fields']))
            collection_formats['user.fields'] = 'csv'
        if local_var_params.get('expansions') is not None:  # noqa: E501
            query_params.append(('expansions', local_var_params['expansions']))
            collection_formats['expansions'] = 'csv'
        if local_var_params.get('tweet_fields') is not None:  # noqa: E501
            query_params.append(('tweet.fields', local_var_params['tweet_fields']))
            collection_formats['tweet.fields'] = 'csv'

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'application/problem+json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BearerToken', 'OAuth2UserToken', 'UserToken']  # noqa: E501

        response_types_map = {
            200: "Get2UsersIdResponse",
        }

        return self.api_client.call_api(
            '/2/users/{id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    @validate_arguments
    def find_user_by_username(self, username : Annotated[constr(strict=True, regex=r'/^[A-Za-z0-9_]{1,15}$/'), Field(..., description="A username.")], user_fields : Annotated[Optional[List[Literal['created_at', 'description', 'entities', 'id', 'location', 'name', 'pinned_tweet_id', 'profile_image_url', 'protected', 'public_metrics', 'url', 'username', 'verified', 'withheld']]], Field(description="A comma separated list of User fields to display.", unique_items=True)] = None, expansions : Annotated[Optional[List[Literal['pinned_tweet_id']]], Field(description="A comma separated list of fields to expand.", unique_items=True)] = None, tweet_fields : Annotated[Optional[List[Literal['attachments', 'author_id', 'context_annotations', 'conversation_id', 'created_at', 'entities', 'geo', 'id', 'in_reply_to_user_id', 'lang', 'non_public_metrics', 'organic_metrics', 'possibly_sensitive', 'promoted_metrics', 'public_metrics', 'referenced_tweets', 'reply_settings', 'source', 'text', 'withheld']]], Field(description="A comma separated list of Tweet fields to display.", unique_items=True)] = None, **kwargs) -> Get2UsersByUsernameUsernameResponse:  # noqa: E501
        """User lookup by username  # noqa: E501

        This endpoint returns information about a User. Specify User by username.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.find_user_by_username(username, user_fields, expansions, tweet_fields, async_req=True)
        >>> result = thread.get()

        :param username: A username. (required)
        :type username: str
        :param user_fields: A comma separated list of User fields to display.
        :type user_fields: List[str]
        :param expansions: A comma separated list of fields to expand.
        :type expansions: List[str]
        :param tweet_fields: A comma separated list of Tweet fields to display.
        :type tweet_fields: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: Get2UsersByUsernameUsernameResponse
        """
        kwargs['_return_http_data_only'] = True
        return self.find_user_by_username_with_http_info(username, user_fields, expansions, tweet_fields, **kwargs)  # noqa: E501

    @validate_arguments
    def find_user_by_username_with_http_info(self, username : Annotated[constr(strict=True, regex=r'/^[A-Za-z0-9_]{1,15}$/'), Field(..., description="A username.")], user_fields : Annotated[Optional[List[Literal['created_at', 'description', 'entities', 'id', 'location', 'name', 'pinned_tweet_id', 'profile_image_url', 'protected', 'public_metrics', 'url', 'username', 'verified', 'withheld']]], Field(description="A comma separated list of User fields to display.", unique_items=True)] = None, expansions : Annotated[Optional[List[Literal['pinned_tweet_id']]], Field(description="A comma separated list of fields to expand.", unique_items=True)] = None, tweet_fields : Annotated[Optional[List[Literal['attachments', 'author_id', 'context_annotations', 'conversation_id', 'created_at', 'entities', 'geo', 'id', 'in_reply_to_user_id', 'lang', 'non_public_metrics', 'organic_metrics', 'possibly_sensitive', 'promoted_metrics', 'public_metrics', 'referenced_tweets', 'reply_settings', 'source', 'text', 'withheld']]], Field(description="A comma separated list of Tweet fields to display.", unique_items=True)] = None, **kwargs):  # noqa: E501
        """User lookup by username  # noqa: E501

        This endpoint returns information about a User. Specify User by username.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.find_user_by_username_with_http_info(username, user_fields, expansions, tweet_fields, async_req=True)
        >>> result = thread.get()

        :param username: A username. (required)
        :type username: str
        :param user_fields: A comma separated list of User fields to display.
        :type user_fields: List[str]
        :param expansions: A comma separated list of fields to expand.
        :type expansions: List[str]
        :param tweet_fields: A comma separated list of Tweet fields to display.
        :type tweet_fields: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(Get2UsersByUsernameUsernameResponse, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'username',
            'user_fields',
            'expansions',
            'tweet_fields'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in local_var_params['kwargs'].items():
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method find_user_by_username" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        collection_formats = {}

        path_params = {}
        if local_var_params['username']:
            path_params['username'] = local_var_params['username']

        query_params = []
        if local_var_params.get('user_fields') is not None:  # noqa: E501
            query_params.append(('user.fields', local_var_params['user_fields']))
            collection_formats['user.fields'] = 'csv'
        if local_var_params.get('expansions') is not None:  # noqa: E501
            query_params.append(('expansions', local_var_params['expansions']))
            collection_formats['expansions'] = 'csv'
        if local_var_params.get('tweet_fields') is not None:  # noqa: E501
            query_params.append(('tweet.fields', local_var_params['tweet_fields']))
            collection_formats['tweet.fields'] = 'csv'

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'application/problem+json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BearerToken', 'OAuth2UserToken', 'UserToken']  # noqa: E501

        response_types_map = {
            200: "Get2UsersByUsernameUsernameResponse",
        }

        return self.api_client.call_api(
            '/2/users/by/username/{username}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    @validate_arguments
    def find_users_by_id(self, ids : Annotated[List[constr(strict=True, regex=r'/^[0-9]{1,19}$/')], Field(..., description="A list of User IDs, comma-separated. You can specify up to 100 IDs.")], user_fields : Annotated[Optional[List[Literal['created_at', 'description', 'entities', 'id', 'location', 'name', 'pinned_tweet_id', 'profile_image_url', 'protected', 'public_metrics', 'url', 'username', 'verified', 'withheld']]], Field(description="A comma separated list of User fields to display.", unique_items=True)] = None, expansions : Annotated[Optional[List[Literal['pinned_tweet_id']]], Field(description="A comma separated list of fields to expand.", unique_items=True)] = None, tweet_fields : Annotated[Optional[List[Literal['attachments', 'author_id', 'context_annotations', 'conversation_id', 'created_at', 'entities', 'geo', 'id', 'in_reply_to_user_id', 'lang', 'non_public_metrics', 'organic_metrics', 'possibly_sensitive', 'promoted_metrics', 'public_metrics', 'referenced_tweets', 'reply_settings', 'source', 'text', 'withheld']]], Field(description="A comma separated list of Tweet fields to display.", unique_items=True)] = None, **kwargs) -> Get2UsersResponse:  # noqa: E501
        """User lookup by IDs  # noqa: E501

        This endpoint returns information about Users. Specify Users by their ID.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.find_users_by_id(ids, user_fields, expansions, tweet_fields, async_req=True)
        >>> result = thread.get()

        :param ids: A list of User IDs, comma-separated. You can specify up to 100 IDs. (required)
        :type ids: List[str]
        :param user_fields: A comma separated list of User fields to display.
        :type user_fields: List[str]
        :param expansions: A comma separated list of fields to expand.
        :type expansions: List[str]
        :param tweet_fields: A comma separated list of Tweet fields to display.
        :type tweet_fields: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: Get2UsersResponse
        """
        kwargs['_return_http_data_only'] = True
        return self.find_users_by_id_with_http_info(ids, user_fields, expansions, tweet_fields, **kwargs)  # noqa: E501

    @validate_arguments
    def find_users_by_id_with_http_info(self, ids : Annotated[List[constr(strict=True, regex=r'/^[0-9]{1,19}$/')], Field(..., description="A list of User IDs, comma-separated. You can specify up to 100 IDs.")], user_fields : Annotated[Optional[List[Literal['created_at', 'description', 'entities', 'id', 'location', 'name', 'pinned_tweet_id', 'profile_image_url', 'protected', 'public_metrics', 'url', 'username', 'verified', 'withheld']]], Field(description="A comma separated list of User fields to display.", unique_items=True)] = None, expansions : Annotated[Optional[List[Literal['pinned_tweet_id']]], Field(description="A comma separated list of fields to expand.", unique_items=True)] = None, tweet_fields : Annotated[Optional[List[Literal['attachments', 'author_id', 'context_annotations', 'conversation_id', 'created_at', 'entities', 'geo', 'id', 'in_reply_to_user_id', 'lang', 'non_public_metrics', 'organic_metrics', 'possibly_sensitive', 'promoted_metrics', 'public_metrics', 'referenced_tweets', 'reply_settings', 'source', 'text', 'withheld']]], Field(description="A comma separated list of Tweet fields to display.", unique_items=True)] = None, **kwargs):  # noqa: E501
        """User lookup by IDs  # noqa: E501

        This endpoint returns information about Users. Specify Users by their ID.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.find_users_by_id_with_http_info(ids, user_fields, expansions, tweet_fields, async_req=True)
        >>> result = thread.get()

        :param ids: A list of User IDs, comma-separated. You can specify up to 100 IDs. (required)
        :type ids: List[str]
        :param user_fields: A comma separated list of User fields to display.
        :type user_fields: List[str]
        :param expansions: A comma separated list of fields to expand.
        :type expansions: List[str]
        :param tweet_fields: A comma separated list of Tweet fields to display.
        :type tweet_fields: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(Get2UsersResponse, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'ids',
            'user_fields',
            'expansions',
            'tweet_fields'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in local_var_params['kwargs'].items():
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method find_users_by_id" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if local_var_params.get('ids') is not None:  # noqa: E501
            query_params.append(('ids', local_var_params['ids']))
            collection_formats['ids'] = 'csv'
        if local_var_params.get('user_fields') is not None:  # noqa: E501
            query_params.append(('user.fields', local_var_params['user_fields']))
            collection_formats['user.fields'] = 'csv'
        if local_var_params.get('expansions') is not None:  # noqa: E501
            query_params.append(('expansions', local_var_params['expansions']))
            collection_formats['expansions'] = 'csv'
        if local_var_params.get('tweet_fields') is not None:  # noqa: E501
            query_params.append(('tweet.fields', local_var_params['tweet_fields']))
            collection_formats['tweet.fields'] = 'csv'

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'application/problem+json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BearerToken', 'OAuth2UserToken', 'UserToken']  # noqa: E501

        response_types_map = {
            200: "Get2UsersResponse",
        }

        return self.api_client.call_api(
            '/2/users', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    @validate_arguments
    def find_users_by_username(self, usernames : Annotated[List[constr(strict=True, regex=r'/^[A-Za-z0-9_]{1,15}$/')], Field(..., description="A list of usernames, comma-separated.")], user_fields : Annotated[Optional[List[Literal['created_at', 'description', 'entities', 'id', 'location', 'name', 'pinned_tweet_id', 'profile_image_url', 'protected', 'public_metrics', 'url', 'username', 'verified', 'withheld']]], Field(description="A comma separated list of User fields to display.", unique_items=True)] = None, expansions : Annotated[Optional[List[Literal['pinned_tweet_id']]], Field(description="A comma separated list of fields to expand.", unique_items=True)] = None, tweet_fields : Annotated[Optional[List[Literal['attachments', 'author_id', 'context_annotations', 'conversation_id', 'created_at', 'entities', 'geo', 'id', 'in_reply_to_user_id', 'lang', 'non_public_metrics', 'organic_metrics', 'possibly_sensitive', 'promoted_metrics', 'public_metrics', 'referenced_tweets', 'reply_settings', 'source', 'text', 'withheld']]], Field(description="A comma separated list of Tweet fields to display.", unique_items=True)] = None, **kwargs) -> Get2UsersByResponse:  # noqa: E501
        """User lookup by usernames  # noqa: E501

        This endpoint returns information about Users. Specify Users by their username.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.find_users_by_username(usernames, user_fields, expansions, tweet_fields, async_req=True)
        >>> result = thread.get()

        :param usernames: A list of usernames, comma-separated. (required)
        :type usernames: List[str]
        :param user_fields: A comma separated list of User fields to display.
        :type user_fields: List[str]
        :param expansions: A comma separated list of fields to expand.
        :type expansions: List[str]
        :param tweet_fields: A comma separated list of Tweet fields to display.
        :type tweet_fields: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: Get2UsersByResponse
        """
        kwargs['_return_http_data_only'] = True
        return self.find_users_by_username_with_http_info(usernames, user_fields, expansions, tweet_fields, **kwargs)  # noqa: E501

    @validate_arguments
    def find_users_by_username_with_http_info(self, usernames : Annotated[List[constr(strict=True, regex=r'/^[A-Za-z0-9_]{1,15}$/')], Field(..., description="A list of usernames, comma-separated.")], user_fields : Annotated[Optional[List[Literal['created_at', 'description', 'entities', 'id', 'location', 'name', 'pinned_tweet_id', 'profile_image_url', 'protected', 'public_metrics', 'url', 'username', 'verified', 'withheld']]], Field(description="A comma separated list of User fields to display.", unique_items=True)] = None, expansions : Annotated[Optional[List[Literal['pinned_tweet_id']]], Field(description="A comma separated list of fields to expand.", unique_items=True)] = None, tweet_fields : Annotated[Optional[List[Literal['attachments', 'author_id', 'context_annotations', 'conversation_id', 'created_at', 'entities', 'geo', 'id', 'in_reply_to_user_id', 'lang', 'non_public_metrics', 'organic_metrics', 'possibly_sensitive', 'promoted_metrics', 'public_metrics', 'referenced_tweets', 'reply_settings', 'source', 'text', 'withheld']]], Field(description="A comma separated list of Tweet fields to display.", unique_items=True)] = None, **kwargs):  # noqa: E501
        """User lookup by usernames  # noqa: E501

        This endpoint returns information about Users. Specify Users by their username.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.find_users_by_username_with_http_info(usernames, user_fields, expansions, tweet_fields, async_req=True)
        >>> result = thread.get()

        :param usernames: A list of usernames, comma-separated. (required)
        :type usernames: List[str]
        :param user_fields: A comma separated list of User fields to display.
        :type user_fields: List[str]
        :param expansions: A comma separated list of fields to expand.
        :type expansions: List[str]
        :param tweet_fields: A comma separated list of Tweet fields to display.
        :type tweet_fields: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(Get2UsersByResponse, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'usernames',
            'user_fields',
            'expansions',
            'tweet_fields'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in local_var_params['kwargs'].items():
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method find_users_by_username" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if local_var_params.get('usernames') is not None:  # noqa: E501
            query_params.append(('usernames', local_var_params['usernames']))
            collection_formats['usernames'] = 'csv'
        if local_var_params.get('user_fields') is not None:  # noqa: E501
            query_params.append(('user.fields', local_var_params['user_fields']))
            collection_formats['user.fields'] = 'csv'
        if local_var_params.get('expansions') is not None:  # noqa: E501
            query_params.append(('expansions', local_var_params['expansions']))
            collection_formats['expansions'] = 'csv'
        if local_var_params.get('tweet_fields') is not None:  # noqa: E501
            query_params.append(('tweet.fields', local_var_params['tweet_fields']))
            collection_formats['tweet.fields'] = 'csv'

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'application/problem+json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BearerToken', 'OAuth2UserToken', 'UserToken']  # noqa: E501

        response_types_map = {
            200: "Get2UsersByResponse",
        }

        return self.api_client.call_api(
            '/2/users/by', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    @validate_arguments
    def list_get_followers(self, id : Annotated[constr(strict=True, regex=r'/^[0-9]{1,19}$/'), Field(..., description="The ID of the List.")], max_results : Annotated[Optional[conint(strict=True, ge=100, le=1)], Field(description="The maximum number of results.")] = None, pagination_token : Annotated[Optional[constr(strict=True, max_length=19, min_length=1)], Field(description="This parameter is used to get a specified 'page' of results.")] = None, user_fields : Annotated[Optional[List[Literal['created_at', 'description', 'entities', 'id', 'location', 'name', 'pinned_tweet_id', 'profile_image_url', 'protected', 'public_metrics', 'url', 'username', 'verified', 'withheld']]], Field(description="A comma separated list of User fields to display.", unique_items=True)] = None, expansions : Annotated[Optional[List[Literal['pinned_tweet_id']]], Field(description="A comma separated list of fields to expand.", unique_items=True)] = None, tweet_fields : Annotated[Optional[List[Literal['attachments', 'author_id', 'context_annotations', 'conversation_id', 'created_at', 'entities', 'geo', 'id', 'in_reply_to_user_id', 'lang', 'non_public_metrics', 'organic_metrics', 'possibly_sensitive', 'promoted_metrics', 'public_metrics', 'referenced_tweets', 'reply_settings', 'source', 'text', 'withheld']]], Field(description="A comma separated list of Tweet fields to display.", unique_items=True)] = None, **kwargs) -> Get2ListsIdFollowersResponse:  # noqa: E501
        """Returns User objects that follow a List by the provided List ID  # noqa: E501

        Returns a list of Users that follow a List by the provided List ID  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.list_get_followers(id, max_results, pagination_token, user_fields, expansions, tweet_fields, async_req=True)
        >>> result = thread.get()

        :param id: The ID of the List. (required)
        :type id: str
        :param max_results: The maximum number of results.
        :type max_results: int
        :param pagination_token: This parameter is used to get a specified 'page' of results.
        :type pagination_token: str
        :param user_fields: A comma separated list of User fields to display.
        :type user_fields: List[str]
        :param expansions: A comma separated list of fields to expand.
        :type expansions: List[str]
        :param tweet_fields: A comma separated list of Tweet fields to display.
        :type tweet_fields: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: Get2ListsIdFollowersResponse
        """
        kwargs['_return_http_data_only'] = True
        return self.list_get_followers_with_http_info(id, max_results, pagination_token, user_fields, expansions, tweet_fields, **kwargs)  # noqa: E501

    @validate_arguments
    def list_get_followers_with_http_info(self, id : Annotated[constr(strict=True, regex=r'/^[0-9]{1,19}$/'), Field(..., description="The ID of the List.")], max_results : Annotated[Optional[conint(strict=True, ge=100, le=1)], Field(description="The maximum number of results.")] = None, pagination_token : Annotated[Optional[constr(strict=True, max_length=19, min_length=1)], Field(description="This parameter is used to get a specified 'page' of results.")] = None, user_fields : Annotated[Optional[List[Literal['created_at', 'description', 'entities', 'id', 'location', 'name', 'pinned_tweet_id', 'profile_image_url', 'protected', 'public_metrics', 'url', 'username', 'verified', 'withheld']]], Field(description="A comma separated list of User fields to display.", unique_items=True)] = None, expansions : Annotated[Optional[List[Literal['pinned_tweet_id']]], Field(description="A comma separated list of fields to expand.", unique_items=True)] = None, tweet_fields : Annotated[Optional[List[Literal['attachments', 'author_id', 'context_annotations', 'conversation_id', 'created_at', 'entities', 'geo', 'id', 'in_reply_to_user_id', 'lang', 'non_public_metrics', 'organic_metrics', 'possibly_sensitive', 'promoted_metrics', 'public_metrics', 'referenced_tweets', 'reply_settings', 'source', 'text', 'withheld']]], Field(description="A comma separated list of Tweet fields to display.", unique_items=True)] = None, **kwargs):  # noqa: E501
        """Returns User objects that follow a List by the provided List ID  # noqa: E501

        Returns a list of Users that follow a List by the provided List ID  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.list_get_followers_with_http_info(id, max_results, pagination_token, user_fields, expansions, tweet_fields, async_req=True)
        >>> result = thread.get()

        :param id: The ID of the List. (required)
        :type id: str
        :param max_results: The maximum number of results.
        :type max_results: int
        :param pagination_token: This parameter is used to get a specified 'page' of results.
        :type pagination_token: str
        :param user_fields: A comma separated list of User fields to display.
        :type user_fields: List[str]
        :param expansions: A comma separated list of fields to expand.
        :type expansions: List[str]
        :param tweet_fields: A comma separated list of Tweet fields to display.
        :type tweet_fields: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(Get2ListsIdFollowersResponse, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'id',
            'max_results',
            'pagination_token',
            'user_fields',
            'expansions',
            'tweet_fields'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in local_var_params['kwargs'].items():
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_get_followers" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        collection_formats = {}

        path_params = {}
        if local_var_params['id']:
            path_params['id'] = local_var_params['id']

        query_params = []
        if local_var_params.get('max_results') is not None:  # noqa: E501
            query_params.append(('max_results', local_var_params['max_results']))
        if local_var_params.get('pagination_token') is not None:  # noqa: E501
            query_params.append(('pagination_token', local_var_params['pagination_token']))
        if local_var_params.get('user_fields') is not None:  # noqa: E501
            query_params.append(('user.fields', local_var_params['user_fields']))
            collection_formats['user.fields'] = 'csv'
        if local_var_params.get('expansions') is not None:  # noqa: E501
            query_params.append(('expansions', local_var_params['expansions']))
            collection_formats['expansions'] = 'csv'
        if local_var_params.get('tweet_fields') is not None:  # noqa: E501
            query_params.append(('tweet.fields', local_var_params['tweet_fields']))
            collection_formats['tweet.fields'] = 'csv'

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'application/problem+json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BearerToken', 'OAuth2UserToken', 'UserToken']  # noqa: E501

        response_types_map = {
            200: "Get2ListsIdFollowersResponse",
        }

        return self.api_client.call_api(
            '/2/lists/{id}/followers', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    @validate_arguments
    def list_get_members(self, id : Annotated[constr(strict=True, regex=r'/^[0-9]{1,19}$/'), Field(..., description="The ID of the List.")], max_results : Annotated[Optional[conint(strict=True, ge=100, le=1)], Field(description="The maximum number of results.")] = None, pagination_token : Annotated[Optional[constr(strict=True, max_length=19, min_length=1)], Field(description="This parameter is used to get a specified 'page' of results.")] = None, user_fields : Annotated[Optional[List[Literal['created_at', 'description', 'entities', 'id', 'location', 'name', 'pinned_tweet_id', 'profile_image_url', 'protected', 'public_metrics', 'url', 'username', 'verified', 'withheld']]], Field(description="A comma separated list of User fields to display.", unique_items=True)] = None, expansions : Annotated[Optional[List[Literal['pinned_tweet_id']]], Field(description="A comma separated list of fields to expand.", unique_items=True)] = None, tweet_fields : Annotated[Optional[List[Literal['attachments', 'author_id', 'context_annotations', 'conversation_id', 'created_at', 'entities', 'geo', 'id', 'in_reply_to_user_id', 'lang', 'non_public_metrics', 'organic_metrics', 'possibly_sensitive', 'promoted_metrics', 'public_metrics', 'referenced_tweets', 'reply_settings', 'source', 'text', 'withheld']]], Field(description="A comma separated list of Tweet fields to display.", unique_items=True)] = None, **kwargs) -> Get2ListsIdMembersResponse:  # noqa: E501
        """Returns User objects that are members of a List by the provided List ID.  # noqa: E501

        Returns a list of Users that are members of a List by the provided List ID.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.list_get_members(id, max_results, pagination_token, user_fields, expansions, tweet_fields, async_req=True)
        >>> result = thread.get()

        :param id: The ID of the List. (required)
        :type id: str
        :param max_results: The maximum number of results.
        :type max_results: int
        :param pagination_token: This parameter is used to get a specified 'page' of results.
        :type pagination_token: str
        :param user_fields: A comma separated list of User fields to display.
        :type user_fields: List[str]
        :param expansions: A comma separated list of fields to expand.
        :type expansions: List[str]
        :param tweet_fields: A comma separated list of Tweet fields to display.
        :type tweet_fields: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: Get2ListsIdMembersResponse
        """
        kwargs['_return_http_data_only'] = True
        return self.list_get_members_with_http_info(id, max_results, pagination_token, user_fields, expansions, tweet_fields, **kwargs)  # noqa: E501

    @validate_arguments
    def list_get_members_with_http_info(self, id : Annotated[constr(strict=True, regex=r'/^[0-9]{1,19}$/'), Field(..., description="The ID of the List.")], max_results : Annotated[Optional[conint(strict=True, ge=100, le=1)], Field(description="The maximum number of results.")] = None, pagination_token : Annotated[Optional[constr(strict=True, max_length=19, min_length=1)], Field(description="This parameter is used to get a specified 'page' of results.")] = None, user_fields : Annotated[Optional[List[Literal['created_at', 'description', 'entities', 'id', 'location', 'name', 'pinned_tweet_id', 'profile_image_url', 'protected', 'public_metrics', 'url', 'username', 'verified', 'withheld']]], Field(description="A comma separated list of User fields to display.", unique_items=True)] = None, expansions : Annotated[Optional[List[Literal['pinned_tweet_id']]], Field(description="A comma separated list of fields to expand.", unique_items=True)] = None, tweet_fields : Annotated[Optional[List[Literal['attachments', 'author_id', 'context_annotations', 'conversation_id', 'created_at', 'entities', 'geo', 'id', 'in_reply_to_user_id', 'lang', 'non_public_metrics', 'organic_metrics', 'possibly_sensitive', 'promoted_metrics', 'public_metrics', 'referenced_tweets', 'reply_settings', 'source', 'text', 'withheld']]], Field(description="A comma separated list of Tweet fields to display.", unique_items=True)] = None, **kwargs):  # noqa: E501
        """Returns User objects that are members of a List by the provided List ID.  # noqa: E501

        Returns a list of Users that are members of a List by the provided List ID.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.list_get_members_with_http_info(id, max_results, pagination_token, user_fields, expansions, tweet_fields, async_req=True)
        >>> result = thread.get()

        :param id: The ID of the List. (required)
        :type id: str
        :param max_results: The maximum number of results.
        :type max_results: int
        :param pagination_token: This parameter is used to get a specified 'page' of results.
        :type pagination_token: str
        :param user_fields: A comma separated list of User fields to display.
        :type user_fields: List[str]
        :param expansions: A comma separated list of fields to expand.
        :type expansions: List[str]
        :param tweet_fields: A comma separated list of Tweet fields to display.
        :type tweet_fields: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(Get2ListsIdMembersResponse, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'id',
            'max_results',
            'pagination_token',
            'user_fields',
            'expansions',
            'tweet_fields'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in local_var_params['kwargs'].items():
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_get_members" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        collection_formats = {}

        path_params = {}
        if local_var_params['id']:
            path_params['id'] = local_var_params['id']

        query_params = []
        if local_var_params.get('max_results') is not None:  # noqa: E501
            query_params.append(('max_results', local_var_params['max_results']))
        if local_var_params.get('pagination_token') is not None:  # noqa: E501
            query_params.append(('pagination_token', local_var_params['pagination_token']))
        if local_var_params.get('user_fields') is not None:  # noqa: E501
            query_params.append(('user.fields', local_var_params['user_fields']))
            collection_formats['user.fields'] = 'csv'
        if local_var_params.get('expansions') is not None:  # noqa: E501
            query_params.append(('expansions', local_var_params['expansions']))
            collection_formats['expansions'] = 'csv'
        if local_var_params.get('tweet_fields') is not None:  # noqa: E501
            query_params.append(('tweet.fields', local_var_params['tweet_fields']))
            collection_formats['tweet.fields'] = 'csv'

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'application/problem+json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BearerToken', 'OAuth2UserToken', 'UserToken']  # noqa: E501

        response_types_map = {
            200: "Get2ListsIdMembersResponse",
        }

        return self.api_client.call_api(
            '/2/lists/{id}/members', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    @validate_arguments
    def tweets_id_liking_users(self, id : Annotated[constr(strict=True, regex=r'/^[0-9]{1,19}$/'), Field(..., description="A single Tweet ID.")], max_results : Annotated[Optional[conint(strict=True, ge=100, le=1)], Field(description="The maximum number of results.")] = None, pagination_token : Annotated[Optional[constr(strict=True, min_length=1)], Field(description="This parameter is used to get the next 'page' of results.")] = None, user_fields : Annotated[Optional[List[Literal['created_at', 'description', 'entities', 'id', 'location', 'name', 'pinned_tweet_id', 'profile_image_url', 'protected', 'public_metrics', 'url', 'username', 'verified', 'withheld']]], Field(description="A comma separated list of User fields to display.", unique_items=True)] = None, expansions : Annotated[Optional[List[Literal['pinned_tweet_id']]], Field(description="A comma separated list of fields to expand.", unique_items=True)] = None, tweet_fields : Annotated[Optional[List[Literal['attachments', 'author_id', 'context_annotations', 'conversation_id', 'created_at', 'entities', 'geo', 'id', 'in_reply_to_user_id', 'lang', 'non_public_metrics', 'organic_metrics', 'possibly_sensitive', 'promoted_metrics', 'public_metrics', 'referenced_tweets', 'reply_settings', 'source', 'text', 'withheld']]], Field(description="A comma separated list of Tweet fields to display.", unique_items=True)] = None, **kwargs) -> Get2TweetsIdLikingUsersResponse:  # noqa: E501
        """Returns User objects that have liked the provided Tweet ID  # noqa: E501

        Returns a list of Users that have liked the provided Tweet ID  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.tweets_id_liking_users(id, max_results, pagination_token, user_fields, expansions, tweet_fields, async_req=True)
        >>> result = thread.get()

        :param id: A single Tweet ID. (required)
        :type id: str
        :param max_results: The maximum number of results.
        :type max_results: int
        :param pagination_token: This parameter is used to get the next 'page' of results.
        :type pagination_token: str
        :param user_fields: A comma separated list of User fields to display.
        :type user_fields: List[str]
        :param expansions: A comma separated list of fields to expand.
        :type expansions: List[str]
        :param tweet_fields: A comma separated list of Tweet fields to display.
        :type tweet_fields: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: Get2TweetsIdLikingUsersResponse
        """
        kwargs['_return_http_data_only'] = True
        return self.tweets_id_liking_users_with_http_info(id, max_results, pagination_token, user_fields, expansions, tweet_fields, **kwargs)  # noqa: E501

    @validate_arguments
    def tweets_id_liking_users_with_http_info(self, id : Annotated[constr(strict=True, regex=r'/^[0-9]{1,19}$/'), Field(..., description="A single Tweet ID.")], max_results : Annotated[Optional[conint(strict=True, ge=100, le=1)], Field(description="The maximum number of results.")] = None, pagination_token : Annotated[Optional[constr(strict=True, min_length=1)], Field(description="This parameter is used to get the next 'page' of results.")] = None, user_fields : Annotated[Optional[List[Literal['created_at', 'description', 'entities', 'id', 'location', 'name', 'pinned_tweet_id', 'profile_image_url', 'protected', 'public_metrics', 'url', 'username', 'verified', 'withheld']]], Field(description="A comma separated list of User fields to display.", unique_items=True)] = None, expansions : Annotated[Optional[List[Literal['pinned_tweet_id']]], Field(description="A comma separated list of fields to expand.", unique_items=True)] = None, tweet_fields : Annotated[Optional[List[Literal['attachments', 'author_id', 'context_annotations', 'conversation_id', 'created_at', 'entities', 'geo', 'id', 'in_reply_to_user_id', 'lang', 'non_public_metrics', 'organic_metrics', 'possibly_sensitive', 'promoted_metrics', 'public_metrics', 'referenced_tweets', 'reply_settings', 'source', 'text', 'withheld']]], Field(description="A comma separated list of Tweet fields to display.", unique_items=True)] = None, **kwargs):  # noqa: E501
        """Returns User objects that have liked the provided Tweet ID  # noqa: E501

        Returns a list of Users that have liked the provided Tweet ID  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.tweets_id_liking_users_with_http_info(id, max_results, pagination_token, user_fields, expansions, tweet_fields, async_req=True)
        >>> result = thread.get()

        :param id: A single Tweet ID. (required)
        :type id: str
        :param max_results: The maximum number of results.
        :type max_results: int
        :param pagination_token: This parameter is used to get the next 'page' of results.
        :type pagination_token: str
        :param user_fields: A comma separated list of User fields to display.
        :type user_fields: List[str]
        :param expansions: A comma separated list of fields to expand.
        :type expansions: List[str]
        :param tweet_fields: A comma separated list of Tweet fields to display.
        :type tweet_fields: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(Get2TweetsIdLikingUsersResponse, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'id',
            'max_results',
            'pagination_token',
            'user_fields',
            'expansions',
            'tweet_fields'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in local_var_params['kwargs'].items():
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method tweets_id_liking_users" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        collection_formats = {}

        path_params = {}
        if local_var_params['id']:
            path_params['id'] = local_var_params['id']

        query_params = []
        if local_var_params.get('max_results') is not None:  # noqa: E501
            query_params.append(('max_results', local_var_params['max_results']))
        if local_var_params.get('pagination_token') is not None:  # noqa: E501
            query_params.append(('pagination_token', local_var_params['pagination_token']))
        if local_var_params.get('user_fields') is not None:  # noqa: E501
            query_params.append(('user.fields', local_var_params['user_fields']))
            collection_formats['user.fields'] = 'csv'
        if local_var_params.get('expansions') is not None:  # noqa: E501
            query_params.append(('expansions', local_var_params['expansions']))
            collection_formats['expansions'] = 'csv'
        if local_var_params.get('tweet_fields') is not None:  # noqa: E501
            query_params.append(('tweet.fields', local_var_params['tweet_fields']))
            collection_formats['tweet.fields'] = 'csv'

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'application/problem+json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BearerToken', 'OAuth2UserToken', 'UserToken']  # noqa: E501

        response_types_map = {
            200: "Get2TweetsIdLikingUsersResponse",
        }

        return self.api_client.call_api(
            '/2/tweets/{id}/liking_users', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    @validate_arguments
    def tweets_id_retweeting_users(self, id : Annotated[constr(strict=True, regex=r'/^[0-9]{1,19}$/'), Field(..., description="A single Tweet ID.")], max_results : Annotated[Optional[conint(strict=True, ge=100, le=1)], Field(description="The maximum number of results.")] = None, pagination_token : Annotated[Optional[constr(strict=True, min_length=1)], Field(description="This parameter is used to get the next 'page' of results.")] = None, user_fields : Annotated[Optional[List[Literal['created_at', 'description', 'entities', 'id', 'location', 'name', 'pinned_tweet_id', 'profile_image_url', 'protected', 'public_metrics', 'url', 'username', 'verified', 'withheld']]], Field(description="A comma separated list of User fields to display.", unique_items=True)] = None, expansions : Annotated[Optional[List[Literal['pinned_tweet_id']]], Field(description="A comma separated list of fields to expand.", unique_items=True)] = None, tweet_fields : Annotated[Optional[List[Literal['attachments', 'author_id', 'context_annotations', 'conversation_id', 'created_at', 'entities', 'geo', 'id', 'in_reply_to_user_id', 'lang', 'non_public_metrics', 'organic_metrics', 'possibly_sensitive', 'promoted_metrics', 'public_metrics', 'referenced_tweets', 'reply_settings', 'source', 'text', 'withheld']]], Field(description="A comma separated list of Tweet fields to display.", unique_items=True)] = None, **kwargs) -> Get2TweetsIdRetweetedByResponse:  # noqa: E501
        """Returns User objects that have retweeted the provided Tweet ID  # noqa: E501

        Returns a list of Users that have retweeted the provided Tweet ID  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.tweets_id_retweeting_users(id, max_results, pagination_token, user_fields, expansions, tweet_fields, async_req=True)
        >>> result = thread.get()

        :param id: A single Tweet ID. (required)
        :type id: str
        :param max_results: The maximum number of results.
        :type max_results: int
        :param pagination_token: This parameter is used to get the next 'page' of results.
        :type pagination_token: str
        :param user_fields: A comma separated list of User fields to display.
        :type user_fields: List[str]
        :param expansions: A comma separated list of fields to expand.
        :type expansions: List[str]
        :param tweet_fields: A comma separated list of Tweet fields to display.
        :type tweet_fields: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: Get2TweetsIdRetweetedByResponse
        """
        kwargs['_return_http_data_only'] = True
        return self.tweets_id_retweeting_users_with_http_info(id, max_results, pagination_token, user_fields, expansions, tweet_fields, **kwargs)  # noqa: E501

    @validate_arguments
    def tweets_id_retweeting_users_with_http_info(self, id : Annotated[constr(strict=True, regex=r'/^[0-9]{1,19}$/'), Field(..., description="A single Tweet ID.")], max_results : Annotated[Optional[conint(strict=True, ge=100, le=1)], Field(description="The maximum number of results.")] = None, pagination_token : Annotated[Optional[constr(strict=True, min_length=1)], Field(description="This parameter is used to get the next 'page' of results.")] = None, user_fields : Annotated[Optional[List[Literal['created_at', 'description', 'entities', 'id', 'location', 'name', 'pinned_tweet_id', 'profile_image_url', 'protected', 'public_metrics', 'url', 'username', 'verified', 'withheld']]], Field(description="A comma separated list of User fields to display.", unique_items=True)] = None, expansions : Annotated[Optional[List[Literal['pinned_tweet_id']]], Field(description="A comma separated list of fields to expand.", unique_items=True)] = None, tweet_fields : Annotated[Optional[List[Literal['attachments', 'author_id', 'context_annotations', 'conversation_id', 'created_at', 'entities', 'geo', 'id', 'in_reply_to_user_id', 'lang', 'non_public_metrics', 'organic_metrics', 'possibly_sensitive', 'promoted_metrics', 'public_metrics', 'referenced_tweets', 'reply_settings', 'source', 'text', 'withheld']]], Field(description="A comma separated list of Tweet fields to display.", unique_items=True)] = None, **kwargs):  # noqa: E501
        """Returns User objects that have retweeted the provided Tweet ID  # noqa: E501

        Returns a list of Users that have retweeted the provided Tweet ID  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.tweets_id_retweeting_users_with_http_info(id, max_results, pagination_token, user_fields, expansions, tweet_fields, async_req=True)
        >>> result = thread.get()

        :param id: A single Tweet ID. (required)
        :type id: str
        :param max_results: The maximum number of results.
        :type max_results: int
        :param pagination_token: This parameter is used to get the next 'page' of results.
        :type pagination_token: str
        :param user_fields: A comma separated list of User fields to display.
        :type user_fields: List[str]
        :param expansions: A comma separated list of fields to expand.
        :type expansions: List[str]
        :param tweet_fields: A comma separated list of Tweet fields to display.
        :type tweet_fields: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(Get2TweetsIdRetweetedByResponse, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'id',
            'max_results',
            'pagination_token',
            'user_fields',
            'expansions',
            'tweet_fields'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in local_var_params['kwargs'].items():
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method tweets_id_retweeting_users" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        collection_formats = {}

        path_params = {}
        if local_var_params['id']:
            path_params['id'] = local_var_params['id']

        query_params = []
        if local_var_params.get('max_results') is not None:  # noqa: E501
            query_params.append(('max_results', local_var_params['max_results']))
        if local_var_params.get('pagination_token') is not None:  # noqa: E501
            query_params.append(('pagination_token', local_var_params['pagination_token']))
        if local_var_params.get('user_fields') is not None:  # noqa: E501
            query_params.append(('user.fields', local_var_params['user_fields']))
            collection_formats['user.fields'] = 'csv'
        if local_var_params.get('expansions') is not None:  # noqa: E501
            query_params.append(('expansions', local_var_params['expansions']))
            collection_formats['expansions'] = 'csv'
        if local_var_params.get('tweet_fields') is not None:  # noqa: E501
            query_params.append(('tweet.fields', local_var_params['tweet_fields']))
            collection_formats['tweet.fields'] = 'csv'

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'application/problem+json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BearerToken', 'OAuth2UserToken', 'UserToken']  # noqa: E501

        response_types_map = {
            200: "Get2TweetsIdRetweetedByResponse",
        }

        return self.api_client.call_api(
            '/2/tweets/{id}/retweeted_by', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    @validate_arguments
    def users_id_block(self, id : Annotated[StrictStr, Field(..., description="The ID of the authenticated source User that is requesting to block the target User.")], block_user_request : BlockUserRequest, **kwargs) -> BlockUserMutationResponse:  # noqa: E501
        """Block User by User ID  # noqa: E501

        Causes the User (in the path) to block the target User. The User (in the path) must match the User context authorizing the request  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.users_id_block(id, block_user_request, async_req=True)
        >>> result = thread.get()

        :param id: The ID of the authenticated source User that is requesting to block the target User. (required)
        :type id: str
        :param block_user_request: (required)
        :type block_user_request: BlockUserRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: BlockUserMutationResponse
        """
        kwargs['_return_http_data_only'] = True
        return self.users_id_block_with_http_info(id, block_user_request, **kwargs)  # noqa: E501

    @validate_arguments
    def users_id_block_with_http_info(self, id : Annotated[StrictStr, Field(..., description="The ID of the authenticated source User that is requesting to block the target User.")], block_user_request : BlockUserRequest, **kwargs):  # noqa: E501
        """Block User by User ID  # noqa: E501

        Causes the User (in the path) to block the target User. The User (in the path) must match the User context authorizing the request  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.users_id_block_with_http_info(id, block_user_request, async_req=True)
        >>> result = thread.get()

        :param id: The ID of the authenticated source User that is requesting to block the target User. (required)
        :type id: str
        :param block_user_request: (required)
        :type block_user_request: BlockUserRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(BlockUserMutationResponse, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'id',
            'block_user_request'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in local_var_params['kwargs'].items():
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method users_id_block" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        collection_formats = {}

        path_params = {}
        if local_var_params['id']:
            path_params['id'] = local_var_params['id']

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        if local_var_params['block_user_request']:
            body_params = local_var_params['block_user_request']

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'application/problem+json'])  # noqa: E501

        # HTTP header `Content-Type`
        content_types_list = local_var_params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if content_types_list:
                header_params['Content-Type'] = content_types_list

        # Authentication setting
        auth_settings = ['OAuth2UserToken', 'UserToken']  # noqa: E501

        response_types_map = {
            200: "BlockUserMutationResponse",
        }

        return self.api_client.call_api(
            '/2/users/{id}/blocking', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    @validate_arguments
    def users_id_blocking(self, id : Annotated[StrictStr, Field(..., description="The ID of the authenticated source User for whom to return results.")], max_results : Annotated[Optional[conint(strict=True, ge=1000, le=1)], Field(description="The maximum number of results.")] = None, pagination_token : Annotated[Optional[constr(strict=True, min_length=16)], Field(description="This parameter is used to get a specified 'page' of results.")] = None, user_fields : Annotated[Optional[List[Literal['created_at', 'description', 'entities', 'id', 'location', 'name', 'pinned_tweet_id', 'profile_image_url', 'protected', 'public_metrics', 'url', 'username', 'verified', 'withheld']]], Field(description="A comma separated list of User fields to display.", unique_items=True)] = None, expansions : Annotated[Optional[List[Literal['pinned_tweet_id']]], Field(description="A comma separated list of fields to expand.", unique_items=True)] = None, tweet_fields : Annotated[Optional[List[Literal['attachments', 'author_id', 'context_annotations', 'conversation_id', 'created_at', 'entities', 'geo', 'id', 'in_reply_to_user_id', 'lang', 'non_public_metrics', 'organic_metrics', 'possibly_sensitive', 'promoted_metrics', 'public_metrics', 'referenced_tweets', 'reply_settings', 'source', 'text', 'withheld']]], Field(description="A comma separated list of Tweet fields to display.", unique_items=True)] = None, **kwargs) -> Get2UsersIdBlockingResponse:  # noqa: E501
        """Returns User objects that are blocked by provided User ID  # noqa: E501

        Returns a list of Users that are blocked by the provided User ID  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.users_id_blocking(id, max_results, pagination_token, user_fields, expansions, tweet_fields, async_req=True)
        >>> result = thread.get()

        :param id: The ID of the authenticated source User for whom to return results. (required)
        :type id: str
        :param max_results: The maximum number of results.
        :type max_results: int
        :param pagination_token: This parameter is used to get a specified 'page' of results.
        :type pagination_token: str
        :param user_fields: A comma separated list of User fields to display.
        :type user_fields: List[str]
        :param expansions: A comma separated list of fields to expand.
        :type expansions: List[str]
        :param tweet_fields: A comma separated list of Tweet fields to display.
        :type tweet_fields: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: Get2UsersIdBlockingResponse
        """
        kwargs['_return_http_data_only'] = True
        return self.users_id_blocking_with_http_info(id, max_results, pagination_token, user_fields, expansions, tweet_fields, **kwargs)  # noqa: E501

    @validate_arguments
    def users_id_blocking_with_http_info(self, id : Annotated[StrictStr, Field(..., description="The ID of the authenticated source User for whom to return results.")], max_results : Annotated[Optional[conint(strict=True, ge=1000, le=1)], Field(description="The maximum number of results.")] = None, pagination_token : Annotated[Optional[constr(strict=True, min_length=16)], Field(description="This parameter is used to get a specified 'page' of results.")] = None, user_fields : Annotated[Optional[List[Literal['created_at', 'description', 'entities', 'id', 'location', 'name', 'pinned_tweet_id', 'profile_image_url', 'protected', 'public_metrics', 'url', 'username', 'verified', 'withheld']]], Field(description="A comma separated list of User fields to display.", unique_items=True)] = None, expansions : Annotated[Optional[List[Literal['pinned_tweet_id']]], Field(description="A comma separated list of fields to expand.", unique_items=True)] = None, tweet_fields : Annotated[Optional[List[Literal['attachments', 'author_id', 'context_annotations', 'conversation_id', 'created_at', 'entities', 'geo', 'id', 'in_reply_to_user_id', 'lang', 'non_public_metrics', 'organic_metrics', 'possibly_sensitive', 'promoted_metrics', 'public_metrics', 'referenced_tweets', 'reply_settings', 'source', 'text', 'withheld']]], Field(description="A comma separated list of Tweet fields to display.", unique_items=True)] = None, **kwargs):  # noqa: E501
        """Returns User objects that are blocked by provided User ID  # noqa: E501

        Returns a list of Users that are blocked by the provided User ID  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.users_id_blocking_with_http_info(id, max_results, pagination_token, user_fields, expansions, tweet_fields, async_req=True)
        >>> result = thread.get()

        :param id: The ID of the authenticated source User for whom to return results. (required)
        :type id: str
        :param max_results: The maximum number of results.
        :type max_results: int
        :param pagination_token: This parameter is used to get a specified 'page' of results.
        :type pagination_token: str
        :param user_fields: A comma separated list of User fields to display.
        :type user_fields: List[str]
        :param expansions: A comma separated list of fields to expand.
        :type expansions: List[str]
        :param tweet_fields: A comma separated list of Tweet fields to display.
        :type tweet_fields: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(Get2UsersIdBlockingResponse, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'id',
            'max_results',
            'pagination_token',
            'user_fields',
            'expansions',
            'tweet_fields'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in local_var_params['kwargs'].items():
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method users_id_blocking" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        collection_formats = {}

        path_params = {}
        if local_var_params['id']:
            path_params['id'] = local_var_params['id']

        query_params = []
        if local_var_params.get('max_results') is not None:  # noqa: E501
            query_params.append(('max_results', local_var_params['max_results']))
        if local_var_params.get('pagination_token') is not None:  # noqa: E501
            query_params.append(('pagination_token', local_var_params['pagination_token']))
        if local_var_params.get('user_fields') is not None:  # noqa: E501
            query_params.append(('user.fields', local_var_params['user_fields']))
            collection_formats['user.fields'] = 'csv'
        if local_var_params.get('expansions') is not None:  # noqa: E501
            query_params.append(('expansions', local_var_params['expansions']))
            collection_formats['expansions'] = 'csv'
        if local_var_params.get('tweet_fields') is not None:  # noqa: E501
            query_params.append(('tweet.fields', local_var_params['tweet_fields']))
            collection_formats['tweet.fields'] = 'csv'

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'application/problem+json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['OAuth2UserToken', 'UserToken']  # noqa: E501

        response_types_map = {
            200: "Get2UsersIdBlockingResponse",
        }

        return self.api_client.call_api(
            '/2/users/{id}/blocking', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    @validate_arguments
    def users_id_follow(self, id : Annotated[StrictStr, Field(..., description="The ID of the authenticated source User that is requesting to follow the target User.")], users_following_create_request : Optional[UsersFollowingCreateRequest] = None, **kwargs) -> UsersFollowingCreateResponse:  # noqa: E501
        """Follow User  # noqa: E501

        Causes the User(in the path) to follow, or request to follow for protected Users, the target User. The User(in the path) must match the User context authorizing the request  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.users_id_follow(id, users_following_create_request, async_req=True)
        >>> result = thread.get()

        :param id: The ID of the authenticated source User that is requesting to follow the target User. (required)
        :type id: str
        :param users_following_create_request:
        :type users_following_create_request: UsersFollowingCreateRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: UsersFollowingCreateResponse
        """
        kwargs['_return_http_data_only'] = True
        return self.users_id_follow_with_http_info(id, users_following_create_request, **kwargs)  # noqa: E501

    @validate_arguments
    def users_id_follow_with_http_info(self, id : Annotated[StrictStr, Field(..., description="The ID of the authenticated source User that is requesting to follow the target User.")], users_following_create_request : Optional[UsersFollowingCreateRequest] = None, **kwargs):  # noqa: E501
        """Follow User  # noqa: E501

        Causes the User(in the path) to follow, or request to follow for protected Users, the target User. The User(in the path) must match the User context authorizing the request  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.users_id_follow_with_http_info(id, users_following_create_request, async_req=True)
        >>> result = thread.get()

        :param id: The ID of the authenticated source User that is requesting to follow the target User. (required)
        :type id: str
        :param users_following_create_request:
        :type users_following_create_request: UsersFollowingCreateRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(UsersFollowingCreateResponse, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'id',
            'users_following_create_request'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in local_var_params['kwargs'].items():
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method users_id_follow" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        collection_formats = {}

        path_params = {}
        if local_var_params['id']:
            path_params['id'] = local_var_params['id']

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        if local_var_params['users_following_create_request']:
            body_params = local_var_params['users_following_create_request']

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'application/problem+json'])  # noqa: E501

        # HTTP header `Content-Type`
        content_types_list = local_var_params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if content_types_list:
                header_params['Content-Type'] = content_types_list

        # Authentication setting
        auth_settings = ['OAuth2UserToken', 'UserToken']  # noqa: E501

        response_types_map = {
            200: "UsersFollowingCreateResponse",
        }

        return self.api_client.call_api(
            '/2/users/{id}/following', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    @validate_arguments
    def users_id_followers(self, id : Annotated[constr(strict=True, regex=r'/^[0-9]{1,19}$/'), Field(..., description="The ID of the User to lookup.")], max_results : Annotated[Optional[conint(strict=True, ge=1000, le=1)], Field(description="The maximum number of results.")] = None, pagination_token : Annotated[Optional[constr(strict=True, min_length=16)], Field(description="This parameter is used to get a specified 'page' of results.")] = None, user_fields : Annotated[Optional[List[Literal['created_at', 'description', 'entities', 'id', 'location', 'name', 'pinned_tweet_id', 'profile_image_url', 'protected', 'public_metrics', 'url', 'username', 'verified', 'withheld']]], Field(description="A comma separated list of User fields to display.", unique_items=True)] = None, expansions : Annotated[Optional[List[Literal['pinned_tweet_id']]], Field(description="A comma separated list of fields to expand.", unique_items=True)] = None, tweet_fields : Annotated[Optional[List[Literal['attachments', 'author_id', 'context_annotations', 'conversation_id', 'created_at', 'entities', 'geo', 'id', 'in_reply_to_user_id', 'lang', 'non_public_metrics', 'organic_metrics', 'possibly_sensitive', 'promoted_metrics', 'public_metrics', 'referenced_tweets', 'reply_settings', 'source', 'text', 'withheld']]], Field(description="A comma separated list of Tweet fields to display.", unique_items=True)] = None, **kwargs) -> Get2UsersIdFollowersResponse:  # noqa: E501
        """Followers by User ID  # noqa: E501

        Returns a list of Users who are followers of the specified User ID.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.users_id_followers(id, max_results, pagination_token, user_fields, expansions, tweet_fields, async_req=True)
        >>> result = thread.get()

        :param id: The ID of the User to lookup. (required)
        :type id: str
        :param max_results: The maximum number of results.
        :type max_results: int
        :param pagination_token: This parameter is used to get a specified 'page' of results.
        :type pagination_token: str
        :param user_fields: A comma separated list of User fields to display.
        :type user_fields: List[str]
        :param expansions: A comma separated list of fields to expand.
        :type expansions: List[str]
        :param tweet_fields: A comma separated list of Tweet fields to display.
        :type tweet_fields: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: Get2UsersIdFollowersResponse
        """
        kwargs['_return_http_data_only'] = True
        return self.users_id_followers_with_http_info(id, max_results, pagination_token, user_fields, expansions, tweet_fields, **kwargs)  # noqa: E501

    @validate_arguments
    def users_id_followers_with_http_info(self, id : Annotated[constr(strict=True, regex=r'/^[0-9]{1,19}$/'), Field(..., description="The ID of the User to lookup.")], max_results : Annotated[Optional[conint(strict=True, ge=1000, le=1)], Field(description="The maximum number of results.")] = None, pagination_token : Annotated[Optional[constr(strict=True, min_length=16)], Field(description="This parameter is used to get a specified 'page' of results.")] = None, user_fields : Annotated[Optional[List[Literal['created_at', 'description', 'entities', 'id', 'location', 'name', 'pinned_tweet_id', 'profile_image_url', 'protected', 'public_metrics', 'url', 'username', 'verified', 'withheld']]], Field(description="A comma separated list of User fields to display.", unique_items=True)] = None, expansions : Annotated[Optional[List[Literal['pinned_tweet_id']]], Field(description="A comma separated list of fields to expand.", unique_items=True)] = None, tweet_fields : Annotated[Optional[List[Literal['attachments', 'author_id', 'context_annotations', 'conversation_id', 'created_at', 'entities', 'geo', 'id', 'in_reply_to_user_id', 'lang', 'non_public_metrics', 'organic_metrics', 'possibly_sensitive', 'promoted_metrics', 'public_metrics', 'referenced_tweets', 'reply_settings', 'source', 'text', 'withheld']]], Field(description="A comma separated list of Tweet fields to display.", unique_items=True)] = None, **kwargs):  # noqa: E501
        """Followers by User ID  # noqa: E501

        Returns a list of Users who are followers of the specified User ID.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.users_id_followers_with_http_info(id, max_results, pagination_token, user_fields, expansions, tweet_fields, async_req=True)
        >>> result = thread.get()

        :param id: The ID of the User to lookup. (required)
        :type id: str
        :param max_results: The maximum number of results.
        :type max_results: int
        :param pagination_token: This parameter is used to get a specified 'page' of results.
        :type pagination_token: str
        :param user_fields: A comma separated list of User fields to display.
        :type user_fields: List[str]
        :param expansions: A comma separated list of fields to expand.
        :type expansions: List[str]
        :param tweet_fields: A comma separated list of Tweet fields to display.
        :type tweet_fields: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(Get2UsersIdFollowersResponse, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'id',
            'max_results',
            'pagination_token',
            'user_fields',
            'expansions',
            'tweet_fields'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in local_var_params['kwargs'].items():
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method users_id_followers" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        collection_formats = {}

        path_params = {}
        if local_var_params['id']:
            path_params['id'] = local_var_params['id']

        query_params = []
        if local_var_params.get('max_results') is not None:  # noqa: E501
            query_params.append(('max_results', local_var_params['max_results']))
        if local_var_params.get('pagination_token') is not None:  # noqa: E501
            query_params.append(('pagination_token', local_var_params['pagination_token']))
        if local_var_params.get('user_fields') is not None:  # noqa: E501
            query_params.append(('user.fields', local_var_params['user_fields']))
            collection_formats['user.fields'] = 'csv'
        if local_var_params.get('expansions') is not None:  # noqa: E501
            query_params.append(('expansions', local_var_params['expansions']))
            collection_formats['expansions'] = 'csv'
        if local_var_params.get('tweet_fields') is not None:  # noqa: E501
            query_params.append(('tweet.fields', local_var_params['tweet_fields']))
            collection_formats['tweet.fields'] = 'csv'

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'application/problem+json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BearerToken', 'OAuth2UserToken', 'UserToken']  # noqa: E501

        response_types_map = {
            200: "Get2UsersIdFollowersResponse",
        }

        return self.api_client.call_api(
            '/2/users/{id}/followers', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    @validate_arguments
    def users_id_following(self, id : Annotated[constr(strict=True, regex=r'/^[0-9]{1,19}$/'), Field(..., description="The ID of the User to lookup.")], max_results : Annotated[Optional[conint(strict=True, ge=1000, le=1)], Field(description="The maximum number of results.")] = None, pagination_token : Annotated[Optional[constr(strict=True, min_length=16)], Field(description="This parameter is used to get a specified 'page' of results.")] = None, user_fields : Annotated[Optional[List[Literal['created_at', 'description', 'entities', 'id', 'location', 'name', 'pinned_tweet_id', 'profile_image_url', 'protected', 'public_metrics', 'url', 'username', 'verified', 'withheld']]], Field(description="A comma separated list of User fields to display.", unique_items=True)] = None, expansions : Annotated[Optional[List[Literal['pinned_tweet_id']]], Field(description="A comma separated list of fields to expand.", unique_items=True)] = None, tweet_fields : Annotated[Optional[List[Literal['attachments', 'author_id', 'context_annotations', 'conversation_id', 'created_at', 'entities', 'geo', 'id', 'in_reply_to_user_id', 'lang', 'non_public_metrics', 'organic_metrics', 'possibly_sensitive', 'promoted_metrics', 'public_metrics', 'referenced_tweets', 'reply_settings', 'source', 'text', 'withheld']]], Field(description="A comma separated list of Tweet fields to display.", unique_items=True)] = None, **kwargs) -> Get2UsersIdFollowingResponse:  # noqa: E501
        """Following by User ID  # noqa: E501

        Returns a list of Users that are being followed by the provided User ID  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.users_id_following(id, max_results, pagination_token, user_fields, expansions, tweet_fields, async_req=True)
        >>> result = thread.get()

        :param id: The ID of the User to lookup. (required)
        :type id: str
        :param max_results: The maximum number of results.
        :type max_results: int
        :param pagination_token: This parameter is used to get a specified 'page' of results.
        :type pagination_token: str
        :param user_fields: A comma separated list of User fields to display.
        :type user_fields: List[str]
        :param expansions: A comma separated list of fields to expand.
        :type expansions: List[str]
        :param tweet_fields: A comma separated list of Tweet fields to display.
        :type tweet_fields: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: Get2UsersIdFollowingResponse
        """
        kwargs['_return_http_data_only'] = True
        return self.users_id_following_with_http_info(id, max_results, pagination_token, user_fields, expansions, tweet_fields, **kwargs)  # noqa: E501

    @validate_arguments
    def users_id_following_with_http_info(self, id : Annotated[constr(strict=True, regex=r'/^[0-9]{1,19}$/'), Field(..., description="The ID of the User to lookup.")], max_results : Annotated[Optional[conint(strict=True, ge=1000, le=1)], Field(description="The maximum number of results.")] = None, pagination_token : Annotated[Optional[constr(strict=True, min_length=16)], Field(description="This parameter is used to get a specified 'page' of results.")] = None, user_fields : Annotated[Optional[List[Literal['created_at', 'description', 'entities', 'id', 'location', 'name', 'pinned_tweet_id', 'profile_image_url', 'protected', 'public_metrics', 'url', 'username', 'verified', 'withheld']]], Field(description="A comma separated list of User fields to display.", unique_items=True)] = None, expansions : Annotated[Optional[List[Literal['pinned_tweet_id']]], Field(description="A comma separated list of fields to expand.", unique_items=True)] = None, tweet_fields : Annotated[Optional[List[Literal['attachments', 'author_id', 'context_annotations', 'conversation_id', 'created_at', 'entities', 'geo', 'id', 'in_reply_to_user_id', 'lang', 'non_public_metrics', 'organic_metrics', 'possibly_sensitive', 'promoted_metrics', 'public_metrics', 'referenced_tweets', 'reply_settings', 'source', 'text', 'withheld']]], Field(description="A comma separated list of Tweet fields to display.", unique_items=True)] = None, **kwargs):  # noqa: E501
        """Following by User ID  # noqa: E501

        Returns a list of Users that are being followed by the provided User ID  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.users_id_following_with_http_info(id, max_results, pagination_token, user_fields, expansions, tweet_fields, async_req=True)
        >>> result = thread.get()

        :param id: The ID of the User to lookup. (required)
        :type id: str
        :param max_results: The maximum number of results.
        :type max_results: int
        :param pagination_token: This parameter is used to get a specified 'page' of results.
        :type pagination_token: str
        :param user_fields: A comma separated list of User fields to display.
        :type user_fields: List[str]
        :param expansions: A comma separated list of fields to expand.
        :type expansions: List[str]
        :param tweet_fields: A comma separated list of Tweet fields to display.
        :type tweet_fields: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(Get2UsersIdFollowingResponse, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'id',
            'max_results',
            'pagination_token',
            'user_fields',
            'expansions',
            'tweet_fields'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in local_var_params['kwargs'].items():
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method users_id_following" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        collection_formats = {}

        path_params = {}
        if local_var_params['id']:
            path_params['id'] = local_var_params['id']

        query_params = []
        if local_var_params.get('max_results') is not None:  # noqa: E501
            query_params.append(('max_results', local_var_params['max_results']))
        if local_var_params.get('pagination_token') is not None:  # noqa: E501
            query_params.append(('pagination_token', local_var_params['pagination_token']))
        if local_var_params.get('user_fields') is not None:  # noqa: E501
            query_params.append(('user.fields', local_var_params['user_fields']))
            collection_formats['user.fields'] = 'csv'
        if local_var_params.get('expansions') is not None:  # noqa: E501
            query_params.append(('expansions', local_var_params['expansions']))
            collection_formats['expansions'] = 'csv'
        if local_var_params.get('tweet_fields') is not None:  # noqa: E501
            query_params.append(('tweet.fields', local_var_params['tweet_fields']))
            collection_formats['tweet.fields'] = 'csv'

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'application/problem+json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BearerToken', 'OAuth2UserToken', 'UserToken']  # noqa: E501

        response_types_map = {
            200: "Get2UsersIdFollowingResponse",
        }

        return self.api_client.call_api(
            '/2/users/{id}/following', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    @validate_arguments
    def users_id_mute(self, id : Annotated[StrictStr, Field(..., description="The ID of the authenticated source User that is requesting to mute the target User.")], mute_user_request : Optional[MuteUserRequest] = None, **kwargs) -> MuteUserMutationResponse:  # noqa: E501
        """Mute User by User ID.  # noqa: E501

        Causes the User (in the path) to mute the target User. The User (in the path) must match the User context authorizing the request.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.users_id_mute(id, mute_user_request, async_req=True)
        >>> result = thread.get()

        :param id: The ID of the authenticated source User that is requesting to mute the target User. (required)
        :type id: str
        :param mute_user_request:
        :type mute_user_request: MuteUserRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: MuteUserMutationResponse
        """
        kwargs['_return_http_data_only'] = True
        return self.users_id_mute_with_http_info(id, mute_user_request, **kwargs)  # noqa: E501

    @validate_arguments
    def users_id_mute_with_http_info(self, id : Annotated[StrictStr, Field(..., description="The ID of the authenticated source User that is requesting to mute the target User.")], mute_user_request : Optional[MuteUserRequest] = None, **kwargs):  # noqa: E501
        """Mute User by User ID.  # noqa: E501

        Causes the User (in the path) to mute the target User. The User (in the path) must match the User context authorizing the request.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.users_id_mute_with_http_info(id, mute_user_request, async_req=True)
        >>> result = thread.get()

        :param id: The ID of the authenticated source User that is requesting to mute the target User. (required)
        :type id: str
        :param mute_user_request:
        :type mute_user_request: MuteUserRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(MuteUserMutationResponse, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'id',
            'mute_user_request'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in local_var_params['kwargs'].items():
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method users_id_mute" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        collection_formats = {}

        path_params = {}
        if local_var_params['id']:
            path_params['id'] = local_var_params['id']

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        if local_var_params['mute_user_request']:
            body_params = local_var_params['mute_user_request']

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'application/problem+json'])  # noqa: E501

        # HTTP header `Content-Type`
        content_types_list = local_var_params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if content_types_list:
                header_params['Content-Type'] = content_types_list

        # Authentication setting
        auth_settings = ['OAuth2UserToken', 'UserToken']  # noqa: E501

        response_types_map = {
            200: "MuteUserMutationResponse",
        }

        return self.api_client.call_api(
            '/2/users/{id}/muting', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    @validate_arguments
    def users_id_muting(self, id : Annotated[StrictStr, Field(..., description="The ID of the authenticated source User for whom to return results.")], max_results : Annotated[Optional[conint(strict=True, ge=1000, le=1)], Field(description="The maximum number of results.")] = None, pagination_token : Annotated[Optional[constr(strict=True, max_length=19, min_length=1)], Field(description="This parameter is used to get the next 'page' of results.")] = None, user_fields : Annotated[Optional[List[Literal['created_at', 'description', 'entities', 'id', 'location', 'name', 'pinned_tweet_id', 'profile_image_url', 'protected', 'public_metrics', 'url', 'username', 'verified', 'withheld']]], Field(description="A comma separated list of User fields to display.", unique_items=True)] = None, expansions : Annotated[Optional[List[Literal['pinned_tweet_id']]], Field(description="A comma separated list of fields to expand.", unique_items=True)] = None, tweet_fields : Annotated[Optional[List[Literal['attachments', 'author_id', 'context_annotations', 'conversation_id', 'created_at', 'entities', 'geo', 'id', 'in_reply_to_user_id', 'lang', 'non_public_metrics', 'organic_metrics', 'possibly_sensitive', 'promoted_metrics', 'public_metrics', 'referenced_tweets', 'reply_settings', 'source', 'text', 'withheld']]], Field(description="A comma separated list of Tweet fields to display.", unique_items=True)] = None, **kwargs) -> Get2UsersIdMutingResponse:  # noqa: E501
        """Returns User objects that are muted by the provided User ID  # noqa: E501

        Returns a list of Users that are muted by the provided User ID  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.users_id_muting(id, max_results, pagination_token, user_fields, expansions, tweet_fields, async_req=True)
        >>> result = thread.get()

        :param id: The ID of the authenticated source User for whom to return results. (required)
        :type id: str
        :param max_results: The maximum number of results.
        :type max_results: int
        :param pagination_token: This parameter is used to get the next 'page' of results.
        :type pagination_token: str
        :param user_fields: A comma separated list of User fields to display.
        :type user_fields: List[str]
        :param expansions: A comma separated list of fields to expand.
        :type expansions: List[str]
        :param tweet_fields: A comma separated list of Tweet fields to display.
        :type tweet_fields: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: Get2UsersIdMutingResponse
        """
        kwargs['_return_http_data_only'] = True
        return self.users_id_muting_with_http_info(id, max_results, pagination_token, user_fields, expansions, tweet_fields, **kwargs)  # noqa: E501

    @validate_arguments
    def users_id_muting_with_http_info(self, id : Annotated[StrictStr, Field(..., description="The ID of the authenticated source User for whom to return results.")], max_results : Annotated[Optional[conint(strict=True, ge=1000, le=1)], Field(description="The maximum number of results.")] = None, pagination_token : Annotated[Optional[constr(strict=True, max_length=19, min_length=1)], Field(description="This parameter is used to get the next 'page' of results.")] = None, user_fields : Annotated[Optional[List[Literal['created_at', 'description', 'entities', 'id', 'location', 'name', 'pinned_tweet_id', 'profile_image_url', 'protected', 'public_metrics', 'url', 'username', 'verified', 'withheld']]], Field(description="A comma separated list of User fields to display.", unique_items=True)] = None, expansions : Annotated[Optional[List[Literal['pinned_tweet_id']]], Field(description="A comma separated list of fields to expand.", unique_items=True)] = None, tweet_fields : Annotated[Optional[List[Literal['attachments', 'author_id', 'context_annotations', 'conversation_id', 'created_at', 'entities', 'geo', 'id', 'in_reply_to_user_id', 'lang', 'non_public_metrics', 'organic_metrics', 'possibly_sensitive', 'promoted_metrics', 'public_metrics', 'referenced_tweets', 'reply_settings', 'source', 'text', 'withheld']]], Field(description="A comma separated list of Tweet fields to display.", unique_items=True)] = None, **kwargs):  # noqa: E501
        """Returns User objects that are muted by the provided User ID  # noqa: E501

        Returns a list of Users that are muted by the provided User ID  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.users_id_muting_with_http_info(id, max_results, pagination_token, user_fields, expansions, tweet_fields, async_req=True)
        >>> result = thread.get()

        :param id: The ID of the authenticated source User for whom to return results. (required)
        :type id: str
        :param max_results: The maximum number of results.
        :type max_results: int
        :param pagination_token: This parameter is used to get the next 'page' of results.
        :type pagination_token: str
        :param user_fields: A comma separated list of User fields to display.
        :type user_fields: List[str]
        :param expansions: A comma separated list of fields to expand.
        :type expansions: List[str]
        :param tweet_fields: A comma separated list of Tweet fields to display.
        :type tweet_fields: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(Get2UsersIdMutingResponse, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'id',
            'max_results',
            'pagination_token',
            'user_fields',
            'expansions',
            'tweet_fields'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in local_var_params['kwargs'].items():
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method users_id_muting" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        collection_formats = {}

        path_params = {}
        if local_var_params['id']:
            path_params['id'] = local_var_params['id']

        query_params = []
        if local_var_params.get('max_results') is not None:  # noqa: E501
            query_params.append(('max_results', local_var_params['max_results']))
        if local_var_params.get('pagination_token') is not None:  # noqa: E501
            query_params.append(('pagination_token', local_var_params['pagination_token']))
        if local_var_params.get('user_fields') is not None:  # noqa: E501
            query_params.append(('user.fields', local_var_params['user_fields']))
            collection_formats['user.fields'] = 'csv'
        if local_var_params.get('expansions') is not None:  # noqa: E501
            query_params.append(('expansions', local_var_params['expansions']))
            collection_formats['expansions'] = 'csv'
        if local_var_params.get('tweet_fields') is not None:  # noqa: E501
            query_params.append(('tweet.fields', local_var_params['tweet_fields']))
            collection_formats['tweet.fields'] = 'csv'

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'application/problem+json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['OAuth2UserToken', 'UserToken']  # noqa: E501

        response_types_map = {
            200: "Get2UsersIdMutingResponse",
        }

        return self.api_client.call_api(
            '/2/users/{id}/muting', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    @validate_arguments
    def users_id_unblock(self, source_user_id : Annotated[StrictStr, Field(..., description="The ID of the authenticated source User that is requesting to unblock the target User.")], target_user_id : Annotated[constr(strict=True, regex=r'/^[0-9]{1,19}$/'), Field(..., description="The ID of the User that the source User is requesting to unblock.")], **kwargs) -> BlockUserMutationResponse:  # noqa: E501
        """Unblock User by User ID  # noqa: E501

        Causes the source User to unblock the target User. The source User must match the User context authorizing the request  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.users_id_unblock(source_user_id, target_user_id, async_req=True)
        >>> result = thread.get()

        :param source_user_id: The ID of the authenticated source User that is requesting to unblock the target User. (required)
        :type source_user_id: str
        :param target_user_id: The ID of the User that the source User is requesting to unblock. (required)
        :type target_user_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: BlockUserMutationResponse
        """
        kwargs['_return_http_data_only'] = True
        return self.users_id_unblock_with_http_info(source_user_id, target_user_id, **kwargs)  # noqa: E501

    @validate_arguments
    def users_id_unblock_with_http_info(self, source_user_id : Annotated[StrictStr, Field(..., description="The ID of the authenticated source User that is requesting to unblock the target User.")], target_user_id : Annotated[constr(strict=True, regex=r'/^[0-9]{1,19}$/'), Field(..., description="The ID of the User that the source User is requesting to unblock.")], **kwargs):  # noqa: E501
        """Unblock User by User ID  # noqa: E501

        Causes the source User to unblock the target User. The source User must match the User context authorizing the request  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.users_id_unblock_with_http_info(source_user_id, target_user_id, async_req=True)
        >>> result = thread.get()

        :param source_user_id: The ID of the authenticated source User that is requesting to unblock the target User. (required)
        :type source_user_id: str
        :param target_user_id: The ID of the User that the source User is requesting to unblock. (required)
        :type target_user_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(BlockUserMutationResponse, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'source_user_id',
            'target_user_id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in local_var_params['kwargs'].items():
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method users_id_unblock" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        collection_formats = {}

        path_params = {}
        if local_var_params['source_user_id']:
            path_params['source_user_id'] = local_var_params['source_user_id']
        if local_var_params['target_user_id']:
            path_params['target_user_id'] = local_var_params['target_user_id']

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'application/problem+json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['OAuth2UserToken', 'UserToken']  # noqa: E501

        response_types_map = {
            200: "BlockUserMutationResponse",
        }

        return self.api_client.call_api(
            '/2/users/{source_user_id}/blocking/{target_user_id}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    @validate_arguments
    def users_id_unfollow(self, source_user_id : Annotated[StrictStr, Field(..., description="The ID of the authenticated source User that is requesting to unfollow the target User.")], target_user_id : Annotated[constr(strict=True, regex=r'/^[0-9]{1,19}$/'), Field(..., description="The ID of the User that the source User is requesting to unfollow.")], **kwargs) -> UsersFollowingDeleteResponse:  # noqa: E501
        """Unfollow User  # noqa: E501

        Causes the source User to unfollow the target User. The source User must match the User context authorizing the request  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.users_id_unfollow(source_user_id, target_user_id, async_req=True)
        >>> result = thread.get()

        :param source_user_id: The ID of the authenticated source User that is requesting to unfollow the target User. (required)
        :type source_user_id: str
        :param target_user_id: The ID of the User that the source User is requesting to unfollow. (required)
        :type target_user_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: UsersFollowingDeleteResponse
        """
        kwargs['_return_http_data_only'] = True
        return self.users_id_unfollow_with_http_info(source_user_id, target_user_id, **kwargs)  # noqa: E501

    @validate_arguments
    def users_id_unfollow_with_http_info(self, source_user_id : Annotated[StrictStr, Field(..., description="The ID of the authenticated source User that is requesting to unfollow the target User.")], target_user_id : Annotated[constr(strict=True, regex=r'/^[0-9]{1,19}$/'), Field(..., description="The ID of the User that the source User is requesting to unfollow.")], **kwargs):  # noqa: E501
        """Unfollow User  # noqa: E501

        Causes the source User to unfollow the target User. The source User must match the User context authorizing the request  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.users_id_unfollow_with_http_info(source_user_id, target_user_id, async_req=True)
        >>> result = thread.get()

        :param source_user_id: The ID of the authenticated source User that is requesting to unfollow the target User. (required)
        :type source_user_id: str
        :param target_user_id: The ID of the User that the source User is requesting to unfollow. (required)
        :type target_user_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(UsersFollowingDeleteResponse, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'source_user_id',
            'target_user_id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in local_var_params['kwargs'].items():
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method users_id_unfollow" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        collection_formats = {}

        path_params = {}
        if local_var_params['source_user_id']:
            path_params['source_user_id'] = local_var_params['source_user_id']
        if local_var_params['target_user_id']:
            path_params['target_user_id'] = local_var_params['target_user_id']

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'application/problem+json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['OAuth2UserToken', 'UserToken']  # noqa: E501

        response_types_map = {
            200: "UsersFollowingDeleteResponse",
        }

        return self.api_client.call_api(
            '/2/users/{source_user_id}/following/{target_user_id}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    @validate_arguments
    def users_id_unmute(self, source_user_id : Annotated[StrictStr, Field(..., description="The ID of the authenticated source User that is requesting to unmute the target User.")], target_user_id : Annotated[constr(strict=True, regex=r'/^[0-9]{1,19}$/'), Field(..., description="The ID of the User that the source User is requesting to unmute.")], **kwargs) -> MuteUserMutationResponse:  # noqa: E501
        """Unmute User by User ID  # noqa: E501

        Causes the source User to unmute the target User. The source User must match the User context authorizing the request  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.users_id_unmute(source_user_id, target_user_id, async_req=True)
        >>> result = thread.get()

        :param source_user_id: The ID of the authenticated source User that is requesting to unmute the target User. (required)
        :type source_user_id: str
        :param target_user_id: The ID of the User that the source User is requesting to unmute. (required)
        :type target_user_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: MuteUserMutationResponse
        """
        kwargs['_return_http_data_only'] = True
        return self.users_id_unmute_with_http_info(source_user_id, target_user_id, **kwargs)  # noqa: E501

    @validate_arguments
    def users_id_unmute_with_http_info(self, source_user_id : Annotated[StrictStr, Field(..., description="The ID of the authenticated source User that is requesting to unmute the target User.")], target_user_id : Annotated[constr(strict=True, regex=r'/^[0-9]{1,19}$/'), Field(..., description="The ID of the User that the source User is requesting to unmute.")], **kwargs):  # noqa: E501
        """Unmute User by User ID  # noqa: E501

        Causes the source User to unmute the target User. The source User must match the User context authorizing the request  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.users_id_unmute_with_http_info(source_user_id, target_user_id, async_req=True)
        >>> result = thread.get()

        :param source_user_id: The ID of the authenticated source User that is requesting to unmute the target User. (required)
        :type source_user_id: str
        :param target_user_id: The ID of the User that the source User is requesting to unmute. (required)
        :type target_user_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(MuteUserMutationResponse, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'source_user_id',
            'target_user_id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in local_var_params['kwargs'].items():
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method users_id_unmute" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        collection_formats = {}

        path_params = {}
        if local_var_params['source_user_id']:
            path_params['source_user_id'] = local_var_params['source_user_id']
        if local_var_params['target_user_id']:
            path_params['target_user_id'] = local_var_params['target_user_id']

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'application/problem+json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['OAuth2UserToken', 'UserToken']  # noqa: E501

        response_types_map = {
            200: "MuteUserMutationResponse",
        }

        return self.api_client.call_api(
            '/2/users/{source_user_id}/muting/{target_user_id}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))
