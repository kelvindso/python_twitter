# coding: utf-8

"""
    Twitter API v2

    Twitter API v2 available endpoints  # noqa: E501

    The version of the OpenAPI document: 2.49
    Generated by: https://openapi-generator.tech
"""


from __future__ import absolute_import

import re  # noqa: F401

from pydantic import validate_arguments, ValidationError
from typing_extensions import Annotated

from datetime import datetime

from pydantic import Field, StrictStr, conint, constr

from typing import List, Literal, Optional

from twitter import models
from twitter.models import CreateComplianceJobRequest, CreateComplianceJobResponse, Get2ComplianceJobsIdResponse, Get2ComplianceJobsResponse, TweetComplianceStreamResponse, UserComplianceStreamResponse

from twitter.api_client import ApiClient
from twitter.exceptions import (  # noqa: F401
    ApiTypeError,
    ApiValueError
)


class ComplianceApi(object):
    """NOTE: This class is auto generated by OpenAPI Generator
    Ref: https://openapi-generator.tech

    Do not edit the class manually.
    """

    def __init__(self, api_client=None):
        if api_client is None:
            api_client = ApiClient()
        self.api_client = api_client

    @validate_arguments
    def create_batch_compliance_job(self, create_compliance_job_request : CreateComplianceJobRequest, **kwargs) -> CreateComplianceJobResponse:  # noqa: E501
        """Create compliance job  # noqa: E501

        Creates a compliance for the given job type  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.create_batch_compliance_job(create_compliance_job_request, async_req=True)
        >>> result = thread.get()

        :param create_compliance_job_request: (required)
        :type create_compliance_job_request: CreateComplianceJobRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: CreateComplianceJobResponse
        """
        kwargs['_return_http_data_only'] = True
        return self.create_batch_compliance_job_with_http_info(create_compliance_job_request, **kwargs)  # noqa: E501

    @validate_arguments
    def create_batch_compliance_job_with_http_info(self, create_compliance_job_request : CreateComplianceJobRequest, **kwargs):  # noqa: E501
        """Create compliance job  # noqa: E501

        Creates a compliance for the given job type  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.create_batch_compliance_job_with_http_info(create_compliance_job_request, async_req=True)
        >>> result = thread.get()

        :param create_compliance_job_request: (required)
        :type create_compliance_job_request: CreateComplianceJobRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(CreateComplianceJobResponse, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'create_compliance_job_request'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in local_var_params['kwargs'].items():
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_batch_compliance_job" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        if local_var_params['create_compliance_job_request']:
            body_params = local_var_params['create_compliance_job_request']

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'application/problem+json'])  # noqa: E501

        # HTTP header `Content-Type`
        content_types_list = local_var_params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if content_types_list:
                header_params['Content-Type'] = content_types_list

        # Authentication setting
        auth_settings = ['BearerToken']  # noqa: E501

        response_types_map = {
            200: "CreateComplianceJobResponse",
        }

        return self.api_client.call_api(
            '/2/compliance/jobs', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    @validate_arguments
    def get_batch_compliance_job(self, id : Annotated[constr(strict=True, regex=r'/^[0-9]{1,19}$/'), Field(..., description="The ID of the Compliance Job to retrieve.")], compliance_job_fields : Annotated[Optional[List[Literal['created_at', 'download_expires_at', 'download_url', 'id', 'name', 'resumable', 'status', 'type', 'upload_expires_at', 'upload_url']]], Field(description="A comma separated list of ComplianceJob fields to display.", unique_items=True)] = None, **kwargs) -> Get2ComplianceJobsIdResponse:  # noqa: E501
        """Get Compliance Job  # noqa: E501

        Returns a single Compliance Job by ID  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_batch_compliance_job(id, compliance_job_fields, async_req=True)
        >>> result = thread.get()

        :param id: The ID of the Compliance Job to retrieve. (required)
        :type id: str
        :param compliance_job_fields: A comma separated list of ComplianceJob fields to display.
        :type compliance_job_fields: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: Get2ComplianceJobsIdResponse
        """
        kwargs['_return_http_data_only'] = True
        return self.get_batch_compliance_job_with_http_info(id, compliance_job_fields, **kwargs)  # noqa: E501

    @validate_arguments
    def get_batch_compliance_job_with_http_info(self, id : Annotated[constr(strict=True, regex=r'/^[0-9]{1,19}$/'), Field(..., description="The ID of the Compliance Job to retrieve.")], compliance_job_fields : Annotated[Optional[List[Literal['created_at', 'download_expires_at', 'download_url', 'id', 'name', 'resumable', 'status', 'type', 'upload_expires_at', 'upload_url']]], Field(description="A comma separated list of ComplianceJob fields to display.", unique_items=True)] = None, **kwargs):  # noqa: E501
        """Get Compliance Job  # noqa: E501

        Returns a single Compliance Job by ID  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_batch_compliance_job_with_http_info(id, compliance_job_fields, async_req=True)
        >>> result = thread.get()

        :param id: The ID of the Compliance Job to retrieve. (required)
        :type id: str
        :param compliance_job_fields: A comma separated list of ComplianceJob fields to display.
        :type compliance_job_fields: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(Get2ComplianceJobsIdResponse, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'id',
            'compliance_job_fields'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in local_var_params['kwargs'].items():
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_batch_compliance_job" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        collection_formats = {}

        path_params = {}
        if local_var_params['id']:
            path_params['id'] = local_var_params['id']

        query_params = []
        if local_var_params.get('compliance_job_fields') is not None:  # noqa: E501
            query_params.append(('compliance_job.fields', local_var_params['compliance_job_fields']))
            collection_formats['compliance_job.fields'] = 'csv'

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'application/problem+json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BearerToken']  # noqa: E501

        response_types_map = {
            200: "Get2ComplianceJobsIdResponse",
        }

        return self.api_client.call_api(
            '/2/compliance/jobs/{id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    @validate_arguments
    def get_tweets_compliance_stream(self, partition : Annotated[conint(strict=True, ge=4, le=1), Field(..., description="The partition number.")], backfill_minutes : Annotated[Optional[conint(strict=True, ge=5, le=0)], Field(description="The number of minutes of backfill requested.")] = None, start_time : Annotated[Optional[datetime], Field(description="YYYY-MM-DDTHH:mm:ssZ. The earliest UTC timestamp from which the Tweet Compliance events will be provided.")] = None, end_time : Annotated[Optional[datetime], Field(description="YYYY-MM-DDTHH:mm:ssZ. The latest UTC timestamp to which the Tweet Compliance events will be provided.")] = None, **kwargs) -> TweetComplianceStreamResponse:  # noqa: E501
        """Tweets Compliance stream  # noqa: E501

        Streams 100% of compliance data for Tweets  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_tweets_compliance_stream(partition, backfill_minutes, start_time, end_time, async_req=True)
        >>> result = thread.get()

        :param partition: The partition number. (required)
        :type partition: int
        :param backfill_minutes: The number of minutes of backfill requested.
        :type backfill_minutes: int
        :param start_time: YYYY-MM-DDTHH:mm:ssZ. The earliest UTC timestamp from which the Tweet Compliance events will be provided.
        :type start_time: datetime
        :param end_time: YYYY-MM-DDTHH:mm:ssZ. The latest UTC timestamp to which the Tweet Compliance events will be provided.
        :type end_time: datetime
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: TweetComplianceStreamResponse
        """
        kwargs['_return_http_data_only'] = True
        return self.get_tweets_compliance_stream_with_http_info(partition, backfill_minutes, start_time, end_time, **kwargs)  # noqa: E501

    @validate_arguments
    def get_tweets_compliance_stream_with_http_info(self, partition : Annotated[conint(strict=True, ge=4, le=1), Field(..., description="The partition number.")], backfill_minutes : Annotated[Optional[conint(strict=True, ge=5, le=0)], Field(description="The number of minutes of backfill requested.")] = None, start_time : Annotated[Optional[datetime], Field(description="YYYY-MM-DDTHH:mm:ssZ. The earliest UTC timestamp from which the Tweet Compliance events will be provided.")] = None, end_time : Annotated[Optional[datetime], Field(description="YYYY-MM-DDTHH:mm:ssZ. The latest UTC timestamp to which the Tweet Compliance events will be provided.")] = None, **kwargs):  # noqa: E501
        """Tweets Compliance stream  # noqa: E501

        Streams 100% of compliance data for Tweets  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_tweets_compliance_stream_with_http_info(partition, backfill_minutes, start_time, end_time, async_req=True)
        >>> result = thread.get()

        :param partition: The partition number. (required)
        :type partition: int
        :param backfill_minutes: The number of minutes of backfill requested.
        :type backfill_minutes: int
        :param start_time: YYYY-MM-DDTHH:mm:ssZ. The earliest UTC timestamp from which the Tweet Compliance events will be provided.
        :type start_time: datetime
        :param end_time: YYYY-MM-DDTHH:mm:ssZ. The latest UTC timestamp to which the Tweet Compliance events will be provided.
        :type end_time: datetime
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(TweetComplianceStreamResponse, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'partition',
            'backfill_minutes',
            'start_time',
            'end_time'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in local_var_params['kwargs'].items():
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_tweets_compliance_stream" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if local_var_params.get('backfill_minutes') is not None:  # noqa: E501
            query_params.append(('backfill_minutes', local_var_params['backfill_minutes']))
        if local_var_params.get('partition') is not None:  # noqa: E501
            query_params.append(('partition', local_var_params['partition']))
        if local_var_params.get('start_time') is not None:  # noqa: E501
            query_params.append(('start_time', local_var_params['start_time']))
        if local_var_params.get('end_time') is not None:  # noqa: E501
            query_params.append(('end_time', local_var_params['end_time']))

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'application/problem+json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BearerToken']  # noqa: E501

        response_types_map = {
            200: "TweetComplianceStreamResponse",
        }

        return self.api_client.call_api(
            '/2/tweets/compliance/stream', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    @validate_arguments
    def get_users_compliance_stream(self, partition : Annotated[conint(strict=True, ge=4, le=1), Field(..., description="The partition number.")], backfill_minutes : Annotated[Optional[conint(strict=True, ge=5, le=0)], Field(description="The number of minutes of backfill requested.")] = None, start_time : Annotated[Optional[datetime], Field(description="YYYY-MM-DDTHH:mm:ssZ. The earliest UTC timestamp from which the User Compliance events will be provided.")] = None, end_time : Annotated[Optional[datetime], Field(description="YYYY-MM-DDTHH:mm:ssZ. The latest UTC timestamp from which the User Compliance events will be provided.")] = None, **kwargs) -> UserComplianceStreamResponse:  # noqa: E501
        """Users Compliance stream  # noqa: E501

        Streams 100% of compliance data for Users  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_users_compliance_stream(partition, backfill_minutes, start_time, end_time, async_req=True)
        >>> result = thread.get()

        :param partition: The partition number. (required)
        :type partition: int
        :param backfill_minutes: The number of minutes of backfill requested.
        :type backfill_minutes: int
        :param start_time: YYYY-MM-DDTHH:mm:ssZ. The earliest UTC timestamp from which the User Compliance events will be provided.
        :type start_time: datetime
        :param end_time: YYYY-MM-DDTHH:mm:ssZ. The latest UTC timestamp from which the User Compliance events will be provided.
        :type end_time: datetime
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: UserComplianceStreamResponse
        """
        kwargs['_return_http_data_only'] = True
        return self.get_users_compliance_stream_with_http_info(partition, backfill_minutes, start_time, end_time, **kwargs)  # noqa: E501

    @validate_arguments
    def get_users_compliance_stream_with_http_info(self, partition : Annotated[conint(strict=True, ge=4, le=1), Field(..., description="The partition number.")], backfill_minutes : Annotated[Optional[conint(strict=True, ge=5, le=0)], Field(description="The number of minutes of backfill requested.")] = None, start_time : Annotated[Optional[datetime], Field(description="YYYY-MM-DDTHH:mm:ssZ. The earliest UTC timestamp from which the User Compliance events will be provided.")] = None, end_time : Annotated[Optional[datetime], Field(description="YYYY-MM-DDTHH:mm:ssZ. The latest UTC timestamp from which the User Compliance events will be provided.")] = None, **kwargs):  # noqa: E501
        """Users Compliance stream  # noqa: E501

        Streams 100% of compliance data for Users  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_users_compliance_stream_with_http_info(partition, backfill_minutes, start_time, end_time, async_req=True)
        >>> result = thread.get()

        :param partition: The partition number. (required)
        :type partition: int
        :param backfill_minutes: The number of minutes of backfill requested.
        :type backfill_minutes: int
        :param start_time: YYYY-MM-DDTHH:mm:ssZ. The earliest UTC timestamp from which the User Compliance events will be provided.
        :type start_time: datetime
        :param end_time: YYYY-MM-DDTHH:mm:ssZ. The latest UTC timestamp from which the User Compliance events will be provided.
        :type end_time: datetime
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(UserComplianceStreamResponse, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'partition',
            'backfill_minutes',
            'start_time',
            'end_time'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in local_var_params['kwargs'].items():
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_users_compliance_stream" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if local_var_params.get('backfill_minutes') is not None:  # noqa: E501
            query_params.append(('backfill_minutes', local_var_params['backfill_minutes']))
        if local_var_params.get('partition') is not None:  # noqa: E501
            query_params.append(('partition', local_var_params['partition']))
        if local_var_params.get('start_time') is not None:  # noqa: E501
            query_params.append(('start_time', local_var_params['start_time']))
        if local_var_params.get('end_time') is not None:  # noqa: E501
            query_params.append(('end_time', local_var_params['end_time']))

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'application/problem+json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BearerToken']  # noqa: E501

        response_types_map = {
            200: "UserComplianceStreamResponse",
        }

        return self.api_client.call_api(
            '/2/users/compliance/stream', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    @validate_arguments
    def list_batch_compliance_jobs(self, type : Annotated[StrictStr, Field(..., description="Type of Compliance Job to list.")], status : Annotated[Optional[StrictStr], Field(description="Status of Compliance Job to list.")] = None, compliance_job_fields : Annotated[Optional[List[Literal['created_at', 'download_expires_at', 'download_url', 'id', 'name', 'resumable', 'status', 'type', 'upload_expires_at', 'upload_url']]], Field(description="A comma separated list of ComplianceJob fields to display.", unique_items=True)] = None, **kwargs) -> Get2ComplianceJobsResponse:  # noqa: E501
        """List Compliance Jobs  # noqa: E501

        Returns recent Compliance Jobs for a given job type and optional job status  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.list_batch_compliance_jobs(type, status, compliance_job_fields, async_req=True)
        >>> result = thread.get()

        :param type: Type of Compliance Job to list. (required)
        :type type: str
        :param status: Status of Compliance Job to list.
        :type status: str
        :param compliance_job_fields: A comma separated list of ComplianceJob fields to display.
        :type compliance_job_fields: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: Get2ComplianceJobsResponse
        """
        kwargs['_return_http_data_only'] = True
        return self.list_batch_compliance_jobs_with_http_info(type, status, compliance_job_fields, **kwargs)  # noqa: E501

    @validate_arguments
    def list_batch_compliance_jobs_with_http_info(self, type : Annotated[StrictStr, Field(..., description="Type of Compliance Job to list.")], status : Annotated[Optional[StrictStr], Field(description="Status of Compliance Job to list.")] = None, compliance_job_fields : Annotated[Optional[List[Literal['created_at', 'download_expires_at', 'download_url', 'id', 'name', 'resumable', 'status', 'type', 'upload_expires_at', 'upload_url']]], Field(description="A comma separated list of ComplianceJob fields to display.", unique_items=True)] = None, **kwargs):  # noqa: E501
        """List Compliance Jobs  # noqa: E501

        Returns recent Compliance Jobs for a given job type and optional job status  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.list_batch_compliance_jobs_with_http_info(type, status, compliance_job_fields, async_req=True)
        >>> result = thread.get()

        :param type: Type of Compliance Job to list. (required)
        :type type: str
        :param status: Status of Compliance Job to list.
        :type status: str
        :param compliance_job_fields: A comma separated list of ComplianceJob fields to display.
        :type compliance_job_fields: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(Get2ComplianceJobsResponse, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'type',
            'status',
            'compliance_job_fields'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in local_var_params['kwargs'].items():
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_batch_compliance_jobs" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if local_var_params.get('type') is not None:  # noqa: E501
            query_params.append(('type', local_var_params['type']))
        if local_var_params.get('status') is not None:  # noqa: E501
            query_params.append(('status', local_var_params['status']))
        if local_var_params.get('compliance_job_fields') is not None:  # noqa: E501
            query_params.append(('compliance_job.fields', local_var_params['compliance_job_fields']))
            collection_formats['compliance_job.fields'] = 'csv'

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'application/problem+json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BearerToken']  # noqa: E501

        response_types_map = {
            200: "Get2ComplianceJobsResponse",
        }

        return self.api_client.call_api(
            '/2/compliance/jobs', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))
