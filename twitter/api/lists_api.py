# coding: utf-8

"""
    Twitter API v2

    Twitter API v2 available endpoints  # noqa: E501

    The version of the OpenAPI document: 2.49
    Generated by: https://openapi-generator.tech
"""


from __future__ import absolute_import

import re  # noqa: F401

from pydantic import validate_arguments, ValidationError
from typing_extensions import Annotated

from pydantic import Field, StrictStr, conint, constr

from typing import List, Literal, Optional

from twitter import models
from twitter.models import Get2ListsIdResponse, Get2UsersIdFollowedListsResponse, Get2UsersIdListMembershipsResponse, Get2UsersIdOwnedListsResponse, Get2UsersIdPinnedListsResponse, ListAddUserRequest, ListCreateRequest, ListCreateResponse, ListDeleteResponse, ListFollowedRequest, ListFollowedResponse, ListMutateResponse, ListPinnedRequest, ListPinnedResponse, ListUnpinResponse, ListUpdateRequest, ListUpdateResponse

from twitter.api_client import ApiClient
from twitter.exceptions import (  # noqa: F401
    ApiTypeError,
    ApiValueError
)


class ListsApi(object):
    """NOTE: This class is auto generated by OpenAPI Generator
    Ref: https://openapi-generator.tech

    Do not edit the class manually.
    """

    def __init__(self, api_client=None):
        if api_client is None:
            api_client = ApiClient()
        self.api_client = api_client

    @validate_arguments
    def get_user_list_memberships(self, id : Annotated[constr(strict=True, regex=r'/^[0-9]{1,19}$/'), Field(..., description="The ID of the User to lookup.")], max_results : Annotated[Optional[conint(strict=True, ge=100, le=1)], Field(description="The maximum number of results.")] = None, pagination_token : Annotated[Optional[constr(strict=True, max_length=19, min_length=1)], Field(description="This parameter is used to get a specified 'page' of results.")] = None, list_fields : Annotated[Optional[List[Literal['created_at', 'description', 'follower_count', 'id', 'member_count', 'name', 'owner_id', 'private']]], Field(description="A comma separated list of List fields to display.", unique_items=True)] = None, expansions : Annotated[Optional[List[Literal['owner_id']]], Field(description="A comma separated list of fields to expand.", unique_items=True)] = None, user_fields : Annotated[Optional[List[Literal['created_at', 'description', 'entities', 'id', 'location', 'name', 'pinned_tweet_id', 'profile_image_url', 'protected', 'public_metrics', 'url', 'username', 'verified', 'withheld']]], Field(description="A comma separated list of User fields to display.", unique_items=True)] = None, **kwargs) -> Get2UsersIdListMembershipsResponse:  # noqa: E501
        """Get a User's List Memberships  # noqa: E501

        Get a User's List Memberships.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_user_list_memberships(id, max_results, pagination_token, list_fields, expansions, user_fields, async_req=True)
        >>> result = thread.get()

        :param id: The ID of the User to lookup. (required)
        :type id: str
        :param max_results: The maximum number of results.
        :type max_results: int
        :param pagination_token: This parameter is used to get a specified 'page' of results.
        :type pagination_token: str
        :param list_fields: A comma separated list of List fields to display.
        :type list_fields: List[str]
        :param expansions: A comma separated list of fields to expand.
        :type expansions: List[str]
        :param user_fields: A comma separated list of User fields to display.
        :type user_fields: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: Get2UsersIdListMembershipsResponse
        """
        kwargs['_return_http_data_only'] = True
        return self.get_user_list_memberships_with_http_info(id, max_results, pagination_token, list_fields, expansions, user_fields, **kwargs)  # noqa: E501

    @validate_arguments
    def get_user_list_memberships_with_http_info(self, id : Annotated[constr(strict=True, regex=r'/^[0-9]{1,19}$/'), Field(..., description="The ID of the User to lookup.")], max_results : Annotated[Optional[conint(strict=True, ge=100, le=1)], Field(description="The maximum number of results.")] = None, pagination_token : Annotated[Optional[constr(strict=True, max_length=19, min_length=1)], Field(description="This parameter is used to get a specified 'page' of results.")] = None, list_fields : Annotated[Optional[List[Literal['created_at', 'description', 'follower_count', 'id', 'member_count', 'name', 'owner_id', 'private']]], Field(description="A comma separated list of List fields to display.", unique_items=True)] = None, expansions : Annotated[Optional[List[Literal['owner_id']]], Field(description="A comma separated list of fields to expand.", unique_items=True)] = None, user_fields : Annotated[Optional[List[Literal['created_at', 'description', 'entities', 'id', 'location', 'name', 'pinned_tweet_id', 'profile_image_url', 'protected', 'public_metrics', 'url', 'username', 'verified', 'withheld']]], Field(description="A comma separated list of User fields to display.", unique_items=True)] = None, **kwargs):  # noqa: E501
        """Get a User's List Memberships  # noqa: E501

        Get a User's List Memberships.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_user_list_memberships_with_http_info(id, max_results, pagination_token, list_fields, expansions, user_fields, async_req=True)
        >>> result = thread.get()

        :param id: The ID of the User to lookup. (required)
        :type id: str
        :param max_results: The maximum number of results.
        :type max_results: int
        :param pagination_token: This parameter is used to get a specified 'page' of results.
        :type pagination_token: str
        :param list_fields: A comma separated list of List fields to display.
        :type list_fields: List[str]
        :param expansions: A comma separated list of fields to expand.
        :type expansions: List[str]
        :param user_fields: A comma separated list of User fields to display.
        :type user_fields: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(Get2UsersIdListMembershipsResponse, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'id',
            'max_results',
            'pagination_token',
            'list_fields',
            'expansions',
            'user_fields'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in local_var_params['kwargs'].items():
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_user_list_memberships" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        collection_formats = {}

        path_params = {}
        if local_var_params['id']:
            path_params['id'] = local_var_params['id']

        query_params = []
        if local_var_params.get('max_results') is not None:  # noqa: E501
            query_params.append(('max_results', local_var_params['max_results']))
        if local_var_params.get('pagination_token') is not None:  # noqa: E501
            query_params.append(('pagination_token', local_var_params['pagination_token']))
        if local_var_params.get('list_fields') is not None:  # noqa: E501
            query_params.append(('list.fields', local_var_params['list_fields']))
            collection_formats['list.fields'] = 'csv'
        if local_var_params.get('expansions') is not None:  # noqa: E501
            query_params.append(('expansions', local_var_params['expansions']))
            collection_formats['expansions'] = 'csv'
        if local_var_params.get('user_fields') is not None:  # noqa: E501
            query_params.append(('user.fields', local_var_params['user_fields']))
            collection_formats['user.fields'] = 'csv'

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'application/problem+json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BearerToken', 'OAuth2UserToken', 'UserToken']  # noqa: E501

        response_types_map = {
            200: "Get2UsersIdListMembershipsResponse",
        }

        return self.api_client.call_api(
            '/2/users/{id}/list_memberships', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    @validate_arguments
    def list_add_member(self, id : Annotated[constr(strict=True, regex=r'/^[0-9]{1,19}$/'), Field(..., description="The ID of the List for which to add a member.")], list_add_user_request : Optional[ListAddUserRequest] = None, **kwargs) -> ListMutateResponse:  # noqa: E501
        """Add a List member  # noqa: E501

        Causes a User to become a member of a List.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.list_add_member(id, list_add_user_request, async_req=True)
        >>> result = thread.get()

        :param id: The ID of the List for which to add a member. (required)
        :type id: str
        :param list_add_user_request:
        :type list_add_user_request: ListAddUserRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ListMutateResponse
        """
        kwargs['_return_http_data_only'] = True
        return self.list_add_member_with_http_info(id, list_add_user_request, **kwargs)  # noqa: E501

    @validate_arguments
    def list_add_member_with_http_info(self, id : Annotated[constr(strict=True, regex=r'/^[0-9]{1,19}$/'), Field(..., description="The ID of the List for which to add a member.")], list_add_user_request : Optional[ListAddUserRequest] = None, **kwargs):  # noqa: E501
        """Add a List member  # noqa: E501

        Causes a User to become a member of a List.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.list_add_member_with_http_info(id, list_add_user_request, async_req=True)
        >>> result = thread.get()

        :param id: The ID of the List for which to add a member. (required)
        :type id: str
        :param list_add_user_request:
        :type list_add_user_request: ListAddUserRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ListMutateResponse, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'id',
            'list_add_user_request'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in local_var_params['kwargs'].items():
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_add_member" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        collection_formats = {}

        path_params = {}
        if local_var_params['id']:
            path_params['id'] = local_var_params['id']

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        if local_var_params['list_add_user_request']:
            body_params = local_var_params['list_add_user_request']

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'application/problem+json'])  # noqa: E501

        # HTTP header `Content-Type`
        content_types_list = local_var_params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if content_types_list:
                header_params['Content-Type'] = content_types_list

        # Authentication setting
        auth_settings = ['OAuth2UserToken', 'UserToken']  # noqa: E501

        response_types_map = {
            200: "ListMutateResponse",
        }

        return self.api_client.call_api(
            '/2/lists/{id}/members', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    @validate_arguments
    def list_id_create(self, list_create_request : Optional[ListCreateRequest] = None, **kwargs) -> ListCreateResponse:  # noqa: E501
        """Create List  # noqa: E501

        Creates a new List.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.list_id_create(list_create_request, async_req=True)
        >>> result = thread.get()

        :param list_create_request:
        :type list_create_request: ListCreateRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ListCreateResponse
        """
        kwargs['_return_http_data_only'] = True
        return self.list_id_create_with_http_info(list_create_request, **kwargs)  # noqa: E501

    @validate_arguments
    def list_id_create_with_http_info(self, list_create_request : Optional[ListCreateRequest] = None, **kwargs):  # noqa: E501
        """Create List  # noqa: E501

        Creates a new List.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.list_id_create_with_http_info(list_create_request, async_req=True)
        >>> result = thread.get()

        :param list_create_request:
        :type list_create_request: ListCreateRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ListCreateResponse, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'list_create_request'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in local_var_params['kwargs'].items():
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_id_create" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        if local_var_params['list_create_request']:
            body_params = local_var_params['list_create_request']

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'application/problem+json'])  # noqa: E501

        # HTTP header `Content-Type`
        content_types_list = local_var_params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if content_types_list:
                header_params['Content-Type'] = content_types_list

        # Authentication setting
        auth_settings = ['OAuth2UserToken', 'UserToken']  # noqa: E501

        response_types_map = {
            200: "ListCreateResponse",
        }

        return self.api_client.call_api(
            '/2/lists', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    @validate_arguments
    def list_id_delete(self, id : Annotated[constr(strict=True, regex=r'/^[0-9]{1,19}$/'), Field(..., description="The ID of the List to delete.")], **kwargs) -> ListDeleteResponse:  # noqa: E501
        """Delete List  # noqa: E501

        Delete a List that you own.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.list_id_delete(id, async_req=True)
        >>> result = thread.get()

        :param id: The ID of the List to delete. (required)
        :type id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ListDeleteResponse
        """
        kwargs['_return_http_data_only'] = True
        return self.list_id_delete_with_http_info(id, **kwargs)  # noqa: E501

    @validate_arguments
    def list_id_delete_with_http_info(self, id : Annotated[constr(strict=True, regex=r'/^[0-9]{1,19}$/'), Field(..., description="The ID of the List to delete.")], **kwargs):  # noqa: E501
        """Delete List  # noqa: E501

        Delete a List that you own.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.list_id_delete_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param id: The ID of the List to delete. (required)
        :type id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ListDeleteResponse, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in local_var_params['kwargs'].items():
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_id_delete" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        collection_formats = {}

        path_params = {}
        if local_var_params['id']:
            path_params['id'] = local_var_params['id']

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'application/problem+json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['OAuth2UserToken', 'UserToken']  # noqa: E501

        response_types_map = {
            200: "ListDeleteResponse",
        }

        return self.api_client.call_api(
            '/2/lists/{id}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    @validate_arguments
    def list_id_get(self, id : Annotated[constr(strict=True, regex=r'/^[0-9]{1,19}$/'), Field(..., description="The ID of the List.")], list_fields : Annotated[Optional[List[Literal['created_at', 'description', 'follower_count', 'id', 'member_count', 'name', 'owner_id', 'private']]], Field(description="A comma separated list of List fields to display.", unique_items=True)] = None, expansions : Annotated[Optional[List[Literal['owner_id']]], Field(description="A comma separated list of fields to expand.", unique_items=True)] = None, user_fields : Annotated[Optional[List[Literal['created_at', 'description', 'entities', 'id', 'location', 'name', 'pinned_tweet_id', 'profile_image_url', 'protected', 'public_metrics', 'url', 'username', 'verified', 'withheld']]], Field(description="A comma separated list of User fields to display.", unique_items=True)] = None, **kwargs) -> Get2ListsIdResponse:  # noqa: E501
        """List lookup by List ID.  # noqa: E501

        Returns a List.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.list_id_get(id, list_fields, expansions, user_fields, async_req=True)
        >>> result = thread.get()

        :param id: The ID of the List. (required)
        :type id: str
        :param list_fields: A comma separated list of List fields to display.
        :type list_fields: List[str]
        :param expansions: A comma separated list of fields to expand.
        :type expansions: List[str]
        :param user_fields: A comma separated list of User fields to display.
        :type user_fields: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: Get2ListsIdResponse
        """
        kwargs['_return_http_data_only'] = True
        return self.list_id_get_with_http_info(id, list_fields, expansions, user_fields, **kwargs)  # noqa: E501

    @validate_arguments
    def list_id_get_with_http_info(self, id : Annotated[constr(strict=True, regex=r'/^[0-9]{1,19}$/'), Field(..., description="The ID of the List.")], list_fields : Annotated[Optional[List[Literal['created_at', 'description', 'follower_count', 'id', 'member_count', 'name', 'owner_id', 'private']]], Field(description="A comma separated list of List fields to display.", unique_items=True)] = None, expansions : Annotated[Optional[List[Literal['owner_id']]], Field(description="A comma separated list of fields to expand.", unique_items=True)] = None, user_fields : Annotated[Optional[List[Literal['created_at', 'description', 'entities', 'id', 'location', 'name', 'pinned_tweet_id', 'profile_image_url', 'protected', 'public_metrics', 'url', 'username', 'verified', 'withheld']]], Field(description="A comma separated list of User fields to display.", unique_items=True)] = None, **kwargs):  # noqa: E501
        """List lookup by List ID.  # noqa: E501

        Returns a List.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.list_id_get_with_http_info(id, list_fields, expansions, user_fields, async_req=True)
        >>> result = thread.get()

        :param id: The ID of the List. (required)
        :type id: str
        :param list_fields: A comma separated list of List fields to display.
        :type list_fields: List[str]
        :param expansions: A comma separated list of fields to expand.
        :type expansions: List[str]
        :param user_fields: A comma separated list of User fields to display.
        :type user_fields: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(Get2ListsIdResponse, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'id',
            'list_fields',
            'expansions',
            'user_fields'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in local_var_params['kwargs'].items():
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_id_get" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        collection_formats = {}

        path_params = {}
        if local_var_params['id']:
            path_params['id'] = local_var_params['id']

        query_params = []
        if local_var_params.get('list_fields') is not None:  # noqa: E501
            query_params.append(('list.fields', local_var_params['list_fields']))
            collection_formats['list.fields'] = 'csv'
        if local_var_params.get('expansions') is not None:  # noqa: E501
            query_params.append(('expansions', local_var_params['expansions']))
            collection_formats['expansions'] = 'csv'
        if local_var_params.get('user_fields') is not None:  # noqa: E501
            query_params.append(('user.fields', local_var_params['user_fields']))
            collection_formats['user.fields'] = 'csv'

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'application/problem+json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BearerToken', 'OAuth2UserToken', 'UserToken']  # noqa: E501

        response_types_map = {
            200: "Get2ListsIdResponse",
        }

        return self.api_client.call_api(
            '/2/lists/{id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    @validate_arguments
    def list_id_update(self, id : Annotated[constr(strict=True, regex=r'/^[0-9]{1,19}$/'), Field(..., description="The ID of the List to modify.")], list_update_request : Optional[ListUpdateRequest] = None, **kwargs) -> ListUpdateResponse:  # noqa: E501
        """Update List.  # noqa: E501

        Update a List that you own.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.list_id_update(id, list_update_request, async_req=True)
        >>> result = thread.get()

        :param id: The ID of the List to modify. (required)
        :type id: str
        :param list_update_request:
        :type list_update_request: ListUpdateRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ListUpdateResponse
        """
        kwargs['_return_http_data_only'] = True
        return self.list_id_update_with_http_info(id, list_update_request, **kwargs)  # noqa: E501

    @validate_arguments
    def list_id_update_with_http_info(self, id : Annotated[constr(strict=True, regex=r'/^[0-9]{1,19}$/'), Field(..., description="The ID of the List to modify.")], list_update_request : Optional[ListUpdateRequest] = None, **kwargs):  # noqa: E501
        """Update List.  # noqa: E501

        Update a List that you own.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.list_id_update_with_http_info(id, list_update_request, async_req=True)
        >>> result = thread.get()

        :param id: The ID of the List to modify. (required)
        :type id: str
        :param list_update_request:
        :type list_update_request: ListUpdateRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ListUpdateResponse, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'id',
            'list_update_request'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in local_var_params['kwargs'].items():
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_id_update" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        collection_formats = {}

        path_params = {}
        if local_var_params['id']:
            path_params['id'] = local_var_params['id']

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        if local_var_params['list_update_request']:
            body_params = local_var_params['list_update_request']

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'application/problem+json'])  # noqa: E501

        # HTTP header `Content-Type`
        content_types_list = local_var_params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if content_types_list:
                header_params['Content-Type'] = content_types_list

        # Authentication setting
        auth_settings = ['OAuth2UserToken', 'UserToken']  # noqa: E501

        response_types_map = {
            200: "ListUpdateResponse",
        }

        return self.api_client.call_api(
            '/2/lists/{id}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    @validate_arguments
    def list_remove_member(self, id : Annotated[constr(strict=True, regex=r'/^[0-9]{1,19}$/'), Field(..., description="The ID of the List to remove a member.")], user_id : Annotated[constr(strict=True, regex=r'/^[0-9]{1,19}$/'), Field(..., description="The ID of User that will be removed from the List.")], **kwargs) -> ListMutateResponse:  # noqa: E501
        """Remove a List member  # noqa: E501

        Causes a User to be removed from the members of a List.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.list_remove_member(id, user_id, async_req=True)
        >>> result = thread.get()

        :param id: The ID of the List to remove a member. (required)
        :type id: str
        :param user_id: The ID of User that will be removed from the List. (required)
        :type user_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ListMutateResponse
        """
        kwargs['_return_http_data_only'] = True
        return self.list_remove_member_with_http_info(id, user_id, **kwargs)  # noqa: E501

    @validate_arguments
    def list_remove_member_with_http_info(self, id : Annotated[constr(strict=True, regex=r'/^[0-9]{1,19}$/'), Field(..., description="The ID of the List to remove a member.")], user_id : Annotated[constr(strict=True, regex=r'/^[0-9]{1,19}$/'), Field(..., description="The ID of User that will be removed from the List.")], **kwargs):  # noqa: E501
        """Remove a List member  # noqa: E501

        Causes a User to be removed from the members of a List.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.list_remove_member_with_http_info(id, user_id, async_req=True)
        >>> result = thread.get()

        :param id: The ID of the List to remove a member. (required)
        :type id: str
        :param user_id: The ID of User that will be removed from the List. (required)
        :type user_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ListMutateResponse, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'id',
            'user_id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in local_var_params['kwargs'].items():
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_remove_member" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        collection_formats = {}

        path_params = {}
        if local_var_params['id']:
            path_params['id'] = local_var_params['id']
        if local_var_params['user_id']:
            path_params['user_id'] = local_var_params['user_id']

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'application/problem+json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['OAuth2UserToken', 'UserToken']  # noqa: E501

        response_types_map = {
            200: "ListMutateResponse",
        }

        return self.api_client.call_api(
            '/2/lists/{id}/members/{user_id}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    @validate_arguments
    def list_user_follow(self, id : Annotated[StrictStr, Field(..., description="The ID of the authenticated source User that will follow the List.")], list_followed_request : Optional[ListFollowedRequest] = None, **kwargs) -> ListFollowedResponse:  # noqa: E501
        """Follow a List  # noqa: E501

        Causes a User to follow a List.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.list_user_follow(id, list_followed_request, async_req=True)
        >>> result = thread.get()

        :param id: The ID of the authenticated source User that will follow the List. (required)
        :type id: str
        :param list_followed_request:
        :type list_followed_request: ListFollowedRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ListFollowedResponse
        """
        kwargs['_return_http_data_only'] = True
        return self.list_user_follow_with_http_info(id, list_followed_request, **kwargs)  # noqa: E501

    @validate_arguments
    def list_user_follow_with_http_info(self, id : Annotated[StrictStr, Field(..., description="The ID of the authenticated source User that will follow the List.")], list_followed_request : Optional[ListFollowedRequest] = None, **kwargs):  # noqa: E501
        """Follow a List  # noqa: E501

        Causes a User to follow a List.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.list_user_follow_with_http_info(id, list_followed_request, async_req=True)
        >>> result = thread.get()

        :param id: The ID of the authenticated source User that will follow the List. (required)
        :type id: str
        :param list_followed_request:
        :type list_followed_request: ListFollowedRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ListFollowedResponse, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'id',
            'list_followed_request'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in local_var_params['kwargs'].items():
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_user_follow" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        collection_formats = {}

        path_params = {}
        if local_var_params['id']:
            path_params['id'] = local_var_params['id']

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        if local_var_params['list_followed_request']:
            body_params = local_var_params['list_followed_request']

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'application/problem+json'])  # noqa: E501

        # HTTP header `Content-Type`
        content_types_list = local_var_params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if content_types_list:
                header_params['Content-Type'] = content_types_list

        # Authentication setting
        auth_settings = ['OAuth2UserToken', 'UserToken']  # noqa: E501

        response_types_map = {
            200: "ListFollowedResponse",
        }

        return self.api_client.call_api(
            '/2/users/{id}/followed_lists', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    @validate_arguments
    def list_user_owned_lists(self, id : Annotated[constr(strict=True, regex=r'/^[0-9]{1,19}$/'), Field(..., description="The ID of the User to lookup.")], max_results : Annotated[Optional[conint(strict=True, ge=100, le=1)], Field(description="The maximum number of results.")] = None, pagination_token : Annotated[Optional[constr(strict=True, max_length=19, min_length=1)], Field(description="This parameter is used to get a specified 'page' of results.")] = None, list_fields : Annotated[Optional[List[Literal['created_at', 'description', 'follower_count', 'id', 'member_count', 'name', 'owner_id', 'private']]], Field(description="A comma separated list of List fields to display.", unique_items=True)] = None, expansions : Annotated[Optional[List[Literal['owner_id']]], Field(description="A comma separated list of fields to expand.", unique_items=True)] = None, user_fields : Annotated[Optional[List[Literal['created_at', 'description', 'entities', 'id', 'location', 'name', 'pinned_tweet_id', 'profile_image_url', 'protected', 'public_metrics', 'url', 'username', 'verified', 'withheld']]], Field(description="A comma separated list of User fields to display.", unique_items=True)] = None, **kwargs) -> Get2UsersIdOwnedListsResponse:  # noqa: E501
        """Get a User's Owned Lists.  # noqa: E501

        Get a User's Owned Lists.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.list_user_owned_lists(id, max_results, pagination_token, list_fields, expansions, user_fields, async_req=True)
        >>> result = thread.get()

        :param id: The ID of the User to lookup. (required)
        :type id: str
        :param max_results: The maximum number of results.
        :type max_results: int
        :param pagination_token: This parameter is used to get a specified 'page' of results.
        :type pagination_token: str
        :param list_fields: A comma separated list of List fields to display.
        :type list_fields: List[str]
        :param expansions: A comma separated list of fields to expand.
        :type expansions: List[str]
        :param user_fields: A comma separated list of User fields to display.
        :type user_fields: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: Get2UsersIdOwnedListsResponse
        """
        kwargs['_return_http_data_only'] = True
        return self.list_user_owned_lists_with_http_info(id, max_results, pagination_token, list_fields, expansions, user_fields, **kwargs)  # noqa: E501

    @validate_arguments
    def list_user_owned_lists_with_http_info(self, id : Annotated[constr(strict=True, regex=r'/^[0-9]{1,19}$/'), Field(..., description="The ID of the User to lookup.")], max_results : Annotated[Optional[conint(strict=True, ge=100, le=1)], Field(description="The maximum number of results.")] = None, pagination_token : Annotated[Optional[constr(strict=True, max_length=19, min_length=1)], Field(description="This parameter is used to get a specified 'page' of results.")] = None, list_fields : Annotated[Optional[List[Literal['created_at', 'description', 'follower_count', 'id', 'member_count', 'name', 'owner_id', 'private']]], Field(description="A comma separated list of List fields to display.", unique_items=True)] = None, expansions : Annotated[Optional[List[Literal['owner_id']]], Field(description="A comma separated list of fields to expand.", unique_items=True)] = None, user_fields : Annotated[Optional[List[Literal['created_at', 'description', 'entities', 'id', 'location', 'name', 'pinned_tweet_id', 'profile_image_url', 'protected', 'public_metrics', 'url', 'username', 'verified', 'withheld']]], Field(description="A comma separated list of User fields to display.", unique_items=True)] = None, **kwargs):  # noqa: E501
        """Get a User's Owned Lists.  # noqa: E501

        Get a User's Owned Lists.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.list_user_owned_lists_with_http_info(id, max_results, pagination_token, list_fields, expansions, user_fields, async_req=True)
        >>> result = thread.get()

        :param id: The ID of the User to lookup. (required)
        :type id: str
        :param max_results: The maximum number of results.
        :type max_results: int
        :param pagination_token: This parameter is used to get a specified 'page' of results.
        :type pagination_token: str
        :param list_fields: A comma separated list of List fields to display.
        :type list_fields: List[str]
        :param expansions: A comma separated list of fields to expand.
        :type expansions: List[str]
        :param user_fields: A comma separated list of User fields to display.
        :type user_fields: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(Get2UsersIdOwnedListsResponse, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'id',
            'max_results',
            'pagination_token',
            'list_fields',
            'expansions',
            'user_fields'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in local_var_params['kwargs'].items():
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_user_owned_lists" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        collection_formats = {}

        path_params = {}
        if local_var_params['id']:
            path_params['id'] = local_var_params['id']

        query_params = []
        if local_var_params.get('max_results') is not None:  # noqa: E501
            query_params.append(('max_results', local_var_params['max_results']))
        if local_var_params.get('pagination_token') is not None:  # noqa: E501
            query_params.append(('pagination_token', local_var_params['pagination_token']))
        if local_var_params.get('list_fields') is not None:  # noqa: E501
            query_params.append(('list.fields', local_var_params['list_fields']))
            collection_formats['list.fields'] = 'csv'
        if local_var_params.get('expansions') is not None:  # noqa: E501
            query_params.append(('expansions', local_var_params['expansions']))
            collection_formats['expansions'] = 'csv'
        if local_var_params.get('user_fields') is not None:  # noqa: E501
            query_params.append(('user.fields', local_var_params['user_fields']))
            collection_formats['user.fields'] = 'csv'

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'application/problem+json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BearerToken', 'OAuth2UserToken', 'UserToken']  # noqa: E501

        response_types_map = {
            200: "Get2UsersIdOwnedListsResponse",
        }

        return self.api_client.call_api(
            '/2/users/{id}/owned_lists', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    @validate_arguments
    def list_user_pin(self, id : Annotated[StrictStr, Field(..., description="The ID of the authenticated source User that will pin the List.")], list_pinned_request : ListPinnedRequest, **kwargs) -> ListPinnedResponse:  # noqa: E501
        """Pin a List  # noqa: E501

        Causes a User to pin a List.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.list_user_pin(id, list_pinned_request, async_req=True)
        >>> result = thread.get()

        :param id: The ID of the authenticated source User that will pin the List. (required)
        :type id: str
        :param list_pinned_request: (required)
        :type list_pinned_request: ListPinnedRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ListPinnedResponse
        """
        kwargs['_return_http_data_only'] = True
        return self.list_user_pin_with_http_info(id, list_pinned_request, **kwargs)  # noqa: E501

    @validate_arguments
    def list_user_pin_with_http_info(self, id : Annotated[StrictStr, Field(..., description="The ID of the authenticated source User that will pin the List.")], list_pinned_request : ListPinnedRequest, **kwargs):  # noqa: E501
        """Pin a List  # noqa: E501

        Causes a User to pin a List.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.list_user_pin_with_http_info(id, list_pinned_request, async_req=True)
        >>> result = thread.get()

        :param id: The ID of the authenticated source User that will pin the List. (required)
        :type id: str
        :param list_pinned_request: (required)
        :type list_pinned_request: ListPinnedRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ListPinnedResponse, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'id',
            'list_pinned_request'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in local_var_params['kwargs'].items():
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_user_pin" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        collection_formats = {}

        path_params = {}
        if local_var_params['id']:
            path_params['id'] = local_var_params['id']

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        if local_var_params['list_pinned_request']:
            body_params = local_var_params['list_pinned_request']

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'application/problem+json'])  # noqa: E501

        # HTTP header `Content-Type`
        content_types_list = local_var_params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if content_types_list:
                header_params['Content-Type'] = content_types_list

        # Authentication setting
        auth_settings = ['OAuth2UserToken', 'UserToken']  # noqa: E501

        response_types_map = {
            200: "ListPinnedResponse",
        }

        return self.api_client.call_api(
            '/2/users/{id}/pinned_lists', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    @validate_arguments
    def list_user_pinned_lists(self, id : Annotated[StrictStr, Field(..., description="The ID of the authenticated source User for whom to return results.")], list_fields : Annotated[Optional[List[Literal['created_at', 'description', 'follower_count', 'id', 'member_count', 'name', 'owner_id', 'private']]], Field(description="A comma separated list of List fields to display.", unique_items=True)] = None, expansions : Annotated[Optional[List[Literal['owner_id']]], Field(description="A comma separated list of fields to expand.", unique_items=True)] = None, user_fields : Annotated[Optional[List[Literal['created_at', 'description', 'entities', 'id', 'location', 'name', 'pinned_tweet_id', 'profile_image_url', 'protected', 'public_metrics', 'url', 'username', 'verified', 'withheld']]], Field(description="A comma separated list of User fields to display.", unique_items=True)] = None, **kwargs) -> Get2UsersIdPinnedListsResponse:  # noqa: E501
        """Get a User's Pinned Lists  # noqa: E501

        Get a User's Pinned Lists.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.list_user_pinned_lists(id, list_fields, expansions, user_fields, async_req=True)
        >>> result = thread.get()

        :param id: The ID of the authenticated source User for whom to return results. (required)
        :type id: str
        :param list_fields: A comma separated list of List fields to display.
        :type list_fields: List[str]
        :param expansions: A comma separated list of fields to expand.
        :type expansions: List[str]
        :param user_fields: A comma separated list of User fields to display.
        :type user_fields: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: Get2UsersIdPinnedListsResponse
        """
        kwargs['_return_http_data_only'] = True
        return self.list_user_pinned_lists_with_http_info(id, list_fields, expansions, user_fields, **kwargs)  # noqa: E501

    @validate_arguments
    def list_user_pinned_lists_with_http_info(self, id : Annotated[StrictStr, Field(..., description="The ID of the authenticated source User for whom to return results.")], list_fields : Annotated[Optional[List[Literal['created_at', 'description', 'follower_count', 'id', 'member_count', 'name', 'owner_id', 'private']]], Field(description="A comma separated list of List fields to display.", unique_items=True)] = None, expansions : Annotated[Optional[List[Literal['owner_id']]], Field(description="A comma separated list of fields to expand.", unique_items=True)] = None, user_fields : Annotated[Optional[List[Literal['created_at', 'description', 'entities', 'id', 'location', 'name', 'pinned_tweet_id', 'profile_image_url', 'protected', 'public_metrics', 'url', 'username', 'verified', 'withheld']]], Field(description="A comma separated list of User fields to display.", unique_items=True)] = None, **kwargs):  # noqa: E501
        """Get a User's Pinned Lists  # noqa: E501

        Get a User's Pinned Lists.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.list_user_pinned_lists_with_http_info(id, list_fields, expansions, user_fields, async_req=True)
        >>> result = thread.get()

        :param id: The ID of the authenticated source User for whom to return results. (required)
        :type id: str
        :param list_fields: A comma separated list of List fields to display.
        :type list_fields: List[str]
        :param expansions: A comma separated list of fields to expand.
        :type expansions: List[str]
        :param user_fields: A comma separated list of User fields to display.
        :type user_fields: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(Get2UsersIdPinnedListsResponse, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'id',
            'list_fields',
            'expansions',
            'user_fields'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in local_var_params['kwargs'].items():
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_user_pinned_lists" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        collection_formats = {}

        path_params = {}
        if local_var_params['id']:
            path_params['id'] = local_var_params['id']

        query_params = []
        if local_var_params.get('list_fields') is not None:  # noqa: E501
            query_params.append(('list.fields', local_var_params['list_fields']))
            collection_formats['list.fields'] = 'csv'
        if local_var_params.get('expansions') is not None:  # noqa: E501
            query_params.append(('expansions', local_var_params['expansions']))
            collection_formats['expansions'] = 'csv'
        if local_var_params.get('user_fields') is not None:  # noqa: E501
            query_params.append(('user.fields', local_var_params['user_fields']))
            collection_formats['user.fields'] = 'csv'

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'application/problem+json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['OAuth2UserToken', 'UserToken']  # noqa: E501

        response_types_map = {
            200: "Get2UsersIdPinnedListsResponse",
        }

        return self.api_client.call_api(
            '/2/users/{id}/pinned_lists', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    @validate_arguments
    def list_user_unfollow(self, id : Annotated[StrictStr, Field(..., description="The ID of the authenticated source User that will unfollow the List.")], list_id : Annotated[constr(strict=True, regex=r'/^[0-9]{1,19}$/'), Field(..., description="The ID of the List to unfollow.")], **kwargs) -> ListFollowedResponse:  # noqa: E501
        """Unfollow a List  # noqa: E501

        Causes a User to unfollow a List.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.list_user_unfollow(id, list_id, async_req=True)
        >>> result = thread.get()

        :param id: The ID of the authenticated source User that will unfollow the List. (required)
        :type id: str
        :param list_id: The ID of the List to unfollow. (required)
        :type list_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ListFollowedResponse
        """
        kwargs['_return_http_data_only'] = True
        return self.list_user_unfollow_with_http_info(id, list_id, **kwargs)  # noqa: E501

    @validate_arguments
    def list_user_unfollow_with_http_info(self, id : Annotated[StrictStr, Field(..., description="The ID of the authenticated source User that will unfollow the List.")], list_id : Annotated[constr(strict=True, regex=r'/^[0-9]{1,19}$/'), Field(..., description="The ID of the List to unfollow.")], **kwargs):  # noqa: E501
        """Unfollow a List  # noqa: E501

        Causes a User to unfollow a List.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.list_user_unfollow_with_http_info(id, list_id, async_req=True)
        >>> result = thread.get()

        :param id: The ID of the authenticated source User that will unfollow the List. (required)
        :type id: str
        :param list_id: The ID of the List to unfollow. (required)
        :type list_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ListFollowedResponse, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'id',
            'list_id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in local_var_params['kwargs'].items():
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_user_unfollow" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        collection_formats = {}

        path_params = {}
        if local_var_params['id']:
            path_params['id'] = local_var_params['id']
        if local_var_params['list_id']:
            path_params['list_id'] = local_var_params['list_id']

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'application/problem+json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['OAuth2UserToken', 'UserToken']  # noqa: E501

        response_types_map = {
            200: "ListFollowedResponse",
        }

        return self.api_client.call_api(
            '/2/users/{id}/followed_lists/{list_id}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    @validate_arguments
    def list_user_unpin(self, id : Annotated[StrictStr, Field(..., description="The ID of the authenticated source User for whom to return results.")], list_id : Annotated[constr(strict=True, regex=r'/^[0-9]{1,19}$/'), Field(..., description="The ID of the List to unpin.")], **kwargs) -> ListUnpinResponse:  # noqa: E501
        """Unpin a List  # noqa: E501

        Causes a User to remove a pinned List.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.list_user_unpin(id, list_id, async_req=True)
        >>> result = thread.get()

        :param id: The ID of the authenticated source User for whom to return results. (required)
        :type id: str
        :param list_id: The ID of the List to unpin. (required)
        :type list_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ListUnpinResponse
        """
        kwargs['_return_http_data_only'] = True
        return self.list_user_unpin_with_http_info(id, list_id, **kwargs)  # noqa: E501

    @validate_arguments
    def list_user_unpin_with_http_info(self, id : Annotated[StrictStr, Field(..., description="The ID of the authenticated source User for whom to return results.")], list_id : Annotated[constr(strict=True, regex=r'/^[0-9]{1,19}$/'), Field(..., description="The ID of the List to unpin.")], **kwargs):  # noqa: E501
        """Unpin a List  # noqa: E501

        Causes a User to remove a pinned List.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.list_user_unpin_with_http_info(id, list_id, async_req=True)
        >>> result = thread.get()

        :param id: The ID of the authenticated source User for whom to return results. (required)
        :type id: str
        :param list_id: The ID of the List to unpin. (required)
        :type list_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ListUnpinResponse, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'id',
            'list_id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in local_var_params['kwargs'].items():
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_user_unpin" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        collection_formats = {}

        path_params = {}
        if local_var_params['id']:
            path_params['id'] = local_var_params['id']
        if local_var_params['list_id']:
            path_params['list_id'] = local_var_params['list_id']

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'application/problem+json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['OAuth2UserToken', 'UserToken']  # noqa: E501

        response_types_map = {
            200: "ListUnpinResponse",
        }

        return self.api_client.call_api(
            '/2/users/{id}/pinned_lists/{list_id}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    @validate_arguments
    def user_followed_lists(self, id : Annotated[constr(strict=True, regex=r'/^[0-9]{1,19}$/'), Field(..., description="The ID of the User to lookup.")], max_results : Annotated[Optional[conint(strict=True, ge=100, le=1)], Field(description="The maximum number of results.")] = None, pagination_token : Annotated[Optional[constr(strict=True, max_length=19, min_length=1)], Field(description="This parameter is used to get a specified 'page' of results.")] = None, list_fields : Annotated[Optional[List[Literal['created_at', 'description', 'follower_count', 'id', 'member_count', 'name', 'owner_id', 'private']]], Field(description="A comma separated list of List fields to display.", unique_items=True)] = None, expansions : Annotated[Optional[List[Literal['owner_id']]], Field(description="A comma separated list of fields to expand.", unique_items=True)] = None, user_fields : Annotated[Optional[List[Literal['created_at', 'description', 'entities', 'id', 'location', 'name', 'pinned_tweet_id', 'profile_image_url', 'protected', 'public_metrics', 'url', 'username', 'verified', 'withheld']]], Field(description="A comma separated list of User fields to display.", unique_items=True)] = None, **kwargs) -> Get2UsersIdFollowedListsResponse:  # noqa: E501
        """Get User's Followed Lists  # noqa: E501

        Returns a User's followed Lists.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.user_followed_lists(id, max_results, pagination_token, list_fields, expansions, user_fields, async_req=True)
        >>> result = thread.get()

        :param id: The ID of the User to lookup. (required)
        :type id: str
        :param max_results: The maximum number of results.
        :type max_results: int
        :param pagination_token: This parameter is used to get a specified 'page' of results.
        :type pagination_token: str
        :param list_fields: A comma separated list of List fields to display.
        :type list_fields: List[str]
        :param expansions: A comma separated list of fields to expand.
        :type expansions: List[str]
        :param user_fields: A comma separated list of User fields to display.
        :type user_fields: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: Get2UsersIdFollowedListsResponse
        """
        kwargs['_return_http_data_only'] = True
        return self.user_followed_lists_with_http_info(id, max_results, pagination_token, list_fields, expansions, user_fields, **kwargs)  # noqa: E501

    @validate_arguments
    def user_followed_lists_with_http_info(self, id : Annotated[constr(strict=True, regex=r'/^[0-9]{1,19}$/'), Field(..., description="The ID of the User to lookup.")], max_results : Annotated[Optional[conint(strict=True, ge=100, le=1)], Field(description="The maximum number of results.")] = None, pagination_token : Annotated[Optional[constr(strict=True, max_length=19, min_length=1)], Field(description="This parameter is used to get a specified 'page' of results.")] = None, list_fields : Annotated[Optional[List[Literal['created_at', 'description', 'follower_count', 'id', 'member_count', 'name', 'owner_id', 'private']]], Field(description="A comma separated list of List fields to display.", unique_items=True)] = None, expansions : Annotated[Optional[List[Literal['owner_id']]], Field(description="A comma separated list of fields to expand.", unique_items=True)] = None, user_fields : Annotated[Optional[List[Literal['created_at', 'description', 'entities', 'id', 'location', 'name', 'pinned_tweet_id', 'profile_image_url', 'protected', 'public_metrics', 'url', 'username', 'verified', 'withheld']]], Field(description="A comma separated list of User fields to display.", unique_items=True)] = None, **kwargs):  # noqa: E501
        """Get User's Followed Lists  # noqa: E501

        Returns a User's followed Lists.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.user_followed_lists_with_http_info(id, max_results, pagination_token, list_fields, expansions, user_fields, async_req=True)
        >>> result = thread.get()

        :param id: The ID of the User to lookup. (required)
        :type id: str
        :param max_results: The maximum number of results.
        :type max_results: int
        :param pagination_token: This parameter is used to get a specified 'page' of results.
        :type pagination_token: str
        :param list_fields: A comma separated list of List fields to display.
        :type list_fields: List[str]
        :param expansions: A comma separated list of fields to expand.
        :type expansions: List[str]
        :param user_fields: A comma separated list of User fields to display.
        :type user_fields: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(Get2UsersIdFollowedListsResponse, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'id',
            'max_results',
            'pagination_token',
            'list_fields',
            'expansions',
            'user_fields'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in local_var_params['kwargs'].items():
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method user_followed_lists" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        collection_formats = {}

        path_params = {}
        if local_var_params['id']:
            path_params['id'] = local_var_params['id']

        query_params = []
        if local_var_params.get('max_results') is not None:  # noqa: E501
            query_params.append(('max_results', local_var_params['max_results']))
        if local_var_params.get('pagination_token') is not None:  # noqa: E501
            query_params.append(('pagination_token', local_var_params['pagination_token']))
        if local_var_params.get('list_fields') is not None:  # noqa: E501
            query_params.append(('list.fields', local_var_params['list_fields']))
            collection_formats['list.fields'] = 'csv'
        if local_var_params.get('expansions') is not None:  # noqa: E501
            query_params.append(('expansions', local_var_params['expansions']))
            collection_formats['expansions'] = 'csv'
        if local_var_params.get('user_fields') is not None:  # noqa: E501
            query_params.append(('user.fields', local_var_params['user_fields']))
            collection_formats['user.fields'] = 'csv'

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'application/problem+json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BearerToken', 'OAuth2UserToken', 'UserToken']  # noqa: E501

        response_types_map = {
            200: "Get2UsersIdFollowedListsResponse",
        }

        return self.api_client.call_api(
            '/2/users/{id}/followed_lists', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))
